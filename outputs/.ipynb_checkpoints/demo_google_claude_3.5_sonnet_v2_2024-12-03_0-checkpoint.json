[
    {
        "index": 1,
        "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int unsigned AxiStreamWidth = 128,\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // MAC Table Entry Type\n    typedef struct packed {\n        logic        valid;\n        logic [47:0] mac_addr;\n        logic [1:0]  port;\n        logic [31:0] age_counter;\n    } mac_entry_t;\n\n    // State definitions\n    typedef enum logic [1:0] {\n        IDLE,\n        PARSE_HDR,\n        ROUTE_FRAME,\n        FORWARD\n    } state_t;\n\n    // Internal signals\n    state_t [NumPorts-1:0] state;\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n    logic [47:0] src_mac [NumPorts-1:0];\n    logic [47:0] dst_mac [NumPorts-1:0];\n    logic [NumPorts-1:0] is_broadcast;\n    logic [NumPorts-1:0] is_multicast;\n    logic [NumPorts-1:0][NumPorts-1:0] route_mask;\n    \n    // Reset all output ports\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            for (int i = 0; i < NumPorts; i++) begin\n                state[i] <= IDLE;\n                inTready[i] <= 1'b0;\n                outAxi4St[i] <= '0;\n            end\n            mac_table <= '{default:'0};\n            egressFifoDropEvents <= '0;\n        end\n    end\n\n    // MAC Learning Logic\n    always_ff @(posedge clock) begin\n        if (!reset) begin\n            for (int i = 0; i < NumPorts; i++) begin\n                if (inAxi4St[i].tvalid && state[i] == PARSE_HDR) begin\n                    logic found = 0;\n                    for (int j = 0; j < MacTableDepth; j++) begin\n                        if (mac_table[j].valid && mac_table[j].mac_addr == src_mac[i]) begin\n                            mac_table[j].port <= i[1:0];\n                            mac_table[j].age_counter <= '0;\n                            found = 1;\n                            break;\n                        end\n                    end\n                    \n                    if (!found) begin\n                        for (int j = 0; j < MacTableDepth; j++) begin\n                            if (!mac_table[j].valid) begin\n                                mac_table[j].valid <= 1'b1;\n                                mac_table[j].mac_addr <= src_mac[i];\n                                mac_table[j].port <= i[1:0];\n                                mac_table[j].age_counter <= '0;\n                                break;\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    // Aging Logic\n    always_ff @(posedge clock) begin\n        if (!reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                        mac_table[i].valid <= 1'b0;\n                    else\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                end\n            end\n        end\n    end\n\n    // Per-Port Logic\n    generate\n        for (genvar i = 0; i < NumPorts; i++) begin : port_logic\n            always_ff @(posedge clock) begin\n                if (reset) begin\n                    state[i] <= IDLE;\n                    src_mac[i] <= '0;\n                    dst_mac[i] <= '0;\n                    is_broadcast[i] <= 1'b0;\n                    is_multicast[i] <= 1'b0;\n                    route_mask[i] <= '0;\n                end else begin\n                    case (state[i])\n                        IDLE: begin\n                            inTready[i] <= 1'b1;\n                            if (inAxi4St[i].tvalid) begin\n                                dst_mac[i] <= inAxi4St[i].tdata[47:0];\n                                is_broadcast[i] <= &inAxi4St[i].tdata[47:0];\n                                is_multicast[i] <= inAxi4St[i].tdata[40];\n                                state[i] <= PARSE_HDR;\n                            end\n                        end\n\n                        PARSE_HDR: begin\n                            if (inAxi4St[i].tvalid) begin\n                                src_mac[i] <= inAxi4St[i].tdata[47:0];\n                                state[i] <= ROUTE_FRAME;\n                            end\n                        end\n\n                        ROUTE_FRAME: begin\n                            route_mask[i] <= '0;\n                            if (is_broadcast[i] || is_multicast[i]) begin\n                                for (int j = 0; j < NumPorts; j++) \n                                    route_mask[i][j] <= (j != i);\n                            end else begin\n                                logic found = 0;\n                                for (int j = 0; j < MacTableDepth; j++) begin\n                                    if (mac_table[j].valid && mac_table[j].mac_addr == dst_mac[i]) begin\n                                        route_mask[i][mac_table[j].port] <= (mac_table[j].port != i);\n                                        found = 1;\n                                        break;\n                                    end\n                                end\n                                if (!found) begin\n                                    for (int j = 0; j < NumPorts; j++)\n                                        route_mask[i][j] <= (j != i);\n                                end\n                            end\n                            state[i] <= FORWARD;\n                        end\n\n                        FORWARD: begin\n                            if (inAxi4St[i].tvalid) begin\n                                for (int j = 0; j < NumPorts; j++) begin\n                                    if (route_mask[i][j]) begin\n                                        outAxi4St[j] <= inAxi4St[i];\n                                    end\n                                end\n                                if (inAxi4St[i].tlast) begin\n                                    state[i] <= IDLE;\n                                end\n                            end\n                        end\n                    endcase\n                end\n            end\n        end\n    endgenerate\n\nendmodule",
        "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description of this Layer-2 Ethernet Switch:\n\nMain Functionality:\n1. The module is a 4-port Ethernet Switch that routes frames between ports based on MAC addresses\n2. Key features:\n   - Maintains a 16-entry MAC address table\n   - Learning capability: Learns source MAC addresses from incoming frames\n   - Routing capability: Routes frames based on destination MAC addresses\n   - Supports broadcast/multicast routing\n   - Prevents loopback (frames never exit the same port they entered)\n   - Ages out unused MAC table entries after specified time\n\nHigh-Level Block Diagram would consist of:\n\n1. Input Interface Block (\u00d74)\n   - AXI4-Stream input interfaces\n   - Ready/Valid handshaking\n   - Frame buffering\n\n2. MAC Learning Unit\n   - MAC address table (16 entries)\n   - Source MAC address detection\n   - Aging mechanism\n   - Table management logic\n\n3. Routing Decision Unit\n   - Destination MAC address lookup\n   - Broadcast/multicast detection\n   - Port mapping logic\n\n4. Output Interface Block (\u00d74)\n   - AXI4-Stream output interfaces\n   - Ready/Valid handshaking\n   - Frame forwarding logic\n\n5. Control Logic\n   - Clock domain handling\n   - Reset synchronization\n   - Overall control and coordination\n\nThe data flow would be:\nInput Port \u2192 MAC Learning \u2192 Routing Decision \u2192 Output Port(s)\n\nThe module uses AXI4-Stream protocol for data transfer, with backpressure capability through ready signals, and supports variable data width (defaulting to 128 bits) through parameters.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nKey Parameterizable Aspects:\n\n1. Number of Ports\n- Parameter: NumPorts\n- Default: 4\n- Reasoning: Common for small network switches, though could be scaled up/down\n\n2. AXI Stream Data Width\n- Parameter: AxiStreamWidth\n- Default: 128\n- Reasoning: Good balance of throughput and resource usage; matches common bus widths\n\n3. AXI Stream Type\n- Parameter: AxiStreamType\n- Default: local_pkg::axi4st_128_s\n- Reasoning: Allows flexibility in interface definition while providing a standard default\n\n4. MAC Table Depth\n- Parameter: MacTableDepth\n- Default: 16\n- Reasoning: Sufficient for small networks while keeping resource usage reasonable\n\n5. MAC Table Aging Time\n- Parameter: MacTableCyclesPerEpoch\n- Default: 32'd1_750_000_000\n- Reasoning: Approximately 7 seconds at 250MHz clock, reasonable for network stability\n\nAdditional Parameters that could be useful (though not specified in requirements):\n\n6. FIFO Depths\n- For input/output buffering\n- Reasonable default: 2048 bytes (to handle maximum frame size)\n\n7. Maximum Frame Size\n- Could be parameterizable\n- Default: 1504 bytes (as specified)\n\n8. Minimum Frame Size\n- Could be parameterizable\n- Default: 60 bytes (as specified)\n\nEach of these parameters affects different aspects of the design:\n- Resource utilization (FPGA resources)\n- Performance (throughput, latency)\n- Functionality (network size support, features)\n- Timing (clock frequency capabilities)\n\nThe current parameter set provides a good balance between functionality and implementation complexity while maintaining flexibility for different use cases.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing flow and required registers/logic:\n\nData Processing Flow:\n\n1. Input Processing:\nRegisters needed:\n- Input frame buffers (per port)\n- Frame state tracking registers\n- MAC address extraction registers\n\nLogic needed:\n- MAC address extraction logic\n- Frame validation logic\n- Input handshaking control\n\n2. MAC Table Management:\nRegisters needed:\n- MAC address table entries (16 \u00d7 48-bit MAC addresses)\n- Port mapping (16 \u00d7 log2(NumPorts) bits)\n- Age counters (16 \u00d7 counter width)\n- Valid bits (16 bits)\n\nLogic needed:\n- MAC address comparison logic\n- Age counter incrementer/checker\n- Table update control logic\n\n3. Routing Decision:\nRegisters needed:\n- Destination MAC lookup results\n- Port mapping decisions\n- Broadcast/multicast detection flags\n\nLogic needed:\n- MAC address lookup comparators\n- Broadcast/multicast detection\n- Port mapping logic\n- Loopback prevention logic\n\n4. Output Processing:\nRegisters needed:\n- Output frame buffers (per port)\n- Output state machines\n- Port availability flags\n\nLogic needed:\n- Output multiplexing logic\n- Frame forwarding control\n- Output handshaking logic\n\nKey Transformations:\n\n1. Input Stage:\n```\nif (inAxi4St[port].tvalid && inTready[port])\n    - Extract source MAC\n    - Buffer frame data\n    - Track frame boundaries (tlast)\n```\n\n2. MAC Learning:\n```\nif (new_frame_started)\n    - Compare source MAC with table entries\n    - Update/add table entry if needed\n    - Reset age counter for entry\n```\n\n3. Routing:\n```\nif (frame_header_received)\n    - Look up destination MAC\n    - Determine output port(s)\n    - Set up routing path\n```\n\n4. Output Stage:\n```\nfor each output port\n    if (outTready[port] && data_available)\n        - Forward frame data\n        - Maintain frame boundaries\n        - Handle backpressure\n```\n\nCombinational Logic Blocks:\n1. MAC address comparators\n2. Port mapping decoder\n3. Broadcast/multicast detection\n4. Age counter comparison\n5. Output port selection\n6. Handshaking control\n7. Frame boundary detection\n8. Error checking\n\nThis architecture ensures proper frame handling while maintaining the required routing and learning capabilities.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the timing and reset requirements based on the problem description:\n\nClocking Requirements:\n1. Single Clock Domain\n- The description specifies a single 'clock' input\n- All operations are synchronous to this clock\n- No explicit clock frequency requirement, but should support typical Ethernet speeds\n\nReset Requirements:\n1. Synchronous Reset\n- Explicitly specified as synchronous reset in the description\n- Active-high reset signal\n\nSignals Requiring Reset:\n1. Control Logic:\n- MAC table valid bits\n- Age counters\n- State machines\n- Port mapping registers\n\n2. Data Path:\n- Input/Output buffers\n- Frame tracking registers\n- Routing decision registers\n\n3. Interface Signals:\n- inTready signals\n- outAxi4St.tvalid signals\n- Internal control flags\n\nLatency Considerations:\n1. Input Processing:\n- Minimum 1-2 cycles for MAC address extraction\n- Additional cycles for table lookup\n\n2. MAC Table:\n- 1 cycle for comparison\n- 1-2 cycles for updates\n\n3. Routing Decision:\n- 1 cycle for destination lookup\n- 1 cycle for port mapping\n\n4. Output Processing:\n- 1+ cycles for buffer management\n- Variable cycles based on backpressure\n\nThroughput Requirements:\n1. AXI4-Stream Interface:\n- Must support full throughput when ready\n- Backpressure handled through ready signals\n\n2. Per Port:\n- For 128-bit data width:\n  * Maximum theoretical throughput = (128 bits/cycle) \u00d7 clock_frequency\n  * Must handle full line rate Ethernet frames\n\nTiming Constraints:\n1. Setup/Hold:\n- Standard synchronous design rules\n- All inputs sampled on rising clock edge\n\n2. Critical Paths:\n- MAC address comparison logic\n- Routing decision logic\n- Age counter comparisons\n\nExample Reset Sequence:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Reset control signals\n        for (int i = 0; i < NumPorts; i++) begin\n            inTready[i] <= 1'b0;\n            outAxi4St[i] <= '0;\n        end\n        \n        // Reset MAC table\n        for (int i = 0; i < MacTableDepth; i++) begin\n            mac_table[i].valid <= 1'b0;\n            mac_table[i].age_counter <= '0;\n        end\n        \n        // Reset state machines\n        current_state <= IDLE;\n        \n    end else begin\n        // Normal operation\n    end\nend\n```\n\nPerformance Considerations:\n1. Pipelining may be needed for:\n- MAC address comparisons\n- Table lookups\n- Routing decisions\n\n2. Buffering:\n- Input buffering for frame processing\n- Output buffering for multi-port transmission\n\n3. Critical Timing:\n- MAC table access time\n- Routing decision path\n- Age counter updates\n\nThe design should prioritize maintaining line rate throughput while managing backpressure appropriately.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the key test scenarios and assertions needed for this Ethernet Switch design:\n\nTest Scenarios:\n\n1. Basic Functionality Tests:\n```systemverilog\n- Single frame forwarding between two ports\n- MAC address learning verification\n- Broadcast frame handling\n- Multicast frame handling\n- Loopback prevention verification\n```\n\n2. MAC Table Tests:\n```systemverilog\n- Table addition of new MAC addresses\n- Table update with existing MAC addresses\n- Aging mechanism verification\n- Full table handling\n- Table replacement policy\n```\n\n3. Multi-Port Scenarios:\n```systemverilog\n- Simultaneous frame reception on multiple ports\n- Multiple destination routing\n- Broadcast storm handling\n- Port-to-port isolation verification\n```\n\n4. Error Conditions:\n```systemverilog\n- Invalid frame sizes\n- Corrupted frames\n- Buffer overflow conditions\n- Backpressure handling\n```\n\nKey Assertions:\n\n1. Interface Protocol Assertions:\n```systemverilog\n// AXI4-Stream Protocol\nproperty axi4_valid_ready;\n    @(posedge clock) disable iff (reset)\n    $fell(inAxi4St[*].tvalid) |-> !inTready[*];\nendproperty\nassert property(axi4_valid_ready);\n\n// TLAST must be asserted within max frame size\nproperty max_frame_size;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St[*].tvalid) |-> ##[1:1504] inAxi4St[*].tlast;\nendproperty\n```\n\n2. Functional Assertions:\n```systemverilog\n// No loopback\nproperty no_loopback;\n    @(posedge clock) disable iff (reset)\n    foreach(outAxi4St[i]) {\n        !(inAxi4St[i].tvalid && outAxi4St[i].tvalid);\n    }\nendproperty\n\n// MAC table consistency\nproperty mac_table_valid;\n    @(posedge clock) disable iff (reset)\n    mac_table.valid |-> mac_table.port < NumPorts;\nendproperty\n```\n\n3. Frame Handling Assertions:\n```systemverilog\n// Minimum frame size\nproperty min_frame_size;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St[*].tvalid) |-> ##[60:$] inAxi4St[*].tlast;\nendproperty\n\n// Frame continuity\nproperty frame_continuity;\n    @(posedge clock) disable iff (reset)\n    inAxi4St[*].tvalid && !inAxi4St[*].tlast |-> \n        ##1 (inAxi4St[*].tvalid || !inTready[*]);\nendproperty\n```\n\n4. Performance Assertions:\n```systemverilog\n// Backpressure response\nproperty backpressure_response;\n    @(posedge clock) disable iff (reset)\n    !outTready[*] |-> ##[1:5] !outAxi4St[*].tvalid;\nendproperty\n\n// MAC table aging\nproperty mac_age_timeout;\n    @(posedge clock) disable iff (reset)\n    (mac_table[*].age_counter >= MacTableCyclesPerEpoch) |-> \n        ##1 !mac_table[*].valid;\nendproperty\n```\n\nTest Coverage Requirements:\n\n1. Functional Coverage:\n- All ports used as source/destination\n- MAC table fully utilized\n- All frame size ranges\n- Broadcast/multicast scenarios\n- Backpressure conditions\n\n2. Code Coverage:\n- 100% statement coverage\n- 100% branch coverage\n- 100% FSM state/transition coverage\n- Toggle coverage for control signals\n\n3. Cross Coverage:\n- Port combinations\n- Frame sizes vs. port combinations\n- Backpressure scenarios vs. frame types\n\nTest Environment:\n```systemverilog\nmodule test_env;\n    // Clock generation\n    bit clock;\n    always #5 clock = !clock;\n\n    // Reset generation\n    logic reset;\n    initial begin\n        reset = 1;\n        @(posedge clock);\n        reset = 0;\n    end\n\n    // DUT instantiation\n    dut #(\n        .NumPorts(4),\n        .AxiStreamWidth(128)\n    ) dut_inst (.*);\n\n    // Test stimulus generation\n    // ... test scenarios ...\n\n    // Coverage collection\n    // ... coverage groups ...\n\n    // Assertion monitoring\n    // ... assertions ...\nendmodule\n```\n\nThese test scenarios and assertions should provide good coverage of the design's functionality and help catch potential issues early in the development process.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and their specific tasks:\n\n1. MAC Address Table Manager\n```systemverilog\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n) (\n    // Interface for learning\n    input  logic [47:0] src_mac,\n    input  logic [1:0]  src_port,\n    input  logic        learn_valid,\n    // Interface for lookup\n    input  logic [47:0] dst_mac,\n    output logic [1:0]  dst_port,\n    output logic        found_valid\n);\n```\nTasks:\n- Maintains MAC address table\n- Handles MAC address learning\n- Performs MAC address lookups\n- Manages aging mechanism\n- Updates/invalidates entries\n\n2. Frame Parser\n```systemverilog\nmodule frame_parser #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int AxiStreamWidth = 128\n) (\n    // AXI Stream input\n    input  AxiStreamType in_axi,\n    output logic        in_ready,\n    // Extracted information\n    output logic [47:0] dst_mac,\n    output logic [47:0] src_mac,\n    output logic        is_broadcast,\n    output logic        is_multicast\n);\n```\nTasks:\n- Extracts MAC addresses from frames\n- Identifies broadcast/multicast frames\n- Validates frame format\n- Handles frame boundaries\n\n3. Routing Decision Engine\n```systemverilog\nmodule routing_engine #(\n    parameter int NumPorts = 4\n) (\n    // Routing inputs\n    input  logic [1:0]  src_port,\n    input  logic [1:0]  dst_port,\n    input  logic        dst_valid,\n    input  logic        is_broadcast,\n    input  logic        is_multicast,\n    // Routing output\n    output logic [NumPorts-1:0] port_mask\n);\n```\nTasks:\n- Determines output port(s)\n- Implements routing rules\n- Prevents loopback\n- Handles broadcast/multicast routing\n\n4. Port Buffer Manager (one per port)\n```systemverilog\nmodule port_buffer #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n) (\n    // Input interface\n    input  AxiStreamType in_axi,\n    output logic        in_ready,\n    // Output interface\n    output AxiStreamType out_axi,\n    input  logic        out_ready\n);\n```\nTasks:\n- Buffers incoming frames\n- Handles backpressure\n- Maintains frame boundaries\n- Provides flow control\n\n5. Output Arbiter (one per output port)\n```systemverilog\nmodule output_arbiter #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int NumPorts = 4\n) (\n    // Input interfaces\n    input  AxiStreamType [NumPorts-1:0] in_axi,\n    output logic        [NumPorts-1:0] in_ready,\n    // Output interface\n    output AxiStreamType out_axi,\n    input  logic        out_ready\n);\n```\nTasks:\n- Arbitrates between multiple sources\n- Maintains fair access\n- Preserves frame integrity\n- Handles output backpressure\n\n6. Top-Level Controller\n```systemverilog\nmodule controller #(\n    parameter int NumPorts = 4\n) (\n    // Control signals for all submodules\n    output logic        parse_enable,\n    output logic        route_enable,\n    output logic        learn_enable,\n    // Status signals from submodules\n    input  logic        parse_done,\n    input  logic        route_done,\n    input  logic        learn_done\n);\n```\nTasks:\n- Coordinates between submodules\n- Manages control flow\n- Handles reset sequences\n- Monitors system status\n\nIntegration Example:\n```systemverilog\nmodule dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int AxiStreamWidth = 128,\n    parameter int MacTableDepth = 16\n) (\n    // ... ports as specified ...\n);\n\n    // Instantiate submodules\n    mac_table_manager mac_table (/*...*/);\n    \n    // One parser per input port\n    frame_parser parsers[NumPorts] (/*...*/);\n    \n    routing_engine router (/*...*/);\n    \n    // One buffer per port\n    port_buffer buffers[NumPorts] (/*...*/);\n    \n    // One arbiter per output port\n    output_arbiter arbiters[NumPorts] (/*...*/);\n    \n    controller ctrl (/*...*/);\n\n    // Connect submodules...\n\nendmodule\n```\n\nThis modular approach:\n- Simplifies testing and verification\n- Improves maintainability\n- Allows parallel development\n- Makes the design more scalable\n- Provides clear separation of concerns\n- Enables better reuse of components\n\nEach submodule can be developed and tested independently before integration into the complete system.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nLet me write the SystemVerilog code for each submodule and identify their critical interfaces. I'll start with the first few key submodules:\n\n1. MAC Table Manager:\n```systemverilog\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n)(\n    input  logic        clock,\n    input  logic        reset,\n    // Learning interface\n    input  logic [47:0] src_mac,\n    input  logic [1:0]  src_port,\n    input  logic        learn_valid,\n    // Lookup interface\n    input  logic [47:0] dst_mac,\n    output logic [1:0]  dst_port,\n    output logic        found_valid\n);\n\n    typedef struct packed {\n        logic        valid;\n        logic [47:0] mac_addr;\n        logic [1:0]  port;\n        logic [31:0] age_counter;\n    } mac_entry_t;\n\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n\n    // MAC Learning Logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_table <= '{default: '0};\n        end else if (learn_valid) begin\n            // Look for existing entry or empty slot\n            logic found = 0;\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid && mac_table[i].mac_addr == src_mac) begin\n                    mac_table[i].port <= src_port;\n                    mac_table[i].age_counter <= '0;\n                    found = 1;\n                    break;\n                end\n            end\n            \n            if (!found) begin\n                // Find empty slot\n                for (int i = 0; i < MacTableDepth; i++) begin\n                    if (!mac_table[i].valid) begin\n                        mac_table[i].valid <= 1'b1;\n                        mac_table[i].mac_addr <= src_mac;\n                        mac_table[i].port <= src_port;\n                        mac_table[i].age_counter <= '0;\n                        break;\n                    end\n                end\n            end\n        end\n    end\n\n    // Age Counter and Lookup Logic\n    always_ff @(posedge clock) begin\n        found_valid <= 1'b0;\n        dst_port <= '0;\n        \n        if (!reset) begin\n            // Update age counters\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                        mac_table[i].valid <= 1'b0;\n                    else\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n\n                    // Perform lookup\n                    if (mac_table[i].mac_addr == dst_mac) begin\n                        found_valid <= 1'b1;\n                        dst_port <= mac_table[i].port;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule\n\n2. Frame Parser:\n```systemverilog\nmodule frame_parser #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int AxiStreamWidth = 128\n)(\n    input  logic        clock,\n    input  logic        reset,\n    // AXI Stream input\n    input  AxiStreamType in_axi,\n    output logic        in_ready,\n    // Extracted information\n    output logic [47:0] dst_mac,\n    output logic [47:0] src_mac,\n    output logic        is_broadcast,\n    output logic        is_multicast,\n    output logic        parse_valid\n);\n\n    typedef enum logic [1:0] {\n        IDLE,\n        PARSE_HDR,\n        WAIT_END\n    } state_t;\n\n    state_t state, next_state;\n    \n    // Extract MAC addresses from first two beats of data\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            state <= IDLE;\n            dst_mac <= '0;\n            src_mac <= '0;\n            is_broadcast <= 1'b0;\n            is_multicast <= 1'b0;\n            parse_valid <= 1'b0;\n            in_ready <= 1'b1;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in_axi.tvalid) begin\n                        dst_mac <= in_axi.tdata[47:0];\n                        is_broadcast <= &in_axi.tdata[47:0];\n                        is_multicast <= in_axi.tdata[40];\n                        state <= PARSE_HDR;\n                    end\n                end\n\n                PARSE_HDR: begin\n                    if (in_axi.tvalid) begin\n                        src_mac <= in_axi.tdata[47:0];\n                        parse_valid <= 1'b1;\n                        state <= WAIT_END;\n                    end\n                end\n\n                WAIT_END: begin\n                    parse_valid <= 1'b0;\n                    if (in_axi.tvalid && in_axi.tlast)\n                        state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between MAC Table Manager and Frame Parser:\n- MAC addresses (src_mac, dst_mac)\n- Control signals (learn_valid, found_valid)\n\n2. Between Frame Parser and Routing Engine:\n- Parsed MAC addresses\n- Frame type flags (is_broadcast, is_multicast)\n- Control signals (parse_valid)\n\n3. Between Port Buffer and Output Arbiter:\n- AXI4-Stream interface\n- Backpressure signals (ready)\n\n4. Between Controller and All Submodules:\n- Enable signals\n- Status signals\n- Synchronization signals\n\nLet me know if you'd like me to continue with the remaining submodules.\n\nWould you like me to continue with the code for the remaining submodules (Routing Engine, Port Buffer, Output Arbiter, and Controller)?\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
        "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/test_l2_switch_lite_5/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule custom_tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n",
        "name": "test_l2_switch_lite_5"
    },
    {
        "index": 2,
        "dut": "module dut #(\n  parameter int           Depth = 4096,\n  parameter int          EntriesMTU = 1504,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int          FifoSizeInBytes = 4096,\n  parameter int          MaxNumberOfPackets = 32,\n  parameter int          DropIngressOnAfull = 1,\n  parameter int          DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1,\n  parameter int          CountWidth = $clog2(Depth + 1)\n) (\n  input  logic                          clock,\n  input  logic                          reset,\n  \n  input  AxiStreamType                  inAxi4St,\n  input  logic                          inError,\n  input  logic [ExtraDataWidth-1:0]     inExtra,\n  output logic                          inTready,\n  \n  output AxiStreamType                  outAxi4St,\n  output logic                          outError,\n  output logic [ExtraDataWidth-1:0]     outExtra,\n  input  logic                          outTready,\n  \n  output logic                          inFifoAfull,\n  output logic                          inDropEvent,\n  output logic                          outDropEvent\n);\n\n// Parameter validation\ninitial begin\n    assert(Depth == 0 || (Depth >= 64 && $onehot(Depth))) \n        else $error(\"Invalid Depth parameter\");\n    assert(PacketMtuInBytes <= FifoSizeInBytes)\n        else $error(\"MTU larger than FIFO size\");\n    assert(MaxNumberOfPackets > 0)\n        else $error(\"Invalid MaxNumberOfPackets\");\nend\n\n// Bypass mode when Depth=0\ngenerate\nif (Depth == 0) begin : bypass_gen\n    always_comb begin\n        outAxi4St = inAxi4St;\n        outError = inError;\n        outExtra = inExtra;\n        inTready = 1'b1;\n        inFifoAfull = 1'b0;\n        inDropEvent = 1'b0;\n        outDropEvent = 1'b0;\n    end\nend else begin : fifo_gen\n    \n    // Internal signals\n    logic packet_in_progress;\n    logic [CountWidth-1:0] stored_packets;\n    logic drop_current;\n    logic fifo_write;\n    logic frame_complete;\n    logic [CountWidth-1:0] fifo_count;\n    logic fifo_almost_full;\n\n    // Frame tracking\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            packet_in_progress <= 1'b0;\n        end else if (inAxi4St.tvalid) begin\n            if (!packet_in_progress && !drop_current)\n                packet_in_progress <= 1'b1;\n            else if (inAxi4St.tlast)\n                packet_in_progress <= 1'b0;\n        end\n    end\n\n    // Drop decision\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            drop_current <= 1'b0;\n        end else if (inAxi4St.tvalid && !packet_in_progress) begin\n            drop_current <= (stored_packets >= MaxNumberOfPackets) ||\n                          ((Depth - fifo_count) < EntriesMTU);\n        end else if (inAxi4St.tvalid && inAxi4St.tlast) begin\n            drop_current <= 1'b0;\n        end\n    end\n\n    // Packet counter\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            stored_packets <= '0;\n        end else begin\n            if (inAxi4St.tvalid && inAxi4St.tlast && !drop_current)\n                stored_packets <= stored_packets + 1'b1;\n            if (outAxi4St.tvalid && outAxi4St.tlast && outTready)\n                stored_packets <= stored_packets - 1'b1;\n        end\n    end\n\n    // Main FIFO\n    local_axist_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ExtraDataWidth(ExtraDataWidth),\n        .Depth(Depth)\n    ) data_fifo (\n        .clock(clock),\n        .reset(reset),\n        .almostFull(fifo_almost_full),\n        .inCount(fifo_count),\n        .inAxi4St(inAxi4St),\n        .inError(inError),\n        .inExtra(inExtra),\n        .inTready(),  // Unused - we control via drop logic\n        .outAxi4St(outAxi4St),\n        .outError(outError),\n        .outExtra(outExtra),\n        .outTready(outTready)\n    );\n\n    // Status signals\n    assign inTready = 1'b1;  // Always ready, drop frames if needed\n    assign fifo_write = inAxi4St.tvalid && !drop_current;\n    assign frame_complete = inAxi4St.tvalid && inAxi4St.tlast;\n    assign inFifoAfull = fifo_almost_full || (stored_packets >= MaxNumberOfPackets);\n    assign inDropEvent = frame_complete && drop_current;\n    assign outDropEvent = 1'b0;\n\nend\nendgenerate\n\nendmodule",
        "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module is a specialized FIFO (First-In-First-Out) buffer designed for AXI4-Stream protocol with store-and-forward capabilities. Its key functions are:\n\n1. Store-and-Forward Operation:\n- Must store complete frames (packets) before forwarding\n- A frame starts after reset or previous tlast, and ends with tlast=1\n- Once transmission starts, it must continue until frame completion\n\n2. Frame Drop Conditions:\n- If insufficient space exists for MTU-sized frame at the start\n- If the FIFO already contains MaxNumberOfPackets\n- If there's less than PacketMtuInBytes of storage available\n\n3. Bypass Mode:\n- When Depth=0, directly connects input to output\n\nHigh-Level Block Diagram:\n```\ninAxi4St    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba                                     \u2502\n            \u2502     Packet Counter & Drop Logic      \u2502\ninExtra     \u2502                                     \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n            \u2502  \u2502               \u2502                 \u2502\ninError     \u2502  \u2502  Data FIFO    \u2502                 \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  \u2502(local_axist_ \u2502                 \u2502    outAxi4St\n            \u2502  \u2502    fifo)      \u2502                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n            \u2502  \u2502               \u2502                 \u2502\n            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502    outExtra\n            \u2502                                     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n            \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n            \u2502  \u2502 Packet Count  \u2502                 \u2502    outError\n            \u2502  \u2502     FIFO      \u2502                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n            \u2502  \u2502(local_fifo)   \u2502                 \u2502\n            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n            \u2502                                     \u2502\noutTready   \u2502     Control Logic                  \u2502\n\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                     \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThe design consists of:\n1. Main Data Path FIFO (using local_axist_fifo)\n2. Packet Counter FIFO (using local_fifo)\n3. Control Logic for:\n   - Frame drop decisions\n   - Store-and-forward control\n   - Packet counting\n   - Status signal generation (inDropEvent, outDropEvent, inFifoAfull)What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nFrom the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nKey Parameters:\n1. FIFO-Related Parameters:\n```systemverilog\nparameter int Depth = 4096\n// - Must be 64 or power-of-2 > 64\n// - Controls the total FIFO depth\n// - Default 4096 is reasonable for typical network applications\n\nparameter int FifoSizeInBytes = 4096\n// - Should match Depth when AxiStreamWidth=8\n// - Represents total storage capacity in bytes\n```\n\n2. Data Width Parameters:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n// - Default is 8-bit data width structure\n// - Contains tdata, tkeep, tuser, tlast, tvalid\n\nparameter int unsigned AxiStreamWidth = 8\n// - Must match AxiStreamType.tdata width\n// - Common values: 8, 16, 32, 64, 128\n\nparameter int unsigned ExtraDataWidth = 1\n// - Additional sideband data width\n// - Default 1 is reasonable for simple flag passing\n```\n\n3. Packet Control Parameters:\n```systemverilog\nparameter int unsigned EntriesMTU = 1504\n// - Minimum free space required for new packet\n// - Typical Ethernet MTU plus overhead\n\nparameter int PacketMtuInBytes = 1500\n// - Maximum allowed packet size\n// - Standard Ethernet MTU size\n\nparameter int MaxNumberOfPackets = 32\n// - Maximum concurrent stored packets\n// - Reasonable for preventing FIFO hogging\n```\n\n4. Control Behavior Parameters:\n```systemverilog\nparameter int DropIngressOnAfull = 1    // Required fixed value\nparameter int DropEgressOnError = 1     // Required fixed value\nparameter int IngressPrefillBytes = -1  // Required fixed value\n```\n\nReasonable Constraints/Relationships:\n1. Depth must be \u2265 PacketMtuInBytes to store at least one full packet\n2. FifoSizeInBytes should equal Depth * (AxiStreamWidth/8)\n3. EntriesMTU should be \u2265 PacketMtuInBytes\n4. MaxNumberOfPackets should be < Depth/PacketMtuInBytes to ensure space for minimum-sized packets\n\nThese parameters allow the module to be configured for different:\n- Data widths\n- Storage capacities\n- Packet sizes\n- Performance requirements\n- Application-specific needs\n\nThe default values are chosen to support standard Ethernet frames while providing reasonable buffering capacity.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n1. Input Processing:\n```systemverilog\n// Registers needed for input processing\nlogic packet_in_progress;  // Tracks if we're receiving a packet\nlogic [CountWidth-1:0] current_packet_count;  // Tracks stored packets\nlogic drop_current_packet; // Indicates if current packet should be dropped\n\n// Combinational logic for drop decisions\nassign should_drop = \n    (current_packet_count >= MaxNumberOfPackets) ||\n    ((Depth - fifo_count) < EntriesMTU);\n```\n\n2. FIFO Storage:\n```systemverilog\n// Main data FIFO for AXI4-Stream data\nlocal_axist_fifo #(\n    .AxiStreamType(AxiStreamType),\n    .Depth(Depth),\n    .ExtraDataWidth(ExtraDataWidth)\n) data_fifo (\n    // ... ports ...\n);\n\n// Packet counter FIFO\nlocal_fifo #(\n    .Width(1),  // Just need 1 bit to mark packet end\n    .Depth(MaxNumberOfPackets)\n) packet_counter (\n    // ... ports ...\n);\n```\n\n3. Output Processing:\n```systemverilog\n// Registers needed for output processing\nlogic frame_out_progress;  // Tracks if we're sending a packet\nlogic hold_tvalid;        // Maintains tvalid during packet transmission\n```\n\nRequired Logic Elements:\n\n1. Control Registers:\n```systemverilog\n// Packet tracking\nreg packet_in_progress;\nreg packet_out_progress;\nreg [CountWidth-1:0] stored_packets;\n\n// Drop tracking\nreg drop_current;\nreg drop_event_reg;\n\n// FIFO status\nreg fifo_almost_full;\n```\n\n2. Combinational Logic:\n```systemverilog\n// Drop decision logic\nalways_comb begin\n    drop_decision = \n        packet_in_progress == 1'b0 &&  // Start of new packet\n        (stored_packets >= MaxNumberOfPackets ||\n         (Depth - fifo_count) < EntriesMTU);\nend\n\n// Output control logic\nalways_comb begin\n    outAxi4St.tvalid = data_fifo.outAxi4St.tvalid && \n                       !drop_current && frame_out_progress;\nend\n```\n\n3. Sequential Logic:\n```systemverilog\n// Packet counting\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        stored_packets <= '0;\n    end else begin\n        if (packet_complete && !drop_current)\n            stored_packets <= stored_packets + 1;\n        if (output_packet_complete)\n            stored_packets <= stored_packets - 1;\n    end\nend\n\n// Frame tracking\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        packet_in_progress <= 1'b0;\n    end else begin\n        if (inAxi4St.tvalid && inAxi4St.tlast)\n            packet_in_progress <= 1'b0;\n        else if (inAxi4St.tvalid && !packet_in_progress)\n            packet_in_progress <= 1'b1;\n    end\nend\n```\n\n4. Status Generation:\n```systemverilog\n// Output status signals\nassign inFifoAfull = fifo_almost_full || (stored_packets >= MaxNumberOfPackets);\nassign inDropEvent = drop_event_reg;\nassign outDropEvent = 1'b0; // As specified\n```\n\nKey Transformations:\n1. Input Side:\n- Frame validation and drop decisions\n- Packet counting\n- FIFO write control\n\n2. Storage:\n- Complete frame buffering\n- Extra data and error storage alongside main data\n- Packet boundary tracking\n\n3. Output Side:\n- Store-and-forward control\n- Continuous transmission guarantee\n- Status generation\n\nThe design must maintain AXI4-Stream protocol compliance while implementing store-and-forward behavior and managing packet drops based on available space and packet count limitations.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the clocking, timing, and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock  // Single synchronous clock for entire design\n```\n- All operations are synchronous to this clock\n- No clock domain crossing required\n- Both local_axist_fifo and local_fifo use the same clock\n\nLatency Requirements:\n1. Input Path:\n- Drop decisions must be made at start of packet\n- inTready must be constant 1'b1\n- Zero additional latency on input path\n\n2. Store-and-Forward:\n- Must store complete frame before forwarding\n- Minimum latency = packet size + 1 clock cycle\n- Maximum latency determined by FIFO depth and traffic pattern\n\n3. Output Path:\n- Once started, must maintain continuous transmission\n- No gaps allowed within a packet\n- tvalid must remain high until tlast\n\nThroughput Requirements:\n1. Input Side:\n```systemverilog\n// Can accept new data every cycle if:\n//  - FIFO not almost full\n//  - Not exceeding MaxNumberOfPackets\n//  - Has space for MTU-sized packet\n```\n\n2. Output Side:\n```systemverilog\n// Can transmit every cycle when:\n//  - Complete packet available\n//  - outTready is high\n//  - Must maintain consecutive cycles within packet\n```\n\nReset Requirements:\n1. Synchronous Reset (as specified):\n```systemverilog\ninput logic reset  // Active high, synchronous reset\n```\n\n2. Signals Requiring Reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Control registers\n        packet_in_progress <= 1'b0;\n        frame_out_progress <= 1'b0;\n        stored_packets    <= '0;\n        drop_current     <= 1'b0;\n        \n        // Status registers\n        inDropEvent      <= 1'b0;\n        outDropEvent     <= 1'b0;\n        inFifoAfull     <= 1'b0;\n        \n        // Output control\n        outAxi4St.tvalid <= 1'b0;\n        outError         <= 1'b0;\n        outExtra         <= '0;\n    end\n    // ... normal operation\nend\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n- All inputs must be stable relative to clock edge\n- Output timing determined by clock-to-q of registers\n- Critical paths:\n  * Packet count tracking\n  * Drop decision logic\n  * FIFO status monitoring\n\n2. Protocol Timing:\n```systemverilog\n// AXI4-Stream Protocol Requirements\n// - tvalid must not depend on tready\n// - No combinational logic from tready to tvalid\n// - Data must be stable when tvalid is high\n```\n\n3. Performance Considerations:\n```systemverilog\n// Maximum frequency affected by:\n// - FIFO depth (address decoder paths)\n// - Drop decision combinational logic\n// - Packet counter logic\n```\n\nKey Timing Aspects:\n1. Input Processing:\n- Drop decisions must complete in one cycle\n- FIFO write control must be stable before next clock\n\n2. Output Processing:\n- Store-and-forward control must prevent premature transmission\n- No bubbles allowed in output stream during packet transmission\n\n3. Status Generation:\n- inFifoAfull must reflect current FIFO state\n- Drop events must be properly aligned with packet boundaries\n\nThe design must maintain these timing requirements while ensuring proper protocol behavior and meeting store-and-forward requirements.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n1. Basic Functionality:\n```systemverilog\n// Normal packet transmission\ntask test_basic_packet;\n    // Single packet smaller than MTU\n    // Verify store-and-forward behavior\n    // Check output matches input\nendtask\n\n// Back-to-back packets\ntask test_consecutive_packets;\n    // Multiple packets with no gaps\n    // Verify packet boundaries maintained\nendtask\n```\n\n2. Edge Cases:\n```systemverilog\n// Minimum size packets\ntask test_min_packets;\n    // Single-beat packets\n    // Verify counter logic\nendtask\n\n// Maximum size packets\ntask test_mtu_packets;\n    // Packets at MTU size\n    // Verify storage and forwarding\nendtask\n```\n\n3. Drop Conditions:\n```systemverilog\n// MTU space check\ntask test_mtu_space_drop;\n    // Fill FIFO to leave less than MTU space\n    // Verify packet drop\nendtask\n\n// Max packets check\ntask test_max_packets_drop;\n    // Store MaxNumberOfPackets\n    // Verify additional packets dropped\nendtask\n```\n\n4. Backpressure Testing:\n```systemverilog\n// Output backpressure\ntask test_backpressure;\n    // Assert outTready low during transmission\n    // Verify packet integrity\nendtask\n```\n\nAssertions:\n1. Protocol Compliance:\n```systemverilog\n// Valid-Ready Protocol\nproperty valid_ready_protocol;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property(valid_ready_protocol);\n\n// No gaps in packet\nproperty no_gaps_in_packet;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid;\nendproperty\nassert property(no_gaps_in_packet);\n```\n\n2. Store-and-Forward Checks:\n```systemverilog\n// Complete packet storage\nproperty store_complete_packet;\n    @(posedge clock) disable iff (reset)\n    $rose(outAxi4St.tvalid) |-> stored_complete_packet;\nendproperty\nassert property(store_complete_packet);\n\n// Packet boundary tracking\nproperty packet_boundary_check;\n    @(posedge clock) disable iff (reset)\n    $fell(outAxi4St.tvalid) |-> outAxi4St.tlast;\nendproperty\nassert property(packet_boundary_check);\n```\n\n3. Counter Checks:\n```systemverilog\n// Packet counter limits\nproperty packet_counter_limit;\n    @(posedge clock) disable iff (reset)\n    stored_packets <= MaxNumberOfPackets;\nendproperty\nassert property(packet_counter_limit);\n\n// FIFO space tracking\nproperty fifo_space_check;\n    @(posedge clock) disable iff (reset)\n    !inFifoAfull |-> (Depth - fifo_count) >= EntriesMTU;\nendproperty\nassert property(fifo_space_check);\n```\n\n4. Drop Logic Verification:\n```systemverilog\n// Drop condition checks\nproperty drop_condition_check;\n    @(posedge clock) disable iff (reset)\n    inDropEvent |-> \n        (stored_packets >= MaxNumberOfPackets) ||\n        ((Depth - fifo_count) < EntriesMTU);\nendproperty\nassert property(drop_condition_check);\n\n// Drop event alignment\nproperty drop_event_alignment;\n    @(posedge clock) disable iff (reset)\n    inDropEvent |-> inAxi4St.tvalid && inAxi4St.tlast;\nendproperty\nassert property(drop_event_alignment);\n```\n\n5. Parameter Checks:\n```systemverilog\n// Initial assertions for parameter validation\ninitial begin\n    assert (Depth == 0 || Depth >= 64 && $onehot(Depth))\n        else $error(\"Invalid Depth parameter\");\n    assert (PacketMtuInBytes <= FifoSizeInBytes)\n        else $error(\"MTU larger than FIFO size\");\n    assert (MaxNumberOfPackets > 0)\n        else $error(\"Invalid MaxNumberOfPackets\");\nend\n```\n\nCoverage Points:\n```systemverilog\ncovergroup fifo_coverage;\n    full_fifo: coverpoint fifo_count {\n        bins empty = {0};\n        bins full = {Depth};\n        bins almost_full = {[Depth-EntriesMTU:Depth-1]};\n    }\n    \n    packet_counts: coverpoint stored_packets {\n        bins empty = {0};\n        bins max = {MaxNumberOfPackets};\n        bins normal = {[1:MaxNumberOfPackets-1]};\n    }\n    \n    drop_scenarios: coverpoint {inDropEvent, fifo_almost_full} {\n        bins mtu_drop = {2'b11};\n        bins count_drop = {2'b10};\n    }\nendgroup\n```\n\nThese test scenarios and assertions ensure:\n- Correct protocol behavior\n- Proper store-and-forward operation\n- Accurate packet counting\n- Proper drop conditions\n- Parameter validation\n- Complete functional coverageWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules:\n\n1. Packet Drop Controller:\n```systemverilog\nmodule packet_drop_controller #(\n    parameter int MaxNumberOfPackets = 32,\n    parameter int EntriesMTU = 1504\n) (\n    // Determines if incoming packets should be dropped\n    input  logic clock,\n    input  logic reset,\n    input  logic [CountWidth-1:0] fifo_count,\n    input  logic [CountWidth-1:0] stored_packets,\n    input  logic packet_start,\n    output logic drop_packet\n);\n```\nTask: Makes drop decisions based on FIFO space and packet counts\n\n2. Packet Counter:\n```systemverilog\nmodule packet_counter #(\n    parameter int MaxNumberOfPackets = 32\n) (\n    // Tracks number of complete packets stored\n    input  logic clock,\n    input  logic reset,\n    input  logic packet_stored,\n    input  logic packet_removed,\n    output logic [CountWidth-1:0] stored_packets,\n    output logic max_packets_reached\n);\n```\nTask: Maintains count of stored packets\n\n3. Frame Controller:\n```systemverilog\nmodule frame_controller (\n    // Manages store-and-forward behavior\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    input  logic drop_current,\n    output logic frame_in_progress,\n    output logic frame_complete,\n    output logic write_enable\n);\n```\nTask: Controls frame storage and transmission timing\n\n4. FIFO Manager:\n```systemverilog\nmodule fifo_manager #(\n    parameter int Depth = 4096,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    // Manages FIFO interfaces\n    input  logic clock,\n    input  logic reset,\n    \n    // Main FIFO interface\n    interface data_fifo_if,\n    interface count_fifo_if,\n    \n    // Control signals\n    input  logic write_enable,\n    input  logic drop_packet,\n    output logic fifo_ready\n);\n```\nTask: Coordinates the two FIFOs (data and packet count)\n\n5. Status Generator:\n```systemverilog\nmodule status_generator (\n    // Generates output status signals\n    input  logic clock,\n    input  logic reset,\n    input  logic drop_packet,\n    input  logic frame_complete,\n    input  logic fifo_almost_full,\n    output logic inDropEvent,\n    output logic inFifoAfull\n);\n```\nTask: Generates status and event signals\n\n6. Top-Level Integration (dut):\n```systemverilog\nmodule dut #(parameters...) (\n    // Main module integrating all components\n    input  logic clock,\n    input  logic reset,\n    \n    // AXI Stream interfaces\n    input  AxiStreamType inAxi4St,\n    output logic inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready,\n    \n    // Additional signals\n    input  logic inError,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    output logic outError,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    \n    // Status outputs\n    output logic inFifoAfull,\n    output logic inDropEvent,\n    output logic outDropEvent\n);\n```\nTask: Integrates all submodules and manages top-level control\n\nInteractions between blocks:\n```\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502  Packet Drop    \u2502\n                     \u2502   Controller    \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Frame     \u2502\u25c4\u2500\u2500\u2500\u2500\u25ba\u2502  FIFO Manager   \u2502\u2500\u2500\u2500\u2500\u25ba\u2502   Packet    \u2502\n\u2502 Controller  \u2502      \u2502                 \u2502     \u2502   Counter   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502    Status       \u2502\n                     \u2502   Generator     \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nBenefits of this modular approach:\n1. Clear separation of concerns\n2. Easier testing of individual components\n3. Simplified maintenance\n4. Better reusability\n5. Parallel development possible\n6. Clearer documentation and understanding\n7. Easier to add features or modify behavior\n\nEach submodule has:\n- Well-defined interfaces\n- Single responsibility\n- Independent testability\n- Clear control and data paths\n\nThis modular structure makes the design:\n- More maintainable\n- Easier to verify\n- More scalable\n- Better organized\n- Easier to modifyWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nLet me write the SystemVerilog code for each submodule and define their critical interfaces:\n\n1. Packet Drop Controller:\n```systemverilog\nmodule packet_drop_controller #(\n    parameter int MaxNumberOfPackets = 32,\n    parameter int EntriesMTU = 1504\n) (\n    input  logic clock,\n    input  logic reset,\n    input  logic [CountWidth-1:0] fifo_count,\n    input  logic [CountWidth-1:0] stored_packets,\n    input  logic packet_start,\n    input  logic packet_end,\n    output logic drop_packet\n);\n\n    logic insufficient_space;\n    logic too_many_packets;\n    logic drop_decision;\n\n    always_comb begin\n        insufficient_space = (Depth - fifo_count) < EntriesMTU;\n        too_many_packets = stored_packets >= MaxNumberOfPackets;\n        drop_decision = insufficient_space || too_many_packets;\n    end\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            drop_packet <= 1'b0;\n        end else if (packet_start) begin\n            drop_packet <= drop_decision;\n        end else if (packet_end) begin\n            drop_packet <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\n2. Packet Counter:\n```systemverilog\nmodule packet_counter #(\n    parameter int MaxNumberOfPackets = 32,\n    parameter int CountWidth = $clog2(MaxNumberOfPackets + 1)\n) (\n    input  logic clock,\n    input  logic reset,\n    input  logic packet_stored,\n    input  logic packet_removed,\n    output logic [CountWidth-1:0] stored_packets,\n    output logic max_packets_reached\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            stored_packets <= '0;\n        end else begin\n            case ({packet_stored, packet_removed})\n                2'b10: stored_packets <= stored_packets + 1'b1;\n                2'b01: stored_packets <= stored_packets - 1'b1;\n                default: stored_packets <= stored_packets;\n            endcase\n        end\n    end\n\n    assign max_packets_reached = (stored_packets >= MaxNumberOfPackets);\n\nendmodule\n```\n\n3. Frame Controller:\n```systemverilog\nmodule frame_controller (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    input  logic drop_current,\n    output logic frame_in_progress,\n    output logic frame_complete,\n    output logic write_enable\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_in_progress <= 1'b0;\n        end else if (inAxi4St.tvalid) begin\n            if (!frame_in_progress && !inAxi4St.tlast)\n                frame_in_progress <= 1'b1;\n            else if (inAxi4St.tlast)\n                frame_in_progress <= 1'b0;\n        end\n    end\n\n    assign frame_complete = inAxi4St.tvalid && inAxi4St.tlast;\n    assign write_enable = inAxi4St.tvalid && !drop_current;\n\nendmodule\n```\n\n4. FIFO Manager:\n```systemverilog\nmodule fifo_manager #(\n    parameter int Depth = 4096,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic clock,\n    input  logic reset,\n    \n    // Input interface\n    input  AxiStreamType inAxi4St,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic inError,\n    input  logic write_enable,\n    \n    // Output interface\n    output AxiStreamType outAxi4St,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic outError,\n    input  logic outTready,\n    \n    // Status\n    output logic [CountWidth-1:0] fifo_count,\n    output logic fifo_ready\n);\n\n    local_axist_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .Depth(Depth),\n        .ExtraDataWidth(ExtraDataWidth)\n    ) data_fifo (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inExtra(inExtra),\n        .inError(inError),\n        .inTready(),  // unused\n        .outAxi4St(outAxi4St),\n        .outExtra(outExtra),\n        .outError(outError),\n        .outTready(outTready),\n        .inCount(fifo_count)\n    );\n\n    assign fifo_ready = write_enable && !reset;\n\nendmodule\n```\n\n5. Status Generator:\n```systemverilog\nmodule status_generator (\n    input  logic clock,\n    input  logic reset,\n    input  logic drop_packet,\n    input  logic frame_complete,\n    input  logic fifo_almost_full,\n    output logic inDropEvent,\n    output logic inFifoAfull\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            inDropEvent <= 1'b0;\n        end else begin\n            inDropEvent <= drop_packet && frame_complete;\n        end\n    end\n\n    assign inFifoAfull = fifo_almost_full;\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Drop Controller and FIFO Manager:\n```systemverilog\ninterface drop_fifo_if;\n    logic drop_packet;\n    logic [CountWidth-1:0] fifo_count;\n    modport drop_controller (\n        input  fifo_count,\n        output drop_packet\n    );\n    modport fifo_manager (\n        output fifo_count,\n        input  drop_packet\n    );\nendinterface\n```\n\n2. Between Frame Controller and FIFO Manager:\n```systemverilog\ninterface frame_fifo_if;\n    logic write_enable;\n    logic frame_complete;\n    modport frame_controller (\n        output write_enable,\n        output frame_complete\n    );\n    modport fifo_manager (\n        input write_enable,\n        input frame_complete\n    );\nendinterface\n```\n\n3. Between Status Generator and Other Modules:\n```systemverilog\ninterface status_if;\n    logic drop_packet;\n    logic frame_complete;\n    logic fifo_almost_full;\n    logic inDropEvent;\n    logic inFifoAfull;\n    modport status_generator (\n        input  drop_packet,\n        input  frame_complete,\n        input  fifo_almost_full,\n        output inDropEvent,\n        output inFifoAfull\n    );\nendinterface\n```\n\nThese interfaces ensure:\n1. Clean separation of functionality\n2. Clear signal ownership\n3. Easy modification of interfaces\n4. Better maintainability\n5. Simplified verification\n6. Clear documentation of connections\n\nThe critical timing paths are:\n1. Drop decision logic in Packet Drop Controller\n2. Frame tracking in Frame Controller\n3. FIFO count tracking in FIFO Manager\n4. Status generation timing in Status Generator\n\nThese modules work together to implement the complete store-and-forward FIFO functionality while maintaining clean separation of concerns.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
        "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = local_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = local_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_axist_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = local_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
        "name": "test_axist_storefwd_fifo_4"
    }
]