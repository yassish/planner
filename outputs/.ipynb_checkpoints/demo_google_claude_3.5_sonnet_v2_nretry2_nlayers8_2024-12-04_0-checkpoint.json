[
  {
    "index": 3,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,  // Required but unused\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  input  logic                         clock,\n  input  logic                         reset,\n  \n  // AXI Stream Input Interface\n  input  AxiStreamType                 inAxi4St,\n  output logic                         inTready,\n  input  logic [ExtraDataWidth-1:0]    inExtra,\n  \n  // AXI Stream Output Interface  \n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready,\n  output logic [ExtraDataWidth-1:0]    outExtra,\n  \n  // Rate Control Interface\n  input  logic [7:0]                   i_rate_numerator,\n  input  logic [7:0]                   i_rate_denominator,\n  input  logic                         i_rate_by_frame\n);\n\n  // Internal signals\n  logic rate_allow;\n  logic frame_allow;\n  logic rate_exceeded;\n  logic transfer_valid;\n  \n  AxiStreamType pipe_axi4st;\n  logic [ExtraDataWidth-1:0] pipe_extra;\n  logic pipe_ready;\n  \n  // Input pipeline stage using local_axist_pipe\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_input_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .pipeAxi4St(),  // Unused\n    .pipeTready(),  // Unused\n    .outAxi4St(pipe_axi4st), \n    .outTready(pipe_ready)\n  );\n  \n  // Extra data pipeline\n  always_ff @(posedge clock) begin\n    if (inTready && inAxi4St.tvalid) begin\n      pipe_extra <= inExtra;\n    end\n  end\n  \n  // Rate controller\n  logic [15:0] rate_counter;\n  logic [15:0] effective_rate;\n  \n  always_ff @(posedge clock) begin\n    if (reset) begin\n      rate_counter <= '0;\n    end else if (transfer_valid) begin\n      if (rate_counter >= effective_rate)\n        rate_counter <= '0;\n      else  \n        rate_counter <= rate_counter + i_rate_denominator;\n    end\n  end\n  \n  always_ff @(posedge clock) begin\n    effective_rate <= i_rate_numerator * {8'h0, i_rate_denominator};\n  end\n  \n  assign rate_allow = (rate_counter <= effective_rate);\n  assign rate_exceeded = (rate_counter > effective_rate);\n  \n  // Frame tracker\n  logic in_frame;\n  logic frame_block;\n  \n  always_ff @(posedge clock) begin\n    if (reset) begin\n      in_frame <= 1'b0;\n      frame_block <= 1'b0;\n    end else begin\n      if (pipe_axi4st.tvalid) begin\n        if (!in_frame)\n          in_frame <= 1'b1;\n        else if (pipe_axi4st.tlast)\n          in_frame <= 1'b0;\n      end\n      \n      if (i_rate_by_frame) begin\n        if (pipe_axi4st.tlast && rate_exceeded)\n          frame_block <= 1'b1;\n        else if (!rate_exceeded)\n          frame_block <= 1'b0;\n      end\n    end\n  end\n  \n  assign frame_allow = i_rate_by_frame ? !frame_block : 1'b1;\n  \n  // Flow control\n  logic can_accept;\n  assign can_accept = rate_allow && frame_allow;\n  assign pipe_ready = can_accept && outTready;\n  assign transfer_valid = pipe_axi4st.tvalid && pipe_ready;\n  \n  // Output stage using local_axist_pipe\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_output_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(pipe_axi4st),\n    .inTready(),  // Unused - controlled by pipe_ready\n    .pipeAxi4St(),  // Unused\n    .pipeTready(),  // Unused\n    .outAxi4St(outAxi4St),\n    .outTready(outTready)\n  );\n  \n  // Extra data output\n  always_ff @(posedge clock) begin\n    if (pipe_ready && pipe_axi4st.tvalid) begin\n      outExtra <= pipe_extra;\n    end\n  end\n  \nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nThe main functionality of this module is to implement rate limiting on an AXI4-Stream interface. It acts as a \"traffic shaper\" that controls the data flow rate between an input AXI4-Stream and an output AXI4-Stream interface.\n\nKey functionalities:\n1. Rate Limiting based on numerator/denominator ratio (i_rate_numerator/i_rate_denominator)\n2. Two modes of operation controlled by i_rate_by_frame:\n   - Per-phit throttling (i_rate_by_frame=0)\n   - Frame-based throttling (i_rate_by_frame=1)\n3. Extra data forwarding alongside the main AXI4-Stream data\n4. Ready/Valid flow control maintenance\n\nHigh-level block diagram:\n```\n                                   Rate Control Logic\n                                   +-----------------+\n                                   |  rate counter   |\n                                   |  frame tracking |\n                                   +-----------------+\n                                          \u2193\ninAxi4St     +---------------+    +-----------------+    +---------------+    outAxi4St\n------------>|               |    |                 |    |               |-------------->\n             | Input         |--->| Rate Limiting   |--->| Output       |\ninExtra      | Pipeline      |    | Control         |    | Pipeline     |    outExtra\n------------>| (using        |    |                 |    | (using       |-------------->\n             | local_axist_  |    |                 |    | local_axist_ |\ninTready     | pipe)        |<---|                 |<---| pipe)        |    outTready\n<------------|               |    |                 |    |               |<-------------\n             +---------------+    +-----------------+    +---------------+\n\n```\n\nThe module consists of:\n1. Input pipeline stage for buffering incoming data\n2. Rate limiting control logic that:\n   - Tracks rate using numerator/denominator\n   - Monitors frame boundaries when in frame mode\n   - Controls throttling by manipulating ready/valid signals\n3. Output pipeline stage for buffering outgoing data\n4. Uses the provided local_axist_pipe module for sequential storage\n\nThe module ensures data flow doesn't exceed the specified rate while maintaining AXI4-Stream protocol compliance and proper handling of packet boundaries.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\n1. Required Parameters (specified in description):\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n// Default structure contains:\n// - tdata[7:0]\n// - tkeep\n// - tuser\n// - tlast\n// - tvalid\n\nparameter int AxiStreamWidth = 8\n// Must exist but not necessarily used\n// Represents width of tdata field\n\nparameter int unsigned ExtraDataWidth = 1\n// Width of additional data (inExtra/outExtra)\n// Default of 1 is reasonable for minimal extra data\n```\n\n2. Additional Useful Parameters (could be added):\n```systemverilog\nparameter int unsigned PIPELINE_STAGES = 2\n// Number of pipeline stages for local_axist_pipe\n// Default of 2 provides good balance of latency and timing\n\nparameter int unsigned COUNTER_WIDTH = 16\n// Width of internal rate limiting counter\n// 16 bits provides good range for rate calculations\n\nparameter bit REGISTERED_OUTPUT = 1\n// Whether to register the output signals\n// Default true for better timing\n```\n\nReasoning for defaults:\n1. `AxiStreamType`: The default 8-bit structure is good for basic data transfer and testing.\n2. `ExtraDataWidth=1`: Minimal width but still allows for simple side-channel signaling.\n3. `PIPELINE_STAGES=2`: \n   - One stage for input buffering\n   - One stage for output buffering\n   - Provides good balance between latency and timing\n4. `COUNTER_WIDTH=16`:\n   - Sufficient for most rate calculations\n   - Can handle numerator/denominator ratios with good precision\n5. `REGISTERED_OUTPUT=1`:\n   - Better for timing closure\n   - Small latency penalty but worth it for most applications\n\nThe parameter structure allows for:\n- Flexibility in data width configuration\n- Adjustable pipeline depth\n- Configurability of extra data width\n- Timing optimization options\n\nThese parameters would enable the module to be used in various applications while maintaining reasonable default behavior.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nThe data processing between input and output requires several components to handle rate limiting and data flow control. Here's the breakdown:\n\n1. Required Registers:\n```systemverilog\n// Rate Limiting Control\nlogic [15:0] rate_counter;     // Tracks accumulated rate\nlogic        in_frame;         // Tracks if we're currently in a frame\nlogic        rate_exceeded;    // Indicates if rate limit is exceeded\n\n// Extra Data Pipeline\nlogic [ExtraDataWidth-1:0] extra_data_pipe;  // For storing inExtra\n\n// Rate Calculation\nlogic [15:0] effective_rate;   // Pre-calculated rate threshold\n```\n\n2. Combinational Logic:\n```systemverilog\n// Rate Limit Calculation\nwire rate_allow = (rate_counter <= effective_rate);\n\n// Frame Control\nwire frame_start = inAxi4St.tvalid && !in_frame;\nwire frame_end = inAxi4St.tvalid && inAxi4St.tlast;\n\n// Flow Control\nwire can_accept = i_rate_by_frame ? \n                 (in_frame || (!rate_exceeded && rate_allow)) :\n                 rate_allow;\n\nwire transfer_valid = inAxi4St.tvalid && outTready && can_accept;\n```\n\n3. Data Flow Process:\n```\nInput Stage \u2192 Rate Control \u2192 Output Stage\n\na. Input Stage:\n   - Buffer input data using local_axist_pipe\n   - Store extra data\n   - Generate ready signal based on rate control\n\nb. Rate Control:\n   - Track current rate using counter\n   - Update rate_counter based on transfers\n   - Generate can_accept signal\n\nc. Output Stage:\n   - Buffer output data using local_axist_pipe\n   - Forward data when allowed by rate control\n   - Maintain extra data alignment\n```\n\n4. Key Processing Logic:\n```systemverilog\n// Rate Counter Update\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    rate_counter <= '0;\n  end else if (transfer_valid) begin\n    // Accumulate based on denominator\n    rate_counter <= rate_counter + i_rate_denominator;\n    if (rate_counter >= i_rate_numerator) begin\n      rate_counter <= '0;\n    end\n  end\nend\n\n// Frame Tracking\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    in_frame <= '0;\n  end else if (frame_start) begin\n    in_frame <= 1'b1;\n  end else if (frame_end) begin\n    in_frame <= 1'b0;\n  end\nend\n```\n\n5. Data Path Control:\n```systemverilog\n// Output Assignment\nassign outAxi4St.tvalid = inAxi4St.tvalid && can_accept;\nassign outAxi4St.tdata  = inAxi4St.tdata;\nassign outAxi4St.tkeep  = inAxi4St.tkeep;\nassign outAxi4St.tlast  = inAxi4St.tlast;\nassign outAxi4St.tuser  = inAxi4St.tuser;\nassign outExtra         = extra_data_pipe;\n\n// Input Ready Control\nassign inTready = outTready && can_accept;\n```\n\nThe processing includes:\n1. Rate limiting logic to control data flow\n2. Frame tracking for frame-based rate limiting\n3. Pipeline stages for timing optimization\n4. Flow control signal generation\n5. Extra data forwarding\n6. Ready/valid handshaking maintenance\n\nThe design ensures:\n- Proper rate limiting based on configuration\n- Maintenance of AXI4-Stream protocol\n- Frame integrity in frame-based mode\n- Efficient data flow with minimal stalls\n- Clean timing through pipelined designWhat testcases and verification considerations are important to verify this design works correctly?\n [NEW STEP]\n What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description, here are the key timing, clocking, and reset considerations:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock   // Primary system clock\n```\n- All logic operates in single clock domain\n- No clock domain crossing required\n\nReset Requirements:\n1. Synchronous Reset:\n```systemverilog\ninput logic reset   // Synchronous reset, active high\n```\n- Explicitly specified as synchronous reset\n- Should reset the following signals:\n  * rate_counter\n  * in_frame status\n  * Pipeline stages (via local_axist_pipe)\n  * Any frame tracking logic\n  * Output registers\n\nLatency Considerations:\n1. Pipeline Stages:\n- Minimum latency determined by local_axist_pipe stages\n- Typical path: Input \u2192 Rate Control \u2192 Output\n- Expected latency: 2-3 clock cycles minimum\n\n2. Critical Paths:\n```systemverilog\n// Rate control logic path\nrate_counter \u2192 rate calculation \u2192 flow control \u2192 ready/valid signals\n\n// Data path\ninAxi4St \u2192 pipeline stages \u2192 outAxi4St\n```\n\nThroughput Requirements:\n1. Rate Limited Throughput:\n```systemverilog\n// Maximum throughput = (i_rate_numerator / i_rate_denominator) * line_rate\n// Example: if numerator=4, denominator=8, max throughput is 50%\n```\n\n2. Flow Control:\n- Must maintain AXI4-Stream protocol timing\n- Ready/Valid handshaking must be preserved\n- No data loss allowed\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n```systemverilog\n// Critical paths to constrain\n- rate_counter logic\n- ready/valid generation\n- pipeline stage interfaces\n```\n\n2. Maximum Frequency:\n- Should be determined by system requirements\n- Critical paths should be pipelined appropriately\n\nReset Sequence:\n```systemverilog\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    rate_counter <= '0;\n    in_frame    <= '0;\n    // Reset other control signals\n  end else begin\n    // Normal operation\n  end\nend\n```\n\nAdditional Considerations:\n1. Ready/Valid Timing:\n- No combinational loops between ready and valid\n- Maintain AXI4-Stream timing requirements\n\n2. Pipeline Stages:\n- Use local_axist_pipe for sequential storage\n- Ensures proper timing margins\n\n3. Rate Control Timing:\n- Rate calculations should be registered\n- Avoid long combinational paths\n\n4. Frame Control:\n- Frame status updates must be synchronous\n- Proper frame boundary detection timing\n\nThe design should:\n- Meet system clock frequency requirements\n- Maintain deterministic latency\n- Provide configurable throughput control\n- Handle reset properly\n- Maintain protocol timing requirements\n- Use appropriate pipelining for timing closureWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nHere are the key test scenarios and assertions needed to verify this rate-limiting AXI4-Stream design:\n\nTest Scenarios:\n1. Basic Functionality:\n```systemverilog\n// Test different rate configurations\ntask test_basic_rate;\n  // Test 50% rate\n  i_rate_numerator = 8'd4;\n  i_rate_denominator = 8'd8;\n  \n  // Test 25% rate\n  i_rate_numerator = 8'd1;\n  i_rate_denominator = 8'd4;\n  \n  // Test 100% rate (no limiting)\n  i_rate_numerator = 8'd8;\n  i_rate_denominator = 8'd8;\nend\n```\n\n2. Frame Mode Testing:\n```systemverilog\n// Test frame-based rate limiting\ntask test_frame_mode;\n  // Short frames\n  send_frame(4);   // 4-byte frame\n  \n  // Long frames\n  send_frame(100); // 100-byte frame\n  \n  // Back-to-back frames\n  send_frame(10);\n  send_frame(10);\nend\n```\n\n3. Corner Cases:\n```systemverilog\n// Test extreme conditions\ntask test_corner_cases;\n  // Minimum rate\n  i_rate_numerator = 8'd1;\n  i_rate_denominator = 8'd255;\n  \n  // Single-byte frames\n  send_frame(1);\n  \n  // Maximum-sized frames\n  send_frame(max_size);\nend\n```\n\n4. Backpressure Testing:\n```systemverilog\ntask test_backpressure;\n  // Toggle outTready randomly\n  fork\n    drive_data();\n    randomize_outTready();\n  join\nend\n```\n\nAssertions:\n1. Protocol Checks:\n```systemverilog\n// Basic AXI-Stream protocol checks\nproperty axi_valid_ready_p;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property(axi_valid_ready_p);\n\n// TLAST must be associated with TVALID\nproperty tlast_valid_p;\n  @(posedge clock)\n    outAxi4St.tlast |-> outAxi4St.tvalid;\nendproperty\nassert property(tlast_valid_p);\n```\n\n2. Rate Limiting Checks:\n```systemverilog\n// Check rate compliance\nproperty rate_limit_p;\n  @(posedge clock) disable iff (reset)\n    $rose(outAxi4St.tvalid) |-> \n      rate_counter <= effective_rate;\nendproperty\nassert property(rate_limit_p);\n\n// Frame mode behavior\nproperty frame_mode_p;\n  @(posedge clock) disable iff (reset)\n    i_rate_by_frame && in_frame |-> \n      !rate_exceeded || !$rose(outAxi4St.tvalid);\nendproperty\nassert property(frame_mode_p);\n```\n\n3. Data Integrity:\n```systemverilog\n// Extra data alignment\nproperty extra_data_align_p;\n  @(posedge clock)\n    outAxi4St.tvalid |-> \n      outExtra == $past(inExtra, pipeline_depth);\nendproperty\nassert property(extra_data_align_p);\n\n// Data preservation\nproperty data_preserve_p;\n  @(posedge clock)\n    outAxi4St.tvalid |-> \n      outAxi4St.tdata == $past(inAxi4St.tdata, pipeline_depth);\nendproperty\nassert property(data_preserve_p);\n```\n\n4. Reset Behavior:\n```systemverilog\n// Reset clears all signals\nproperty reset_clear_p;\n  @(posedge clock)\n    $rose(reset) |=> \n      !outAxi4St.tvalid && !in_frame && (rate_counter == '0);\nendproperty\nassert property(reset_clear_p);\n```\n\nCoverage Points:\n1. Rate Configurations:\n```systemverilog\ncovergroup rate_cg;\n  rate_num: coverpoint i_rate_numerator;\n  rate_den: coverpoint i_rate_denominator;\n  rate_mode: coverpoint i_rate_by_frame;\nendgroup\n```\n\n2. Frame Characteristics:\n```systemverilog\ncovergroup frame_cg;\n  frame_size: coverpoint frame_length {\n    bins small = {[1:10]};\n    bins medium = {[11:100]};\n    bins large = {[101:$]};\n  }\n  frame_gaps: coverpoint frame_gap {\n    bins small = {[1:5]};\n    bins large = {[6:$]};\n  }\nendgroup\n```\n\n3. Flow Control:\n```systemverilog\ncovergroup flow_cg;\n  ready_valid: cross outAxi4St.tvalid, outTready;\n  backpressure: coverpoint outTready_delay;\nendgroup\n```\n\nTest Plan should verify:\n1. Rate limiting accuracy\n2. Frame integrity\n3. Protocol compliance\n4. Backpressure handling\n5. Reset behavior\n6. Corner cases\n7. Performance metrics\n8. Data integrity\n\nThis comprehensive verification approach ensures:\n- Functional correctness\n- Protocol compliance\n- Rate limiting accuracy\n- Error-free data transmission\n- Proper handling of all corner casesWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nHere are the logical functional blocks/submodules for this rate-limiting AXI4-Stream design:\n\n1. Input Pipeline Stage\n```systemverilog\nmodule input_stage #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n  // Uses local_axist_pipe internally\n  ...\n);\n```\nTasks:\n- Buffers incoming AXI4-Stream data\n- Handles input ready/valid handshaking\n- Captures and aligns extra data\n- Provides clean timing boundary\n\n2. Rate Control Block\n```systemverilog\nmodule rate_controller #(\n  parameter int COUNTER_WIDTH = 16\n) (\n  ...\n);\n```\nTasks:\n- Maintains rate counter\n- Calculates current rate vs threshold\n- Generates rate allow/block signals\n- Implements rate limiting algorithm\n- Handles numerator/denominator calculations\n\n3. Frame Tracker\n```systemverilog\nmodule frame_tracker (\n  ...\n);\n```\nTasks:\n- Detects frame boundaries\n- Maintains in_frame status\n- Handles frame-based rate limiting mode\n- Controls frame-level throttling\n- Tracks frame statistics\n\n4. Output Pipeline Stage\n```systemverilog\nmodule output_stage #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n  // Uses local_axist_pipe internally\n  ...\n);\n```\nTasks:\n- Buffers outgoing AXI4-Stream data\n- Handles output ready/valid handshaking\n- Maintains extra data alignment\n- Provides clean timing boundary\n\n5. Flow Control Coordinator\n```systemverilog\nmodule flow_coordinator (\n  ...\n);\n```\nTasks:\n- Coordinates ready/valid signals\n- Combines rate and frame control decisions\n- Generates final flow control signals\n- Ensures protocol compliance\n- Handles backpressure\n\nTop-level Integration:\n```systemverilog\nmodule dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  // Module instantiations\n  input_stage u_input_stage (\n    ...\n  );\n  \n  rate_controller u_rate_ctrl (\n    ...\n  );\n  \n  frame_tracker u_frame_tracker (\n    ...\n  );\n  \n  flow_coordinator u_flow_coord (\n    ...\n  );\n  \n  output_stage u_output_stage (\n    ...\n  );\n);\n```\n\nInter-block Communication:\n```\nInput Stage \u2192 Rate Control \u2192 Frame Tracker \u2192 Flow Coordinator \u2192 Output Stage\n     \u2191____________________________________________________________|\n                        (backpressure path)\n```\n\nAdvantages of this modular approach:\n1. Clear Separation of Concerns:\n   - Each block has specific functionality\n   - Easier to maintain and debug\n   - Better reusability\n\n2. Clean Interfaces:\n   - Well-defined boundaries\n   - Simplified timing closure\n   - Easier to modify individual blocks\n\n3. Testability:\n   - Can test each block independently\n   - Simplified verification\n   - Better coverage analysis\n\n4. Scalability:\n   - Easy to add new features\n   - Can modify blocks independently\n   - Better performance optimization\n\n5. Maintenance:\n   - Localized bug fixes\n   - Easier documentation\n   - Better code organization\n\nEach block should:\n- Have clear input/output interfaces\n- Handle its own reset logic\n- Maintain its own state\n- Provide status signals\n- Support error handling\n- Be independently verifiable\n\nThis modular structure allows for:\n- Better design organization\n- Simplified debugging\n- Easier modifications\n- Clear functionality boundaries\n- Better maintainability\n- Improved testability\n- Clean timing closureWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nHere are the SystemVerilog code implementations for each submodule and their critical interfaces:\n\n1. Input Stage:\n```systemverilog\nmodule input_stage #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  input  logic                          clock,\n  input  logic                          reset,\n  \n  // Input Interface\n  input  AxiStreamType                  inAxi4St,\n  input  logic [ExtraDataWidth-1:0]     inExtra,\n  output logic                          inTready,\n  \n  // Output Interface\n  output AxiStreamType                  outAxi4St,\n  output logic [ExtraDataWidth-1:0]     outExtra,\n  input  logic                          outTready,\n  \n  // Control Interface\n  input  logic                          rateAllow\n);\n\n  // Use local_axist_pipe for storage\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock      (clock),\n    .reset      (reset),\n    .inAxi4St   (inAxi4St),\n    .inTready   (inTready),\n    .pipeAxi4St (/* unused */),\n    .pipeTready (/* unused */),\n    .outAxi4St  (outAxi4St),\n    .outTready  (outTready && rateAllow)\n  );\n\n  // Extra data pipeline\n  always_ff @(posedge clock) begin\n    if (inTready && inAxi4St.tvalid)\n      outExtra <= inExtra;\n  end\n\nendmodule\n```\n\n2. Rate Controller:\n```systemverilog\nmodule rate_controller #(\n  parameter int COUNTER_WIDTH = 16\n) (\n  input  logic               clock,\n  input  logic               reset,\n  \n  // Configuration Interface\n  input  logic [7:0]         i_rate_numerator,\n  input  logic [7:0]         i_rate_denominator,\n  \n  // Control Interface\n  input  logic               transfer_valid,\n  output logic               rateAllow,\n  \n  // Status Interface\n  output logic               rate_exceeded\n);\n\n  logic [COUNTER_WIDTH-1:0] rate_counter;\n  logic [COUNTER_WIDTH-1:0] effective_rate;\n\n  // Calculate effective rate threshold\n  always_ff @(posedge clock) begin\n    effective_rate <= (i_rate_numerator * {8'h0, i_rate_denominator});\n  end\n\n  // Rate counter logic\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      rate_counter <= '0;\n    end else if (transfer_valid) begin\n      if (rate_counter >= effective_rate)\n        rate_counter <= '0;\n      else\n        rate_counter <= rate_counter + i_rate_denominator;\n    end\n  end\n\n  assign rateAllow = (rate_counter <= effective_rate);\n  assign rate_exceeded = (rate_counter > effective_rate);\n\nendmodule\n```\n\n3. Frame Tracker:\n```systemverilog\nmodule frame_tracker (\n  input  logic               clock,\n  input  logic               reset,\n  \n  // Stream Interface\n  input  logic               tvalid,\n  input  logic               tlast,\n  \n  // Configuration Interface\n  input  logic               i_rate_by_frame,\n  \n  // Control Interface\n  input  logic               rate_exceeded,\n  output logic               frame_allow\n);\n\n  logic in_frame;\n  logic frame_block;\n\n  // Frame tracking\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      in_frame <= 1'b0;\n      frame_block <= 1'b0;\n    end else begin\n      if (tvalid) begin\n        if (!in_frame)\n          in_frame <= 1'b1;\n        else if (tlast)\n          in_frame <= 1'b0;\n      end\n\n      if (i_rate_by_frame) begin\n        if (tlast && rate_exceeded)\n          frame_block <= 1'b1;\n        else if (!rate_exceeded)\n          frame_block <= 1'b0;\n      end\n    end\n  end\n\n  assign frame_allow = i_rate_by_frame ? !frame_block : 1'b1;\n\nendmodule\n```\n\n4. Flow Coordinator:\n```systemverilog\nmodule flow_coordinator (\n  input  logic        clock,\n  input  logic        reset,\n  \n  // Control Inputs\n  input  logic        rateAllow,\n  input  logic        frame_allow,\n  input  logic        downstream_ready,\n  \n  // Stream Interface\n  input  logic        in_valid,\n  output logic        in_ready,\n  output logic        out_valid,\n  input  logic        out_ready\n);\n\n  logic can_accept;\n  \n  assign can_accept = rateAllow && frame_allow && downstream_ready;\n  assign in_ready = can_accept && out_ready;\n  assign out_valid = in_valid && can_accept;\n\nendmodule\n```\n\n5. Output Stage:\n```systemverilog\nmodule output_stage #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  input  logic                          clock,\n  input  logic                          reset,\n  \n  // Input Interface\n  input  AxiStreamType                  inAxi4St,\n  input  logic [ExtraDataWidth-1:0]     inExtra,\n  output logic                          inTready,\n  \n  // Output Interface\n  output AxiStreamType                  outAxi4St,\n  output logic [ExtraDataWidth-1:0]     outExtra,\n  input  logic                          outTready\n);\n\n  // Use local_axist_pipe for storage\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock      (clock),\n    .reset      (reset),\n    .inAxi4St   (inAxi4St),\n    .inTready   (inTready),\n    .pipeAxi4St (/* unused */),\n    .pipeTready (/* unused */),\n    .outAxi4St  (outAxi4St),\n    .outTready  (outTready)\n  );\n\n  // Extra data pipeline\n  always_ff @(posedge clock) begin\n    if (inTready && inAxi4St.tvalid)\n      outExtra <= inExtra;\n  end\n\nendmodule\n```\n\nCritical Interfaces between modules:\n\n1. Control Signals:\n```systemverilog\nrateAllow    // Rate Controller \u2192 Input Stage, Flow Coordinator\nframe_allow  // Frame Tracker \u2192 Flow Coordinator\n```\n\n2. Status Signals:\n```systemverilog\nrate_exceeded  // Rate Controller \u2192 Frame Tracker\nin_frame      // Frame Tracker \u2192 Rate Controller\n```\n\n3. Data Path:\n```systemverilog\nInput Stage \u2192 Output Stage:\n- AXI4-Stream signals (tvalid, tready, tdata, tlast, etc.)\n- Extra data signals\n```\n\n4. Flow Control:\n```systemverilog\nFlow Coordinator \u2192 All stages:\n- Ready/valid coordination\n- Backpressure handling\n```\n\nThese interfaces are critical for:\n- Maintaining data flow\n- Coordinating rate limiting\n- Ensuring protocol compliance\n- Managing frame boundaries\n- Handling backpressure\n\nEach interface should be properly registered to maintain good timing closure.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_3"
  },
  {
    "index": 0,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n)(\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    // Internal signals\n    logic        frame_start;\n    logic        valid_data;\n    logic [7:0]  data_out;\n    logic [3:0]  byte_position;\n    logic        extraction_complete;\n    logic [47:0] dest_mac;\n    logic [47:0] source_mac;\n    logic        mac_valid;\n\n    // Input controller instantiation\n    axi_stream_input_controller #(\n        .AxiStreamType(AxiStreamType)\n    ) u_input_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .outTready(outTready),\n        .inTready(inTready),\n        .frame_start(frame_start),\n        .valid_data(valid_data),\n        .data_out(data_out)\n    );\n\n    // Byte counter controller instantiation\n    byte_counter_controller u_byte_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .valid_data(valid_data),\n        .frame_start(frame_start),\n        .byte_position(byte_position),\n        .extraction_complete(extraction_complete)\n    );\n\n    // MAC address extractor instantiation\n    mac_address_extractor u_mac_extract (\n        .clock(clock),\n        .reset(reset),\n        .data_in(data_out),\n        .valid_data(valid_data),\n        .byte_position(byte_position),\n        .dest_mac(dest_mac),\n        .source_mac(source_mac),\n        .mac_valid(mac_valid)\n    );\n\n    // Output controller instantiation\n    axi_stream_output_controller #(\n        .AxiStreamType(AxiStreamType)\n    ) u_output_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .in_data(inAxi4St),\n        .outTready(outTready),\n        .outAxi4St(outAxi4St)\n    );\n\n    // MAC output controller instantiation\n    mac_output_controller u_mac_output (\n        .clock(clock),\n        .reset(reset),\n        .dest_mac_in(dest_mac),\n        .source_mac_in(source_mac),\n        .extraction_complete(extraction_complete),\n        .outParsedValid(outParsedValid),\n        .outParsedDestMac(outParsedDestMac),\n        .outParsedSourceMac(outParsedSourceMac)\n    );\n\nendmodule\n\nmodule axi_stream_input_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        outTready,\n    output logic        inTready,\n    output logic        frame_start,\n    output logic        valid_data,\n    output logic [7:0]  data_out\n);\n\n    logic frame_active;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_active <= 1'b0;\n            frame_start <= 1'b0;\n        end else begin\n            if (inAxi4St.tvalid && inTready) begin\n                frame_active <= !inAxi4St.tlast;\n                frame_start <= !frame_active;\n            end else begin\n                frame_start <= 1'b0;\n            end\n        end\n    end\n\n    assign inTready = outTready;\n    assign valid_data = inAxi4St.tvalid && inTready;\n    assign data_out = inAxi4St.tdata;\n\nendmodule\n\nmodule byte_counter_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        valid_data,\n    input  logic        frame_start,\n    output logic [3:0]  byte_position,\n    output logic        extraction_complete\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_position <= 4'h0;\n            extraction_complete <= 1'b0;\n        end else if (frame_start) begin\n            byte_position <= 4'h0;\n            extraction_complete <= 1'b0;\n        end else if (valid_data) begin\n            if (byte_position == 4'hB) begin\n                byte_position <= 4'h0;\n                extraction_complete <= 1'b1;\n            end else begin\n                byte_position <= byte_position + 4'h1;\n                extraction_complete <= 1'b0;\n            end\n        end else begin\n            extraction_complete <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule mac_address_extractor (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        valid_data, \n    input  logic [3:0]  byte_position,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        mac_valid\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac <= '0;\n            source_mac <= '0;\n            mac_valid <= 1'b0;\n        end else if (valid_data) begin\n            case (byte_position)\n                4'd0:  dest_mac[47:40] <= data_in;\n                4'd1:  dest_mac[39:32] <= data_in;\n                4'd2:  dest_mac[31:24] <= data_in;\n                4'd3:  dest_mac[23:16] <= data_in;\n                4'd4:  dest_mac[15:8]  <= data_in;\n                4'd5:  dest_mac[7:0]   <= data_in;\n                4'd6:  source_mac[47:40] <= data_in;\n                4'd7:  source_mac[39:32] <= data_in;\n                4'd8:  source_mac[31:24] <= data_in;\n                4'd9:  source_mac[23:16] <= data_in;\n                4'd10: source_mac[15:8]  <= data_in;\n                4'd11: begin\n                    source_mac[7:0] <= data_in;\n                    mac_valid <= 1'b1;\n                end\n                default: mac_valid <= 1'b0;\n            endcase\n        end else begin\n            mac_valid <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule axi_stream_output_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType in_data,\n    input  logic        outTready,\n    output AxiStreamType outAxi4St\n);\n\n    AxiStreamType data_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            data_reg <= '0;\n        end else if (outTready) begin\n            data_reg <= in_data;\n        end\n    end\n\n    assign outAxi4St = data_reg;\n\nendmodule\n\nmodule mac_output_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac_in,\n    input  logic [47:0] source_mac_in,\n    input  logic        extraction_complete,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end else begin\n            outParsedValid <= extraction_complete;\n            if (extraction_complete) begin\n                outParsedDestMac <= dest_mac_in;\n                outParsedSourceMac <= source_mac_in;\n            end\n        end\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output sometime after the first data phit on inAxi4St.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- outParsedValid should be 1 for a single cycle when outParsedDestMac and outParsedSourceMac are valid.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\n1. The module is designed to parse/extract MAC addresses from an Ethernet frame while passing through AXI4-Stream protocol data\n2. Key operations:\n   - Extract 6-byte Destination MAC address (first 6 bytes of frame)\n   - Extract 6-byte Source MAC address (next 6 bytes of frame)\n   - Pass through the AXI4-Stream data unmodified (but potentially delayed)\n   - Signal when valid MAC addresses are extracted\n\nHigh-Level Block Diagram:\n```\n                                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                      \u2502         MAC Parser         \u2502\ninAxi4St \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                           \u2502\u2500\u2500\u2500\u2500\u25ba outAxi4St\n                                      \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\ninTready \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502    \u2502 State Machine & \u2502     \u2502\u25c4\u2500\u2500\u2500\u2500\u2500 outTready\n                                      \u2502    \u2502 Control Logic   \u2502     \u2502\n                    clock \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    \u2502                \u2502     \u2502\u2500\u2500\u2500\u2500\u25ba outParsedDestMac[47:0]\n                    reset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n                                      \u2502            \u2502                \u2502\u2500\u2500\u2500\u2500\u25ba outParsedSourceMac[47:0]\n                                      \u2502            \u2502                \u2502\n                                      \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u25ba outParsedValid\n                                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nKey Components:\n1. AXI4-Stream Interface Logic\n   - Handles input/output streaming protocol\n   - Manages ready/valid handshaking\n\n2. MAC Address Extraction Logic\n   - Counts bytes and extracts MAC fields\n   - Assembles 6-byte fields into 48-bit values\n   - Big-endian processing\n\n3. Control State Machine\n   - Tracks frame progress\n   - Controls extraction timing\n   - Generates output valid signals\n\nThis module essentially acts as a \"tap\" on the AXI4-Stream, extracting MAC addresses while allowing the original data to flow through unchanged.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let's analyze the parameterizable aspects and their reasonable defaults:\n\nKey Parameterizable Aspects:\n\n1. AXI Stream Data Width (AxiStreamWidth)\n- Description: Width of the tdata field in bits\n- Default Value: 8 bits (as specified in description)\n- Rationale: Allows flexibility in data path width\n- Possible Values: 8, 16, 32, 64, 128 bits (common AXI widths)\n\n2. AXI Stream Type (AxiStreamType)\n- Description: Struct defining the AXI4-Stream interface signals\n- Default Value: local_pkg::axi4st_8_s (as specified)\n- Structure:\n```systemverilog\ntypedef struct packed {\n    logic [7:0] tdata;\n    logic       tkeep;\n    logic       tuser;\n    logic       tlast;\n    logic       tvalid;\n} axi4st_8_s;\n```\n\nAdditional Parameters That Could Be Useful (though not specified in requirements):\n\n3. Pipeline Stages\n- Could be useful for timing optimization\n- Default: 0 (minimum latency)\n\n4. MAC Address Width\n- Currently fixed at 48 bits per specification\n- Could be parameterizable for different protocols\n- Default: 48 bits (standard Ethernet)\n\nReasonable Implementation Constraints:\n\n1. AxiStreamWidth must be a power of 2\n- Valid values: 8, 16, 32, 64, 128\n\n2. AxiStreamWidth must be \u2265 8 bits\n- Ensures at least one byte can be processed per cycle\n\n3. AxiStreamType must contain at minimum:\n- tdata field of width AxiStreamWidth\n- tvalid, tlast signals\n- tkeep signal (for byte alignment)\n\nThe current parameter set (8-bit width) represents the most basic implementation, offering:\n- Simplest implementation\n- Minimal resource usage\n- Maximum flexibility for byte alignment\n- Trade-off: Requires more cycles to process a frame\n\nThese parameters allow the module to be configured for different performance/resource trade-offs while maintaining the core MAC address extraction functionality.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing requirements and necessary logic elements:\n\nData Processing Flow:\n```\n1. Input Stage \u2192 2. MAC Extraction \u2192 3. Output Stage\n```\n\nRequired Registers:\n\n1. MAC Address Assembly Registers:\n```systemverilog\nlogic [47:0] dest_mac_reg;   // Accumulates Destination MAC\nlogic [47:0] src_mac_reg;    // Accumulates Source MAC\n```\n\n2. State Tracking:\n```systemverilog\nlogic [3:0] byte_counter;    // Tracks position in frame (0-11)\nlogic       parsing_frame;   // Indicates active frame parsing\nlogic       mac_valid_reg;   // Registers MAC validity\n```\n\n3. AXI Stream Pipeline:\n```systemverilog\nAxiStreamType axi_pipeline_reg; // For output timing alignment\n```\n\nCombinational Logic:\n\n1. Byte Counter Logic:\n```systemverilog\n// Next byte counter logic\nnext_byte_counter = (inAxi4St.tvalid && inTready) ? \n                    (byte_counter + 1) : byte_counter;\n```\n\n2. MAC Assembly Logic:\n```systemverilog\n// Example for 8-bit data width\ncase (byte_counter)\n    0: next_dest_mac = {inAxi4St.tdata, dest_mac_reg[39:0]};\n    1: next_dest_mac = {dest_mac_reg[47:40], inAxi4St.tdata, dest_mac_reg[31:0]};\n    // ... similar for other bytes\nendcase\n```\n\n3. Control Logic:\n```systemverilog\n// Frame tracking\nnext_parsing_frame = (inAxi4St.tvalid && !inAxi4St.tlast);\n\n// Ready generation\nassign inTready = outTready || !axi_pipeline_reg.tvalid;\n```\n\n4. Output Generation:\n```systemverilog\n// MAC output valid logic\nassign outParsedValid = mac_valid_reg && (byte_counter == 4'hB);\n\n// AXI stream output\nassign outAxi4St = axi_pipeline_reg;\n```\n\nProcessing Steps:\n\n1. Input Handling:\n- Track valid frame starts\n- Maintain byte counter\n- Generate ready signals\n\n2. MAC Extraction:\n- Accumulate bytes into MAC registers\n- Handle big-endian byte ordering\n- Track completion status\n\n3. Output Generation:\n- Pipeline AXI stream data\n- Generate MAC valid signal\n- Output assembled MAC addresses\n\nState Machine:\n```\nIDLE \u2192 PARSE_DEST_MAC \u2192 PARSE_SRC_MAC \u2192 COMPLETE\n```\n\nKey Considerations:\n1. Byte alignment and endianness\n2. Pipeline timing and latency\n3. Backpressure handling\n4. Reset conditions\n5. Error cases (truncated frames)\n\nThis structure allows for:\n- Continuous streaming operation\n- Proper MAC address extraction\n- Maintained AXI protocol timing\n- Efficient resource utilizationWhat is the control flow? What states are needed in state machines?\n [NEW STEP]\n What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the clocking, timing, and reset requirements based on the problem description:\n\nClocking Requirements:\n1. Single Clock Domain\n- Input: clock (system clock)\n- All logic is synchronous to this clock\n- No clock domain crossing required\n\nReset Requirements:\n1. Synchronous Reset\n- Input: reset (explicitly specified as synchronous)\n- Active high reset signal\n- Must reset all state elements\n\nSignals Requiring Reset:\n1. State Registers:\n```systemverilog\n// Must be reset to known values\nreg [3:0]  byte_counter    <= '0;\nreg        parsing_frame   <= '0;\nreg        mac_valid_reg   <= '0;\n```\n\n2. Output Registers:\n```systemverilog\n// Must be reset to inactive/zero\nreg [47:0] outParsedDestMac  <= '0;\nreg [47:0] outParsedSourceMac <= '0;\nreg        outParsedValid    <= '0;\n```\n\n3. AXI Stream Registers:\n```systemverilog\n// Must be reset to inactive state\nAxiStreamType outAxi4St_reg <= '0;\n```\n\nLatency Considerations:\n1. Variable Input to Output Latency:\n- Minimum: 0 cycles (for wide data paths)\n- Maximum: 11 cycles (for 8-bit data path)\n- Depends on AxiStreamWidth parameter\n\n2. MAC Address Extraction Latency:\n- Must complete after receiving 12 bytes\n- For 8-bit width: takes 12 cycles minimum\n- For wider paths: proportionally fewer cycles\n\nThroughput Requirements:\n1. AXI Stream Processing:\n- Must process one data word per clock when:\n  * inAxi4St.tvalid && inTready\n- No gaps allowed within a frame\n\n2. Backpressure Handling:\n- Must respect outTready signal\n- Can stall when outTready is low\n- Must maintain data integrity during stalls\n\nTiming Constraints:\n1. Protocol Timing:\n- AXI Stream handshaking must be maintained\n- tvalid/tready/tlast relationships preserved\n\n2. Output Timing:\n- outParsedValid must assert for exactly one cycle\n- MAC addresses must be stable when valid asserts\n\nReset Behavior:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Synchronous reset\n        byte_counter <= '0;\n        parsing_frame <= '0;\n        mac_valid_reg <= '0;\n        outParsedDestMac <= '0;\n        outParsedSourceMac <= '0;\n        outParsedValid <= '0;\n        outAxi4St_reg <= '0;\n    end else begin\n        // Normal operation\n    end\nend\n```\n\nKey Timing Considerations:\n1. No explicit cycle timing requirements\n2. Must maintain streaming data integrity\n3. Must handle backpressure properly\n4. Reset must initialize all state elements\n5. MAC extraction must complete within frame\n6. Output timing must be deterministic\n\nThese requirements ensure:\n- Reliable data processing\n- Predictable timing behavior\n- Clean reset operation\n- Proper protocol handling\n- Efficient resource utilizationWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed to verify this module:\n\nTest Scenarios:\n\n1. Basic Functionality Tests:\n```systemverilog\n// Single frame with known MAC addresses\n// Minimum-sized frame (14 bytes)\n// Maximum-sized frame (1518 bytes)\n// Back-to-back frames\n```\n\n2. Protocol Tests:\n```systemverilog\n// Valid frame with pauses (tvalid deasserted)\n// Backpressure tests (outTready toggling)\n// Frame abort scenarios\n// Reset during frame transmission\n```\n\n3. Corner Cases:\n```systemverilog\n// Single-cycle frames\n// Truncated frames\n// Maximum-sized frames\n// Zero-gap between frames\n```\n\n4. Error Conditions:\n```systemverilog\n// Invalid frame lengths\n// Premature frame termination\n// Reset during operation\n// Protocol violations\n```\n\nAssertions:\n\n1. Protocol Checks:\n```systemverilog\n// AXI Stream Protocol\nproperty axi_valid_ready;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property(axi_valid_ready);\n\n// No gaps in frame\nproperty no_gaps_in_frame;\n    @(posedge clock) disable iff (reset)\n    (inAxi4St.tvalid && !inAxi4St.tlast) |=> inAxi4St.tvalid;\nendproperty\n```\n\n2. Functional Checks:\n```systemverilog\n// MAC extraction timing\nproperty mac_extraction_timing;\n    @(posedge clock) disable iff (reset)\n    $rose(parsing_frame) |-> ##[1:12] outParsedValid;\nendproperty\n\n// Valid signal width\nproperty parsed_valid_single_cycle;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |=> !outParsedValid;\nendproperty\n```\n\n3. State Checks:\n```systemverilog\n// Byte counter range\nproperty byte_counter_range;\n    @(posedge clock) disable iff (reset)\n    byte_counter inside {[0:11]};\nendproperty\n\n// Reset behavior\nproperty reset_check;\n    @(posedge clock)\n    reset |-> ##1 (byte_counter == '0 && !parsing_frame);\nendproperty\n```\n\n4. Data Integrity:\n```systemverilog\n// Data preservation\nproperty data_preservation;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && inTready |-> ##[0:$] (outAxi4St.tdata == $past(inAxi4St.tdata));\nendproperty\n\n// MAC address stability\nproperty mac_stability;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |-> $stable(outParsedDestMac) && $stable(outParsedSourceMac);\nendproperty\n```\n\nTestbench Components:\n\n1. Driver:\n```systemverilog\n// Generate AXI Stream frames\n// Control backpressure\n// Insert delays\n```\n\n2. Monitor:\n```systemverilog\n// Check output MAC addresses\n// Verify AXI Stream protocol\n// Track frame boundaries\n```\n\n3. Scoreboard:\n```systemverilog\n// Compare extracted MACs with expected\n// Verify frame integrity\n// Check timing requirements\n```\n\nCoverage Points:\n\n1. Functional Coverage:\n```systemverilog\n// Frame sizes\n// Backpressure scenarios\n// MAC address patterns\n// Inter-frame gaps\n```\n\n2. State Coverage:\n```systemverilog\n// State transitions\n// Byte counter values\n// Reset conditions\n```\n\n3. Toggle Coverage:\n```systemverilog\n// All control signals\n// Data paths\n// MAC address bits\n```\n\nTest Environment:\n- SystemVerilog testbench\n- Random stimulus generation\n- Self-checking mechanisms\n- Coverage collection\n- Assertion monitoring\n\nThis comprehensive verification approach ensures:\n- Protocol compliance\n- Functional correctness\n- Error handling\n- Corner case coverage\n- Performance requirementsWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. AXI Stream Input Interface Controller\n```systemverilog\nmodule axi_stream_input_controller (\n    // Handles input handshaking and flow control\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    // Control signals to other blocks\n    output logic        frame_start,\n    output logic        valid_data\n);\n```\nTask: Manages input protocol timing, generates frame start detection, handles backpressure\n\n2. MAC Address Extractor\n```systemverilog\nmodule mac_address_extractor (\n    // Extracts and assembles MAC addresses\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        valid_data,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        mac_valid\n);\n```\nTask: Accumulates bytes into MAC addresses, handles endianness, tracks completion\n\n3. Byte Counter Controller\n```systemverilog\nmodule byte_counter_controller (\n    // Tracks position within frame\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        valid_data,\n    input  logic        frame_start,\n    output logic [3:0]  byte_position,\n    output logic        extraction_complete\n);\n```\nTask: Maintains byte position counter, signals completion of MAC extraction\n\n4. AXI Stream Output Controller\n```systemverilog\nmodule axi_stream_output_controller (\n    // Manages output streaming\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType in_data,\n    input  logic        outTready,\n    output AxiStreamType outAxi4St\n);\n```\nTask: Handles output flow control, maintains AXI protocol timing\n\n5. MAC Output Controller\n```systemverilog\nmodule mac_output_controller (\n    // Controls MAC address output timing\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac_in,\n    input  logic [47:0] source_mac_in,\n    input  logic        extraction_complete,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n```\nTask: Manages timing of MAC address outputs, ensures single-cycle valid signal\n\nIntegration Structure:\n```\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502   AXI Stream    \u2502\n                     \u2502 Input Controller\u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502                                    \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Byte Counter  \u2502               \u2502   MAC Address    \u2502\n    \u2502   Controller   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    Extractor    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                                   \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   AXI Stream   \u2502               \u2502   MAC Output    \u2502\n    \u2502Output Controller\u2502               \u2502   Controller    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nCommunication Between Blocks:\n1. Control Signals:\n- Frame boundaries\n- Valid data indicators\n- Completion signals\n\n2. Data Paths:\n- Input data to MAC extractor\n- MAC addresses to output controller\n- AXI stream data pipeline\n\n3. Status Signals:\n- Byte position\n- Extraction status\n- Output readiness\n\nBenefits of This Modular Structure:\n1. Clear separation of concerns\n2. Easier testing and verification\n3. Simplified maintenance\n4. Reusable components\n5. Better timing closure\n6. Easier to understand and modify\n\nEach submodule has:\n- Well-defined interfaces\n- Single responsibility\n- Independent testing capability\n- Clear control paths\n- Manageable complexity\n\nThis modular approach makes the design:\n- More maintainable\n- Easier to verify\n- More flexible for modifications\n- Better organized\n- Easier to optimizeWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide SystemVerilog code for each submodule and detail their critical interfaces:\n\n1. AXI Stream Input Controller:\n```systemverilog\nmodule axi_stream_input_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        outTready,\n    output logic        inTready,\n    output logic        frame_start,\n    output logic        valid_data,\n    output logic [7:0]  data_out\n);\n\n    logic frame_active;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_active <= 1'b0;\n            frame_start <= 1'b0;\n        end else begin\n            if (inAxi4St.tvalid && inTready) begin\n                frame_active <= !inAxi4St.tlast;\n                frame_start <= !frame_active;\n            end else begin\n                frame_start <= 1'b0;\n            end\n        end\n    end\n\n    assign inTready = outTready;\n    assign valid_data = inAxi4St.tvalid && inTready;\n    assign data_out = inAxi4St.tdata;\n\nendmodule\n```\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_address_extractor (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        valid_data,\n    input  logic [3:0]  byte_position,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        mac_valid\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac <= '0;\n            source_mac <= '0;\n            mac_valid <= 1'b0;\n        end else if (valid_data) begin\n            case (byte_position)\n                4'd0:  dest_mac[47:40] <= data_in;\n                4'd1:  dest_mac[39:32] <= data_in;\n                4'd2:  dest_mac[31:24] <= data_in;\n                4'd3:  dest_mac[23:16] <= data_in;\n                4'd4:  dest_mac[15:8]  <= data_in;\n                4'd5:  dest_mac[7:0]   <= data_in;\n                4'd6:  source_mac[47:40] <= data_in;\n                4'd7:  source_mac[39:32] <= data_in;\n                4'd8:  source_mac[31:24] <= data_in;\n                4'd9:  source_mac[23:16] <= data_in;\n                4'd10: source_mac[15:8]  <= data_in;\n                4'd11: begin\n                    source_mac[7:0] <= data_in;\n                    mac_valid <= 1'b1;\n                end\n                default: mac_valid <= 1'b0;\n            endcase\n        end else begin\n            mac_valid <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\n3. Byte Counter Controller:\n```systemverilog\nmodule byte_counter_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        valid_data,\n    input  logic        frame_start,\n    output logic [3:0]  byte_position,\n    output logic        extraction_complete\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_position <= 4'h0;\n            extraction_complete <= 1'b0;\n        end else if (frame_start) begin\n            byte_position <= 4'h0;\n            extraction_complete <= 1'b0;\n        end else if (valid_data) begin\n            if (byte_position == 4'hB) begin\n                byte_position <= 4'h0;\n                extraction_complete <= 1'b1;\n            end else begin\n                byte_position <= byte_position + 4'h1;\n                extraction_complete <= 1'b0;\n            end\n        end else begin\n            extraction_complete <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\n4. AXI Stream Output Controller:\n```systemverilog\nmodule axi_stream_output_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType in_data,\n    input  logic        outTready,\n    output AxiStreamType outAxi4St\n);\n\n    AxiStreamType data_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            data_reg <= '0;\n        end else if (outTready) begin\n            data_reg <= in_data;\n        end\n    end\n\n    assign outAxi4St = data_reg;\n\nendmodule\n```\n\n5. MAC Output Controller:\n```systemverilog\nmodule mac_output_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac_in,\n    input  logic [47:0] source_mac_in,\n    input  logic        extraction_complete,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end else begin\n            outParsedValid <= extraction_complete;\n            if (extraction_complete) begin\n                outParsedDestMac <= dest_mac_in;\n                outParsedSourceMac <= source_mac_in;\n            end\n        end\n    end\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Input Controller and MAC Extractor:\n```systemverilog\n// Data path interface\nlogic [7:0] data_out;\nlogic       valid_data;\n```\n\n2. Between Byte Counter and MAC Extractor:\n```systemverilog\n// Position tracking interface\nlogic [3:0] byte_position;\nlogic       extraction_complete;\n```\n\n3. Between MAC Extractor and Output Controller:\n```systemverilog\n// MAC data interface\nlogic [47:0] dest_mac;\nlogic [47:0] source_mac;\nlogic        mac_valid;\n```\n\n4. Between Input and Output Controllers:\n```systemverilog\n// AXI Stream pipeline interface\nAxiStreamType data_pipeline;\nlogic         outTready;\n```\n\nThese interfaces are critical for:\n- Data flow coordination\n- Control signal timing\n- State synchronization\n- Protocol compliance\n- Error handling\n\nThe modules must carefully maintain these interfaces to ensure proper operation of the complete system.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output sometime after the first data phit on inAxi4St.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- outParsedValid should be 1 for a single cycle when outParsedDestMac and outParsedSourceMac are valid.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_eth_parser_lite_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_eth_parser_lite_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// -- Custom testbench for ./dut.sv\n// -- Only checks outParsedValid, and that outAxi4St is correct.\n// -- Does not check that outParsedValid=1 on first data phit of outAxi4St.\n// -- Uses ./dut.sv.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  // TODO(drew): This check is removed for this test.\n  ////`OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  logic                 prev_outParsedValid;\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    prev_outParsedValid <= outParsedValid; // add this hook so we only look at this once per frame.\n    if (!reset && outParsedValid && !prev_outParsedValid) begin\n      // In this tb, we skip the outTready=1 qualifier.\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: observed outParsedDestMac=0x%0x outParsedSourceMac=0x%0x\",\n                 $realtime, outParsedDestMac, outParsedSourceMac);\n      end\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_lite_2"
  },
  {
    "index": 4,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    // Internal signals\n    logic frame_start, in_frame;\n    logic [47:0] dest_mac_reg, source_mac_reg;\n    logic [3:0] byte_counter;\n    logic parsing_active;\n    logic extraction_complete;\n    logic out_frame_start, out_in_frame;\n    \n    localparam int NUM_PIPELINE_STAGES = ((48 + AxiStreamWidth - 1) / AxiStreamWidth) - 1;\n\n    // Frame start detection on input\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_in_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .tfirst(frame_start),\n        .in_packet(in_frame)\n    );\n\n    // MAC extraction logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            parsing_active <= 1'b0;\n            extraction_complete <= 1'b0;\n            dest_mac_reg <= '0;\n            source_mac_reg <= '0;\n        end\n        else if (inAxi4St.tvalid && inTready) begin\n            if (frame_start) begin\n                parsing_active <= 1'b1;\n                byte_counter <= '0;\n                extraction_complete <= 1'b0;\n            end\n            else if (byte_counter == 11) begin\n                parsing_active <= 1'b0;\n                extraction_complete <= 1'b1;\n            end\n\n            if (parsing_active) begin\n                byte_counter <= byte_counter + 1'b1;\n                if (byte_counter < 6) begin\n                    dest_mac_reg <= {dest_mac_reg[39:0], inAxi4St.tdata};\n                end\n                else begin\n                    source_mac_reg <= {source_mac_reg[39:0], inAxi4St.tdata};\n                end\n            end\n        end\n    end\n\n    // Pipeline for data delay\n    local_axist_pipe #(\n        .NumStages(NUM_PIPELINE_STAGES),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .pipeAxi4St(),\n        .pipeTready(),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\n\n    // Frame start detection on output\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_out_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(outAxi4St),\n        .inTready(outTready),\n        .tfirst(out_frame_start),\n        .in_packet(out_in_frame)\n    );\n\n    // Output control logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end\n        else if (outAxi4St.tvalid && outTready && out_frame_start) begin\n            outParsedValid <= 1'b1;\n            outParsedDestMac <= dest_mac_reg;\n            outParsedSourceMac <= source_mac_reg;\n        end\n        else begin\n            outParsedValid <= 1'b0;\n        end\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\nAdditionally, you are required to use the folowing module (internal contents not shown) to determine when a packet or frame starts.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining when to start parsing or extracting contents from a frame. For example:\n\nlogic first_byte_of_dest_mac_valid; // if 1, indicates dest mac [47:40] present on inAxi4St.tdata.\nassign first_byte_of_dest_mac_valid = tfirst && in_packet;\n\n\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram of this module.\n\nMain Functionality:\n1. The module is a MAC address parser for Ethernet frames that:\n   - Extracts Destination MAC (6 bytes) and Source MAC (6 bytes) from incoming Ethernet frames\n   - Passes through the AXI4-Stream data with some delay\n   - Aligns the extracted MAC addresses with the first data beat of the output stream\n\nHigh-level Block Diagram:\n```\n                                    +------------------------+\n                                    |     MAC Parser (dut)   |\n                                    |                        |\ninAxi4St -------------+----------->|  Parser Logic          |\n                      |            |  (Extract MAC fields)   |\n                      |            |                        |\n                      |            |  +----------------+    |\n                      +----------->|  |local_axist_pipe|    |\n                      |            |  |                |    |----> outAxi4St\n                      |            |  +----------------+    |\n                      |            |                        |\n                      +----------->|  +------------------+  |\n                                  |  |local_axist_tfirst|  |\n                                  |  |                  |  |\n                                  |  +------------------+  |----> outParsedDestMac[47:0]\n                                  |                        |----> outParsedSourceMac[47:0]\n                                  |                        |----> outParsedValid\n                                  +------------------------+\n```\n\nKey Components:\n1. Parser Logic: \n   - Captures the first 12 bytes of each frame\n   - Assembles them into destination and source MAC addresses\n\n2. local_axist_pipe:\n   - Delays the AXI4-Stream data to align with parsed MAC addresses\n   - Delay depends on data width (e.g., 11 cycles for 8-bit data)\n\n3. local_axist_tfirst:\n   - Detects the start of each new frame\n   - Helps synchronize MAC address extraction\n\nThe module processes AXI4-Stream data in real-time, maintaining the streaming protocol while extracting the MAC addresses. The complexity varies with the AXI Stream width (parameter AxiStreamWidth), requiring different amounts of buffering and delay.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nLet me identify the key parameterizable aspects and their reasonable default values:\n\nKey Parameterizable Aspects:\n\n1. AXI Stream Interface Type:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n```\n- Default: 8-bit width struct\n- This determines the fundamental data width and structure of the AXI interface\n\n2. AXI Stream Width:\n```systemverilog\nparameter int unsigned AxiStreamWidth = 8\n```\n- Default: 8 bits\n- Should match AxiStreamType.tdata width\n- Common values: 8, 16, 32, 64, 128 bits\n\n3. Pipeline Delay:\n```systemverilog\n// For local_axist_pipe\nparameter int unsigned NumStages = ((48 + AxiStreamWidth - 1) / AxiStreamWidth) - 1\n```\n- Default calculation based on MAC address size (48 bits) and AXI width\n- For 8-bit interface: 11 stages\n- For 32-bit interface: 2 stages\n- For 128-bit interface: 0 stages\n\n4. MAC Address Width:\n```systemverilog\nlocalparam MAC_ADDR_WIDTH = 48  // Fixed for Ethernet\n```\n- While technically could be parameterizable, should remain fixed at 48 bits for standard Ethernet\n\nReasonable Default Values:\n1. For small/simple systems:\n```systemverilog\nAxiStreamWidth = 8  // Byte-oriented processing\nNumStages = 11      // Required for 8-bit width\n```\n\n2. For higher performance systems:\n```systemverilog\nAxiStreamWidth = 32 or 64  // Word-oriented processing\nNumStages = 2 or 1         // Fewer stages needed\n```\n\nThe parameter relationships:\n```systemverilog\n// Important relationships\nlocalparam BYTES_PER_MAC = 6;  // Fixed\nlocalparam TOTAL_MAC_BYTES = 12;  // Both MACs\nlocalparam NUM_PIPELINE_STAGES = ((TOTAL_MAC_BYTES * 8 + AxiStreamWidth - 1) / AxiStreamWidth) - 1;\n```\n\nThese parameters allow the module to be configured for different system requirements while maintaining functionality.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\n1. Input Capture and MAC Extraction Logic:\n```systemverilog\n// Registers for MAC address accumulation\nlogic [47:0] dest_mac_reg;\nlogic [47:0] source_mac_reg;\nlogic [3:0]  byte_counter;  // Counts up to 12 bytes\n\n// State tracking\nlogic parsing_active;\nlogic parse_complete;\n\n// For byte-oriented processing (8-bit):\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        byte_counter <= '0;\n        parsing_active <= 1'b0;\n        parse_complete <= 1'b0;\n    end else if (inAxi4St.tvalid && inTready) begin\n        if (tfirst && in_packet) begin\n            parsing_active <= 1'b1;\n            byte_counter <= '0;\n        end else if (byte_counter == 11) begin\n            parsing_active <= 1'b0;\n            parse_complete <= 1'b1;\n        end\n        \n        if (parsing_active) begin\n            byte_counter <= byte_counter + 1'b1;\n            case (byte_counter)\n                // Destination MAC\n                0: dest_mac_reg[47:40] <= inAxi4St.tdata;\n                1: dest_mac_reg[39:32] <= inAxi4St.tdata;\n                // ... continue for all bytes\n                // Source MAC\n                6: source_mac_reg[47:40] <= inAxi4St.tdata;\n                // ... etc\n            endcase\n        end\n    end\nend\n```\n\n2. Pipeline Control Logic:\n```systemverilog\n// Instance of delay pipeline\nlocal_axist_pipe #(\n    .NumStages(NUM_PIPELINE_STAGES),\n    .AxiStreamType(AxiStreamType)\n) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .pipeAxi4St(pipeAxi4St),\n    .pipeTready(pipeTready),\n    .outAxi4St(outAxi4St),\n    .outTready(outTready)\n);\n```\n\n3. Output Generation Logic:\n```systemverilog\n// Frame start detection\nlocal_axist_tfirst #(\n    .AxiStreamType(AxiStreamType)\n) u_tfirst (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(outAxi4St),\n    .inTready(outTready),\n    .tfirst(out_tfirst),\n    .in_packet(out_in_packet)\n);\n\n// Output control\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        outParsedValid <= 1'b0;\n    end else if (out_tfirst && out_in_packet && outAxi4St.tvalid) begin\n        outParsedValid <= 1'b1;\n        outParsedDestMac <= dest_mac_reg;\n        outParsedSourceMac <= source_mac_reg;\n    end else begin\n        outParsedValid <= 1'b0;\n    end\nend\n```\n\nKey Components:\n\n1. Registers:\n- MAC address accumulation registers (dest_mac_reg, source_mac_reg)\n- Byte counter register\n- State tracking registers (parsing_active, parse_complete)\n- Output valid register\n\n2. Combinational Logic:\n- Byte position decoder\n- MAC field assembly logic\n- Pipeline control logic\n- Frame start detection\n\n3. Control Signals:\n- Frame start indicator (tfirst)\n- Parsing state control\n- Pipeline stage control\n- Output valid generation\n\n4. Data Path:\n```\nInput Stream -> Parse Logic -> Pipeline Delay -> Output Stream\n                     |                               |\n                     v                               v\n              MAC Extraction                   Output Valid\n```\n\nThe complexity of the implementation varies with AxiStreamWidth:\n- 8-bit: Requires 12 cycles to capture MACs\n- 32-bit: Requires 3 cycles\n- 128-bit: Requires 1 cycle\n\nThe design needs to handle these different cases while maintaining proper timing and synchronization.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the clocking, timing, and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock  // Single system clock\n```\n- All operations are synchronous to this clock\n- No clock domain crossing required\n- AXI Stream protocol operates on positive clock edge\n\nLatency Requirements:\n1. Variable based on AxiStreamWidth:\n```systemverilog\n// Latency calculation\nlocalparam LATENCY_CYCLES = ((48 + AxiStreamWidth - 1) / AxiStreamWidth) - 1;\n// Examples:\n//  8-bit: 11 cycles\n// 32-bit:  2 cycles\n// 64-bit:  1 cycle\n//128-bit:  0 cycles\n```\n\n2. Pipeline Stages:\n- Must match latency requirements to align MAC data with first output beat\n- Implemented using local_axist_pipe module\n\nThroughput Requirements:\n1. Full AXI-Stream throughput:\n- No artificial stalls\n- One transfer per clock when:\n  ```systemverilog\n  transfer_occurs = inAxi4St.tvalid && inTready;  // Input side\n  transfer_occurs = outAxi4St.tvalid && outTready; // Output side\n  ```\n\nReset Requirements:\n1. Synchronous Reset (as specified):\n```systemverilog\ninput logic reset  // Active high, synchronous reset\n```\n\n2. Signals requiring reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Control registers\n        byte_counter <= '0;\n        parsing_active <= 1'b0;\n        parse_complete <= 1'b0;\n        \n        // Output control\n        outParsedValid <= 1'b0;\n        \n        // State machine registers\n        current_state <= IDLE;\n        \n        // Optional: Reset MAC registers\n        dest_mac_reg <= '0;\n        source_mac_reg <= '0;\n    end\nend\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n```sdc\n# Example timing constraints\nset_input_delay -clock clock -max 2.0 [get_ports \"inAxi4St*\"]\nset_output_delay -clock clock -max 2.0 [get_ports \"outAxi4St*\"]\nset_output_delay -clock clock -max 2.0 [get_ports \"outParsed*\"]\n```\n\n2. Critical Paths:\n- MAC assembly logic (multiple byte accumulation)\n- Pipeline delay matching\n- First beat detection and alignment\n\n3. AXI-Stream Protocol Timing:\n```systemverilog\n// Valid before Ready timing\nassert property (@(posedge clock) \n    inAxi4St.tvalid |-> $stable(inAxi4St.tdata));\nassert property (@(posedge clock)\n    outAxi4St.tvalid |-> $stable(outAxi4St.tdata));\n```\n\nPerformance Considerations:\n1. Maximum Frequency:\n- Determined by critical path through MAC assembly logic\n- Pipeline stages can be adjusted for timing closure\n\n2. Throughput Guarantees:\n```systemverilog\n// No artificial stalls\nassign inTready = pipeTready[0];\n// Ensure output can accept data when valid\nassign outAxi4St = pipeAxi4St[NUM_PIPELINE_STAGES];\n```\n\nReset Strategy:\n1. Synchronous Reset (as specified):\n- All registers reset on positive clock edge when reset is high\n- Simpler timing analysis\n- Better for FPGA implementation\n- Consistent with AXI-Stream protocol requirements\n\n2. Reset Duration:\n- Minimum 1 clock cycle\n- Recommended: Multiple cycles for reliable initialization\n- All internal pipelines and state machines must clear\n\nThe design must maintain these timing and reset requirements while handling different data widths and ensuring proper protocol behavior.What verification and debug features should be included? What test scenarios should be considered?\n [NEW STEP]\n \nLet me outline the verification and debug features along with key test scenarios:\n\n1. Assertions and Protocol Checks:\n```systemverilog\n// Protocol Assertions\nmodule dut_assertions (\n    // AXI-Stream Protocol Checks\n    property valid_before_data_change;\n        @(posedge clock) inAxi4St.tvalid |-> $stable(inAxi4St.tdata);\n    endproperty\n    assert property (valid_before_data_change) else\n        $error(\"AXI-Stream protocol violation: data changed while valid\");\n\n    // MAC Extraction Checks\n    property mac_valid_alignment;\n        @(posedge clock) outParsedValid |-> out_tfirst && out_in_packet;\n    endproperty\n    assert property (mac_valid_alignment) else\n        $error(\"MAC valid not aligned with packet start\");\n\n    // Counter Checks\n    property byte_counter_range;\n        @(posedge clock) byte_counter inside {[0:11]};\n    endproperty\n    assert property (byte_counter_range) else\n        $error(\"Byte counter out of valid range\");\n);\n```\n\n2. Debug Ports and Signals:\n```systemverilog\n// Debug Interface\n`ifdef DEBUG_ENABLED\n    output logic [3:0]  dbg_byte_counter;\n    output logic        dbg_parsing_active;\n    output logic [47:0] dbg_partial_dest_mac;\n    output logic [47:0] dbg_partial_source_mac;\n    output logic [2:0]  dbg_state;\n    \n    assign dbg_byte_counter = byte_counter;\n    assign dbg_parsing_active = parsing_active;\n    assign dbg_partial_dest_mac = dest_mac_reg;\n    assign dbg_partial_source_mac = source_mac_reg;\n    assign dbg_state = current_state;\n`endif\n```\n\n3. Error Detection and Reporting:\n```systemverilog\n// Error Flags\nlogic error_protocol_violation;\nlogic error_invalid_state;\nlogic error_counter_overflow;\n\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        error_protocol_violation <= 1'b0;\n        error_invalid_state <= 1'b0;\n        error_counter_overflow <= 1'b0;\n    end else begin\n        // Error detection logic\n        if (inAxi4St.tvalid && !$stable(inAxi4St.tdata))\n            error_protocol_violation <= 1'b1;\n        // ... other error conditions\n    end\nend\n```\n\n4. Test Scenarios:\n\nBasic Functionality Tests:\n```systemverilog\ntask test_basic_packet;\n    // Single packet with known MAC addresses\n    send_packet(48'hAABBCCDDEEFF, 48'h112233445566);\n    check_output_macs(48'hAABBCCDDEEFF, 48'h112233445566);\nendtask\n\ntask test_back_to_back;\n    // Multiple packets without gaps\n    repeat(5) begin\n        send_packet(random_mac(), random_mac());\n        check_output_alignment();\n    end\nendtask\n```\n\nCorner Cases:\n```systemverilog\ntask test_corner_cases;\n    // Minimum size packet\n    test_min_packet();\n    \n    // Maximum size packet\n    test_max_packet();\n    \n    // Back-pressure scenarios\n    test_with_backpressure();\n    \n    // Reset during transfer\n    test_reset_during_transfer();\nendtask\n```\n\n5. Test Coverage Points:\n```systemverilog\ncovergroup mac_parser_cg;\n    // State coverage\n    cp_state: coverpoint current_state {\n        bins all_states[] = {[0:$]};\n        bins state_transitions[] = ([0:$] => [0:$]);\n    }\n    \n    // Data width coverage\n    cp_data_patterns: coverpoint inAxi4St.tdata {\n        bins zeros = {'h00};\n        bins ones  = {'hFF};\n        bins others = {[1:'hFE]};\n    }\n    \n    // Protocol coverage\n    cp_ready_valid: cross inAxi4St.tvalid, inTready;\nendgroup\n```\n\n6. Performance Monitoring:\n```systemverilog\n// Performance counters\nlogic [31:0] total_packets;\nlogic [31:0] stall_cycles;\nlogic [31:0] active_cycles;\n\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        total_packets <= '0;\n        stall_cycles <= '0;\n        active_cycles <= '0;\n    end else begin\n        if (packet_complete)\n            total_packets <= total_packets + 1;\n        if (inAxi4St.tvalid && !inTready)\n            stall_cycles <= stall_cycles + 1;\n        if (parsing_active)\n            active_cycles <= active_cycles + 1;\n    end\nend\n```\n\n7. Specific Test Scenarios:\n- Protocol compliance testing\n- Backpressure handling\n- Reset during various states\n- Error injection and recovery\n- Maximum throughput testing\n- Minimum packet gap testing\n- Random packet sizes and content\n- Stress testing with maximum rate\n- Edge cases in MAC address values\n- Pipeline depth verification\n\n8. System Integration Tests:\n- Interface timing variations\n- Clock frequency variations\n- System-level interactions\n- Resource utilization monitoring\n- Power analysis scenarios\n\nThese verification features enable thorough testing and debugging of the design across various operating conditions and corner cases.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the comprehensive test scenarios and assertion strategy:\n\n1. Basic Protocol Assertions:\n```systemverilog\n// AXI-Stream Protocol Assertions\nmodule dut_assertions (\n    // Valid/Ready Handshake\n    assert property (@(posedge clock) disable iff (reset)\n        inAxi4St.tvalid |-> !$isunknown(inAxi4St.tdata))\n        else $error(\"Valid data must be known\");\n\n    // Data Stability\n    assert property (@(posedge clock)\n        inAxi4St.tvalid && !inTready |=> $stable(inAxi4St.tdata))\n        else $error(\"Data must remain stable when valid and not ready\");\n\n    // TLAST must be accompanied by TVALID\n    assert property (@(posedge clock)\n        inAxi4St.tlast |-> inAxi4St.tvalid)\n        else $error(\"TLAST without TVALID\");\n);\n```\n\n2. Functional Test Scenarios:\n\nBasic Packet Tests:\n```systemverilog\ntask test_single_packet;\n    // Basic packet with known MACs\n    logic [47:0] test_dest_mac = 48'h112233445566;\n    logic [47:0] test_src_mac = 48'hAABBCCDDEEFF;\n    \n    send_packet(test_dest_mac, test_src_mac);\n    check_parsed_macs(test_dest_mac, test_src_mac);\nendtask\n\ntask test_multiple_packets;\n    // Back-to-back packets\n    repeat(10) begin\n        logic [47:0] random_dest = $random;\n        logic [47:0] random_src = $random;\n        send_packet(random_dest, random_src);\n        check_parsed_macs(random_dest, random_src);\n    end\nendtask\n```\n\n3. Corner Cases:\n```systemverilog\ntask test_corner_cases;\n    // All zeros MAC\n    test_packet(48'h0, 48'h0);\n    \n    // All ones MAC\n    test_packet(48'hFFFFFFFFFFFF, 48'hFFFFFFFFFFFF);\n    \n    // Alternating bits\n    test_packet(48'h555555555555, 48'hAAAAAAAAAAAA);\n    \n    // Single bit differences\n    test_packet(48'h000000000001, 48'h000000000002);\nendtask\n```\n\n4. Stress Testing:\n```systemverilog\ntask test_backpressure;\n    // Random backpressure\n    fork\n        begin\n            repeat(100) begin\n                #($random) outTready <= 0;\n                #($random) outTready <= 1;\n            end\n        end\n        begin\n            repeat(20) test_single_packet();\n        end\n    join\nendtask\n\ntask test_maximum_throughput;\n    // Continuous packets with no gaps\n    outTready <= 1;\n    repeat(1000) begin\n        send_packet($random, $random);\n    end\nendtask\n```\n\n5. Error Injection:\n```systemverilog\ntask test_error_conditions;\n    // Invalid protocol sequence\n    fork\n        begin\n            force inAxi4St.tvalid = 1;\n            force inAxi4St.tlast = 1;\n            #10;\n            release inAxi4St.tvalid;\n            release inAxi4St.tlast;\n        end\n    join\nendtask\n```\n\n6. Functional Coverage:\n```systemverilog\ncovergroup mac_parser_coverage;\n    // State coverage\n    cp_parsing_states: coverpoint current_state {\n        bins all_states[] = {IDLE, PARSING, COMPLETE};\n        bins transitions[] = (IDLE => PARSING => COMPLETE => IDLE);\n    }\n\n    // Data patterns\n    cp_mac_patterns: coverpoint dest_mac_reg {\n        bins zeros = {48'h0};\n        bins ones = {48'hFFFFFFFFFFFF};\n        bins others = {[48'h1:48'hFFFFFFFFFFFE]};\n    }\n\n    // Protocol coverage\n    cp_handshake: cross inAxi4St.tvalid, inTready;\nendgroup\n```\n\n7. Pipeline Specific Tests:\n```systemverilog\ntask test_pipeline_alignment;\n    // Check output alignment for different data widths\n    case (AxiStreamWidth)\n        8:  verify_8bit_alignment();\n        32: verify_32bit_alignment();\n        64: verify_64bit_alignment();\n    endcase\nendtask\n```\n\n8. Reset Behavior Tests:\n```systemverilog\ntask test_reset_scenarios;\n    // Reset during packet\n    fork\n        begin\n            send_packet($random, $random);\n        end\n        begin\n            #5 reset <= 1;\n            #2 reset <= 0;\n        end\n    join\n    \n    // Verify clean recovery after reset\n    test_single_packet();\nendtask\n```\n\n9. System-Level Assertions:\n```systemverilog\n// Timing assertions\nassert property (@(posedge clock)\n    $rose(outParsedValid) |-> ##[0:NUM_PIPELINE_STAGES] out_tfirst)\n    else $error(\"MAC valid not properly aligned with packet start\");\n\n// Data integrity assertions\nassert property (@(posedge clock)\n    outParsedValid |-> !$isunknown({outParsedDestMac, outParsedSourceMac}))\n    else $error(\"Parsed MACs contain X or Z\");\n```\n\n10. Performance Monitoring:\n```systemverilog\n// Monitor throughput and latency\nalways @(posedge clock) begin\n    if (outParsedValid) begin\n        $display(\"Packet processed at time %t\", $time);\n        $display(\"Latency: %d cycles\", latency_counter);\n    end\nend\n```\n\nThese test scenarios and assertions provide:\n- Complete protocol compliance verification\n- Corner case coverage\n- Performance validation\n- Error detection and recovery testing\n- System-level integration verification\n- Timing and alignment verification\n\nThis comprehensive verification approach helps ensure the design works correctly across all operating conditions and corner cases.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and describe their specific tasks:\n\n1. Frame Start Detector:\n```systemverilog\nmodule mac_frame_detector (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        frame_start,\n    output logic        in_frame\n);\n    // Uses provided local_axist_tfirst module\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .tfirst(frame_start),\n        .in_packet(in_frame)\n    );\nendmodule\n```\nTask: Detects start of new frames and maintains frame status\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        frame_start,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        extraction_complete\n);\n    // MAC extraction state machine and logic\n    // Accumulates bytes/words based on AxiStreamWidth\nendmodule\n```\nTask: Extracts and assembles MAC addresses from incoming data\n\n3. Pipeline Controller:\n```systemverilog\nmodule pipeline_controller #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        outTready,\n    output AxiStreamType outAxi4St,\n    output logic        inTready\n);\n    // Uses provided local_axist_pipe module\n    local_axist_pipe #(\n        .NumStages(NUM_PIPELINE_STAGES),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (...);\nendmodule\n```\nTask: Manages data pipeline and backpressure\n\n4. Output Aligner:\n```systemverilog\nmodule output_aligner (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] source_mac,\n    input  logic        extraction_complete,\n    input  logic        out_frame_start,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n    // Aligns extracted MAC data with output stream\nendmodule\n```\nTask: Aligns parsed MAC addresses with output stream\n\n5. Top-Level Integration (dut):\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n    // Instantiate and connect all submodules\n    mac_frame_detector u_detector (...);\n    mac_extractor u_extractor (...);\n    pipeline_controller u_pipeline (...);\n    output_aligner u_aligner (...);\nendmodule\n```\n\n6. Debug and Monitor Block (Optional):\n```systemverilog\nmodule mac_parser_monitor #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  AxiStreamType outAxi4St,\n    output logic [31:0] packet_count,\n    output logic [31:0] error_count\n);\n    // Monitoring and statistics collection\nendmodule\n```\nTask: Provides debug information and performance metrics\n\nInterconnections:\n```\n                   +----------------+\n                   |  Frame Start  |\n                   |   Detector    |\n                   +----------------+\n                          |\n                   +----------------+\ninAxi4St --------->| MAC Extractor |\n                   +----------------+\n                          |\n                   +----------------+\n                   |   Pipeline    |\n                   |  Controller   |\n                   +----------------+\n                          |\n                   +----------------+\n                   |    Output     |\n                   |   Aligner     |\n                   +----------------+\n                          |\n                   outAxi4St, MAC data\n```\n\nBenefits of this modular approach:\n1. Easier testing and verification\n2. Better maintainability\n3. Clear separation of concerns\n4. Simplified timing closure\n5. Reusable components\n6. Parallel development possible\n7. Better debug capabilities\n\nEach submodule can be tested independently and then integrated into the complete system.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write the SystemVerilog code for each submodule and identify their critical interfaces:\n\n1. Frame Start Detector:\n```systemverilog\nmodule mac_frame_detector #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        frame_start,\n    output logic        in_frame\n);\n    // Instantiate provided frame start detector\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .tfirst(frame_start),\n        .in_packet(in_frame)\n    );\n\nendmodule\n```\n\n2. MAC Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    input  logic        frame_start,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        extraction_complete\n);\n    localparam BYTES_PER_MAC = 6;\n    logic [3:0] byte_counter;\n    logic [47:0] dest_mac_reg;\n    logic [47:0] source_mac_reg;\n    logic parsing_active;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            parsing_active <= 1'b0;\n            extraction_complete <= 1'b0;\n            dest_mac_reg <= '0;\n            source_mac_reg <= '0;\n        end\n        else if (inAxi4St.tvalid && inTready) begin\n            if (frame_start) begin\n                parsing_active <= 1'b1;\n                byte_counter <= '0;\n                extraction_complete <= 1'b0;\n            end\n            else if (byte_counter == 11) begin\n                parsing_active <= 1'b0;\n                extraction_complete <= 1'b1;\n            end\n\n            if (parsing_active) begin\n                byte_counter <= byte_counter + 1'b1;\n                if (byte_counter < BYTES_PER_MAC) begin\n                    dest_mac_reg <= {dest_mac_reg[39:0], inAxi4St.tdata};\n                end\n                else begin\n                    source_mac_reg <= {source_mac_reg[39:0], inAxi4St.tdata};\n                end\n            end\n        end\n    end\n\n    assign dest_mac = dest_mac_reg;\n    assign source_mac = source_mac_reg;\n\nendmodule\n```\n\n3. Pipeline Controller:\n```systemverilog\nmodule pipeline_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        outTready,\n    output AxiStreamType outAxi4St,\n    output logic        inTready\n);\n    localparam NUM_STAGES = ((48 + AxiStreamWidth - 1) / AxiStreamWidth) - 1;\n\n    local_axist_pipe #(\n        .NumStages(NUM_STAGES),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .pipeAxi4St(),  // Internal pipeline stages\n        .pipeTready(),  // Internal pipeline ready signals\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\n\nendmodule\n```\n\n4. Output Aligner:\n```systemverilog\nmodule output_aligner #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] source_mac,\n    input  logic        extraction_complete,\n    input  logic        out_frame_start,\n    input  AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end\n        else if (outAxi4St.tvalid && outTready && out_frame_start) begin\n            outParsedValid <= 1'b1;\n            outParsedDestMac <= dest_mac;\n            outParsedSourceMac <= source_mac;\n        end\n        else begin\n            outParsedValid <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Frame Detector and MAC Extractor:\n```systemverilog\n// Critical signals\nlogic frame_start;\nlogic in_frame;\n```\n\n2. Between MAC Extractor and Output Aligner:\n```systemverilog\n// Critical signals\nlogic [47:0] dest_mac;\nlogic [47:0] source_mac;\nlogic extraction_complete;\n```\n\n3. Between Pipeline Controller and Output Aligner:\n```systemverilog\n// Critical signals\nAxiStreamType outAxi4St;\nlogic outTready;\n```\n\nInterface Timing Requirements:\n1. All interfaces are synchronous to the same clock\n2. Handshaking protocol between modules follows AXI-Stream\n3. MAC extraction must complete before the first output beat\n4. Pipeline delay must match MAC extraction time\n\nTop-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    // ... ports as specified ...\n);\n\n    // Internal signals\n    logic frame_start, in_frame;\n    logic [47:0] dest_mac, source_mac;\n    logic extraction_complete;\n    logic out_frame_start;\n\n    // Instantiate submodules\n    mac_frame_detector u_detector (\n        // ... connections ...\n    );\n\n    mac_extractor u_extractor (\n        // ... connections ...\n    );\n\n    pipeline_controller u_pipeline (\n        // ... connections ...\n    );\n\n    output_aligner u_aligner (\n        // ... connections ...\n    );\n\nendmodule\n```\n\nThese interfaces require careful timing consideration and proper handshaking to ensure reliable data transfer between modules.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\nAdditionally, you are required to use the folowing module (internal contents not shown) to determine when a packet or frame starts.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining when to start parsing or extracting contents from a frame. For example:\n\nlogic first_byte_of_dest_mac_valid; // if 1, indicates dest mac [47:40] present on inAxi4St.tdata.\nassign first_byte_of_dest_mac_valid = tfirst && in_packet;\n\n\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_4"
  },
  {
    "index": 2,
    "dut": "module dut #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth = 4096,\n  parameter int unsigned EntriesMTU = 1504,\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int         FifoSizeInBytes = 4096,\n  parameter int         MaxNumberOfPackets = 32,\n  parameter int         DropIngressOnAfull = 1,\n  parameter int         DropEgressOnError = 1,\n  parameter int         IngressPrefillBytes = -1\n) (\n  input  logic                             clock,\n  input  logic                             reset,\n  \n  input  AxiStreamType                     inAxi4St,\n  input  logic                             inError,\n  input  logic [ExtraDataWidth-1:0]        inExtra,\n  output logic                             inTready,\n  \n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth-1:0]        outExtra,\n  input  logic                             outTready,\n  \n  output logic                             inFifoAfull,\n  output logic                             inDropEvent,\n  output logic                             outDropEvent\n);\n\n  // Parameter checking\n  initial begin\n    assert(Depth >= 64 && ((Depth & (Depth-1)) == 0)) \n      else $error(\"Depth must be 64 or power of 2 > 64\");\n  end\n\n  // Signal declarations\n  logic frame_in_progress;\n  logic dropping_frame;\n  logic [($clog2(MaxNumberOfPackets+1))-1:0] packet_counter;\n  logic max_packets_reached;\n  logic [$clog2(Depth+1)-1:0] fifo_count;\n  logic fifo_almost_full;\n  \n  // Frame detector\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      frame_in_progress <= 1'b0;\n      dropping_frame <= 1'b0;\n    end else begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n        frame_in_progress <= 1'b0;\n        dropping_frame <= 1'b0;\n      end else if (inAxi4St.tvalid && !frame_in_progress) begin\n        frame_in_progress <= 1'b1;\n        dropping_frame <= (packet_counter >= MaxNumberOfPackets) || \n                        (Depth - fifo_count < EntriesMTU);\n      end\n    end\n  end\n\n  // Packet counter\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      packet_counter <= '0;\n    end else begin\n      if (inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame) begin\n        if (!frame_in_progress)\n          packet_counter <= packet_counter + 1'b1;\n      end else if (outAxi4St.tvalid && outAxi4St.tlast && outTready) begin\n        packet_counter <= packet_counter - 1'b1;\n      end\n    end\n  end\n\n  // Drop event generation\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      inDropEvent <= 1'b0;\n    end else begin\n      inDropEvent <= inAxi4St.tvalid && inAxi4St.tlast && dropping_frame;\n    end\n  end\n\n  // FIFO instantiation\n  local_axist_fifo #(\n    .AxiStreamType(AxiStreamType),\n    .AxiStreamWidth(AxiStreamWidth),\n    .ExtraDataWidth(ExtraDataWidth),\n    .Depth(Depth)\n  ) fifo_inst (\n    .clock(clock),\n    .reset(reset),\n    .inCount(fifo_count),\n    .almostFull(fifo_almost_full),\n    .inAxi4St(inAxi4St),\n    .inError(inError),\n    .inExtra(inExtra),\n    .inTready(),  // Not connected since we generate our own\n    .outAxi4St(outAxi4St),\n    .outError(outError),\n    .outExtra(outExtra),\n    .outTready(outTready)\n  );\n\n  // Output assignments\n  assign inTready = 1'b1;  // Always ready, dropping handled internally\n  assign outDropEvent = 1'b0;\n  assign inFifoAfull = (packet_counter >= MaxNumberOfPackets) || \n                      (Depth - fifo_count < PacketMtuInBytes);\n\n  // Bypass logic for Depth=0\n  generate\n    if (Depth == 0) begin\n      always_comb begin\n        outAxi4St = inAxi4St;\n        outError = inError;\n        outExtra = inExtra;\n      end\n    end\n  endgenerate\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram of this module.\n\nMain Functionality:\nThis module is a specialized AXI4-Stream FIFO that implements a store-and-forward mechanism with frame-dropping capabilities. Key features include:\n\n1. Store-and-Forward Operation:\n- Must store complete frames (packets) before forwarding\n- A frame is defined from first data until tlast=1 is detected\n- Once transmission starts, it must continue until the frame completes\n\n2. Frame Dropping Conditions:\n- If there's insufficient space for MTU-sized frame (PacketMtuInBytes)\n- If the maximum number of stored packets is reached (MaxNumberOfPackets)\n- Dropping is implemented by accepting but not storing the data (inTready=1)\n\n3. FIFO Management:\n- Uses existing local_axist_fifo module for data storage\n- Keeps track of packet counts and available space\n- Handles extra data (inExtra) and error flags alongside the main data\n\nHigh-Level Block Diagram:\n```\n                                   +------------------------+\n                                   |    Packet Counter      |\n                                   |     & Controller       |\n                                   +------------------------+\n                                            |\ninAxi4St    +----------------+    +-----------------+    +----------------+    outAxi4St\n---------->| Frame          |    |                 |    | Frame         |---------->\ninExtra --->| Detection &   |--->|  local_axist_   |--->| Transmission |---> outExtra\ninError --->| Drop Logic    |    |     fifo        |    | Control      |---> outError\n            +----------------+    +-----------------+    +----------------+\n                    |\n                    v\n             inDropEvent\n             inFifoAfull\n```\n\nThe design consists of three main functional blocks:\n1. Frame Detection & Drop Logic: Monitors incoming frames and decides whether to store or drop them\n2. FIFO Storage: Uses local_axist_fifo for actual data storage\n3. Frame Transmission Control: Manages the store-and-forward behavior on the output side\n\nThis creates a robust packet buffering system that can handle overflow conditions gracefully while maintaining AXI4-Stream protocol compliance.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nCritical Parameters:\n1. Depth (FifoSizeInBytes)\n- Default: 4096\n- Must be 64 or power-of-2 > 64\n- Represents total FIFO storage in bytes\n- Critical for system buffering capacity\n\n2. AxiStreamWidth\n- Default: 8 bits\n- Must match AxiStreamType.tdata width\n- Affects data path width and storage calculations\n\n3. PacketMtuInBytes\n- Default: 1500 (standard Ethernet MTU)\n- Used for frame dropping decisions\n- Should be <= FifoSizeInBytes\n\n4. MaxNumberOfPackets\n- Default: 32\n- Maximum concurrent packets stored\n- Affects packet management overhead\n\n5. EntriesMTU\n- Default: 1504 (MTU + overhead)\n- Used for free space checking\n- Should be slightly larger than PacketMtuInBytes\n\n6. ExtraDataWidth\n- Default: 1\n- Width of auxiliary data path\n- Application-specific requirement\n\nOptional Parameters (Required but Fixed):\n1. DropIngressOnAfull\n- Fixed at 1\n- Controls ingress dropping behavior\n\n2. DropEgressOnError\n- Fixed at 1\n- Controls error handling\n\n3. IngressPrefillBytes\n- Fixed at -1\n- Reserved for future use\n\nType Parameters:\n1. AxiStreamType\n- Default: local_pkg::axi4st_8_s\n- Defines the AXI stream interface structure\n\nReasonable Configurations Example:\n```systemverilog\nparameter int Depth = 4096,  // 4KB buffer\nparameter int AxiStreamWidth = 8,  // Byte-wide data\nparameter int PacketMtuInBytes = 1500,  // Standard Ethernet\nparameter int MaxNumberOfPackets = 32,\nparameter int EntriesMTU = 1504,\nparameter int ExtraDataWidth = 1,\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n```\n\nThese parameters allow for:\n1. Scalable buffer sizes\n2. Different data widths\n3. Various MTU sizes\n4. Flexible packet management\n5. Additional data handling capability\n\nThe defaults are chosen to support standard Ethernet-like protocols while maintaining reasonable resource usage.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing flow and required logic elements:\n\nData Processing Flow:\n1. Input Stage:\n```systemverilog\n// Frame tracking\nlogic frame_in_progress;  // Tracks active input frame\nlogic packet_count_full;  // Indicates max packets reached\nlogic space_available;    // Tracks if enough space for MTU\n\n// Drop detection\nlogic should_drop_frame;  // Combinational decision\nlogic dropping_current_frame; // Registered state\n```\n\n2. FIFO Stage:\n```systemverilog\n// Packet counting\nlogic [($clog2(MaxNumberOfPackets)+1)-1:0] packet_counter;\nlogic packet_start;  // First word of packet\nlogic packet_end;    // Last word of packet\n\n// FIFO interface signals\nlogic fifo_write_enable;\nlogic fifo_read_enable;\n```\n\n3. Output Stage:\n```systemverilog\n// Frame transmission control\nlogic frame_out_progress;  // Tracks active output frame\nlogic output_valid;        // Controls tvalid assertion\n```\n\nRequired Logic:\n\n1. Combinational Logic:\n```systemverilog\n// Input drop decision\nassign should_drop_frame = \n    (packet_count_full || !space_available) && \n    inAxi4St.tvalid && !frame_in_progress;\n\n// FIFO write enable\nassign fifo_write_enable = \n    inAxi4St.tvalid && !dropping_current_frame;\n\n// Almost full detection\nassign inFifoAfull = \n    (packet_counter >= MaxNumberOfPackets) ||\n    (Depth - inCount < PacketMtuInBytes);\n```\n\n2. Sequential Logic:\n```systemverilog\n// Frame tracking\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_in_progress <= 1'b0;\n        dropping_current_frame <= 1'b0;\n    end else begin\n        // Track frame progress\n        if (inAxi4St.tvalid && inAxi4St.tlast) begin\n            frame_in_progress <= 1'b0;\n        end else if (inAxi4St.tvalid && !frame_in_progress) begin\n            frame_in_progress <= 1'b1;\n        end\n\n        // Track dropping state\n        if (inAxi4St.tvalid && inAxi4St.tlast) begin\n            dropping_current_frame <= 1'b0;\n        end else if (should_drop_frame) begin\n            dropping_current_frame <= 1'b1;\n        end\n    end\nend\n\n// Packet counter\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        packet_counter <= '0;\n    end else begin\n        if (packet_start && !packet_end) begin\n            packet_counter <= packet_counter + 1;\n        end else if (!packet_start && packet_end) begin\n            packet_counter <= packet_counter - 1;\n        end\n    end\nend\n```\n\n3. Output Control:\n```systemverilog\n// Store and forward control\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_out_progress <= 1'b0;\n        output_valid <= 1'b0;\n    end else begin\n        // Start transmission only on packet boundaries\n        if (!frame_out_progress && fifo_has_complete_packet) begin\n            frame_out_progress <= 1'b1;\n            output_valid <= 1'b1;\n        end else if (outAxi4St.tvalid && outAxi4St.tlast && outTready) begin\n            frame_out_progress <= 1'b0;\n            output_valid <= 1'b0;\n        end\n    end\nend\n```\n\nKey Processing Elements:\n1. Frame State Tracking\n   - Track frame boundaries\n   - Manage drop conditions\n   - Control store/forward behavior\n\n2. Packet Management\n   - Count stored packets\n   - Track FIFO space\n   - Handle MTU restrictions\n\n3. FIFO Control\n   - Write enable logic\n   - Read enable logic\n   - Almost full detection\n\n4. Output Control\n   - Ensure complete packet transmission\n   - Maintain tvalid assertion\n   - Handle backpressure\n\nThis logic ensures proper store-and-forward operation while maintaining frame integrity and handling overflow conditions appropriately.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me break down the clocking, timing, and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain\n- All logic operates on positive edge of 'clock'\n- No clock domain crossing required\n- Synchronous to AXI4-Stream protocol\n\nLatency Characteristics:\n1. Input Path\n```systemverilog\n// 1 cycle latency for frame tracking\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_in_progress <= 1'b0;\n    end else begin\n        frame_in_progress <= inAxi4St.tvalid && !inAxi4St.tlast;\n    end\nend\n```\n\n2. Store-and-Forward Latency\n- Minimum latency: Full frame must be stored before forwarding\n- Example: For 1500-byte frame at 8-bit width = 1500 cycles minimum\n- Additional FIFO traversal latency (typically 2-3 cycles)\n\n3. Output Path\n- 1-2 cycles for output control logic\n- Must maintain continuous transmission once started\n\nThroughput Requirements:\n1. Input Side\n```systemverilog\n// Always ready to accept data\nassign inTready = 1'b1;  // As per specification\n```\n\n2. Output Side\n- Must maintain tvalid=1 during frame transmission\n- No gaps allowed within a frame\n- Back-pressure handled via outTready\n\nReset Requirements:\n1. Synchronous Reset (as specified)\n```systemverilog\n// All sequential elements use synchronous reset\nalways_ff @(posedge clock) begin\n    if (reset) begin  // Synchronous reset\n        frame_in_progress <= 1'b0;\n        dropping_current_frame <= 1'b0;\n        packet_counter <= '0;\n        frame_out_progress <= 1'b0;\n        output_valid <= 1'b0;\n    end else begin\n        // Normal operation\n    end\nend\n```\n\nSignals Requiring Reset:\n1. State Machines\n- frame_in_progress\n- dropping_current_frame\n- frame_out_progress\n\n2. Counters\n- packet_counter\n- Any frame size counters\n\n3. Control Signals\n- output_valid\n- FIFO control signals (through local_axist_fifo)\n\n4. Status Flags\n- inDropEvent\n- inFifoAfull status\n\nTiming Constraints:\n1. Setup/Hold Requirements\n```sdc\n# Example timing constraints\nset_input_delay -clock clock -max 1.0 [all_inputs]\nset_output_delay -clock clock -max 1.0 [all_outputs]\n```\n\n2. Critical Paths\n- Packet counter logic\n- Drop decision logic\n- FIFO status monitoring\n\nPerformance Considerations:\n1. No Clock Gating Required\n- Continuous operation needed for streaming\n\n2. Pipeline Registers\n- May be needed for drop decision logic\n- FIFO interface timing closure\n\n3. Backpressure Handling\n```systemverilog\n// Must respond to outTready without introducing bubbles\nalways_ff @(posedge clock) begin\n    if (frame_out_progress && !outTready) begin\n        // Hold current data\n        outAxi4St <= outAxi4St;\n    end\nend\n```\n\nReset State:\n```systemverilog\n// Initial conditions after reset\ninitial begin\n    frame_in_progress = 1'b0;\n    dropping_current_frame = 1'b0;\n    packet_counter = '0;\n    frame_out_progress = 1'b0;\n    output_valid = 1'b0;\n    inDropEvent = 1'b0;\n    outDropEvent = 1'b0;\nend\n```\n\nThis design ensures:\n1. Predictable latency through store-and-forward\n2. Maximum throughput within protocol constraints\n3. Clean reset behavior\n4. Proper handling of backpressure\n5. Maintainable timing closureWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n1. Basic Functionality\n```systemverilog\n// Test single packet transfer\ntask test_basic_transfer();\n    // Send single packet\n    send_packet(64);  // Small packet\n    check_output_packet(64);\nendtask\n\n// Test back-to-back packets\ntask test_back_to_back();\n    repeat(5) begin\n        send_packet(100);\n        check_output_packet(100);\n    end\nendtask\n```\n\n2. Corner Cases\n```systemverilog\n// Test minimum size packet\ntask test_min_packet();\n    send_packet(1);\n    check_output_packet(1);\nendtask\n\n// Test maximum size packet\ntask test_mtu_packet();\n    send_packet(PacketMtuInBytes);\n    check_output_packet(PacketMtuInBytes);\nendtask\n```\n\n3. Error Conditions\n```systemverilog\n// Test packet dropping\ntask test_overflow();\n    // Fill FIFO\n    repeat(MaxNumberOfPackets) begin\n        send_packet(PacketMtuInBytes);\n    end\n    // Send one more packet\n    send_packet(64);  // Should be dropped\n    check_drop_event();\nendtask\n\n// Test error propagation\ntask test_error_flag();\n    send_packet_with_error(64);\n    check_output_error();\nendtask\n```\n\nAssertions:\n1. Protocol Checks\n```systemverilog\n// Check tvalid/tlast relationship\nproperty valid_last_check;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && outAxi4St.tlast |-> \n        !$past(outAxi4St.tvalid) || $past(outAxi4St.tvalid && !outAxi4St.tlast);\nendproperty\nassert property (valid_last_check);\n\n// Check continuous tvalid during frame\nproperty continuous_valid;\n    @(posedge clock) disable iff (reset)\n    frame_out_progress |-> outAxi4St.tvalid;\nendproperty\nassert property (continuous_valid);\n```\n\n2. FIFO Checks\n```systemverilog\n// Check packet counter overflow\nproperty packet_counter_check;\n    @(posedge clock) disable iff (reset)\n    packet_counter <= MaxNumberOfPackets;\nendproperty\nassert property (packet_counter_check);\n\n// Check FIFO space\nproperty mtu_space_check;\n    @(posedge clock) disable iff (reset)\n    !dropping_current_frame |-> \n        (Depth - inCount >= PacketMtuInBytes);\nendproperty\nassert property (mtu_space_check);\n```\n\n3. Store-and-Forward Checks\n```systemverilog\n// Verify complete frame storage\nproperty store_forward_check;\n    @(posedge clock) disable iff (reset)\n    $rose(outAxi4St.tvalid) |-> \n        complete_frame_stored;\nendproperty\nassert property (store_forward_check);\n\n// Check no gaps in transmission\nproperty no_transmission_gaps;\n    @(posedge clock) disable iff (reset)\n    frame_out_progress && !outAxi4St.tlast |-> \n        outAxi4St.tvalid;\nendproperty\nassert property (no_transmission_gaps);\n```\n\n4. Coverage Points\n```systemverilog\ncovergroup packet_size_cg;\n    packet_size: coverpoint current_packet_size {\n        bins small = {[1:64]};\n        bins medium = {[65:1000]};\n        bins large = {[1001:PacketMtuInBytes]};\n    }\nendgroup\n\ncovergroup fifo_state_cg;\n    fifo_fill: coverpoint packet_counter {\n        bins empty = {0};\n        bins partial = {[1:MaxNumberOfPackets-1]};\n        bins full = {MaxNumberOfPackets};\n    }\nendgroup\n```\n\nTest Environment:\n```systemverilog\nclass test_env;\n    virtual dut_if vif;\n    mailbox #(packet) tx_mb, rx_mb;\n    \n    task run_all_tests();\n        test_basic_transfer();\n        test_back_to_back();\n        test_min_packet();\n        test_mtu_packet();\n        test_overflow();\n        test_error_flag();\n        check_coverage();\n    endtask\nendclass\n```\n\nAdditional Test Cases:\n1. Reset Testing\n- Reset during frame transmission\n- Reset with partially filled FIFO\n- Reset with maximum packets stored\n\n2. Backpressure Testing\n- Variable outTready patterns\n- Maximum backpressure scenarios\n- Random backpressure\n\n3. Error Handling\n- Error flag propagation\n- Drop event verification\n- Multiple consecutive drops\n\nThis verification plan ensures:\n1. Complete functional coverage\n2. Protocol compliance\n3. Corner case handling\n4. Error condition coverage\n5. Performance verification\n6. Assertion-based continuous monitoringWhat potential bugs or issues should be checked for? How can they be prevented?\n [NEW STEP]\n \nLet me outline potential bugs, issues, and prevention strategies:\n\n1. Frame Management Issues\n```systemverilog\n// ISSUE: Frame boundary corruption\n// Prevention: State tracking with assertions\nproperty frame_boundary_check;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St.tvalid) |-> \n        !frame_in_progress || $past(inAxi4St.tlast);\nendproperty\nassert property (frame_boundary_check);\n\n// ISSUE: Lost frames during transitions\n// Prevention: Frame counting checks\nalways_ff @(posedge clock) begin\n    if (reset)\n        frame_count <= '0;\n    else begin\n        if (frame_start && !frame_end)\n            frame_count <= frame_count + 1;\n        else if (!frame_start && frame_end)\n            frame_count <= frame_count - 1;\n    end\nend\n```\n\n2. FIFO Management Issues\n```systemverilog\n// ISSUE: FIFO overflow/underflow\n// Prevention: Space checking logic\nalways_comb begin\n    space_available = (Depth - inCount >= EntriesMTU);\n    assert(packet_counter <= MaxNumberOfPackets) else\n        $error(\"Packet counter overflow detected\");\nend\n\n// ISSUE: Incorrect packet dropping\n// Prevention: Drop condition monitoring\nalways_ff @(posedge clock) begin\n    if (dropping_current_frame)\n        assert(!fifo_write_enable) else\n            $error(\"Writing while dropping frame\");\nend\n```\n\n3. Protocol Violations\n```systemverilog\n// ISSUE: tvalid/tready violations\n// Prevention: Protocol checker\nproperty axi_handshake_check;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |-> \n        $stable(outAxi4St);\nendproperty\nassert property (axi_handshake_check);\n\n// ISSUE: Discontinuous tvalid\nproperty continuous_valid_check;\n    @(posedge clock) disable iff (reset)\n    frame_out_progress && !outAxi4St.tlast |-> \n        outAxi4St.tvalid;\nendproperty\nassert property (continuous_valid_check);\n```\n\n4. Reset and Initialization Issues\n```systemverilog\n// ISSUE: Incomplete reset\n// Prevention: Reset checklist\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        assert(frame_in_progress == 1'b0);\n        assert(dropping_current_frame == 1'b0);\n        assert(packet_counter == '0);\n        assert(frame_out_progress == 1'b0);\n    end\nend\n\n// ISSUE: Post-reset invalid states\n// Prevention: State validation\nproperty post_reset_check;\n    @(posedge clock)\n    $rose(reset) |=> !frame_in_progress && !frame_out_progress;\nendproperty\nassert property (post_reset_check);\n```\n\n5. Timing and Synchronization Issues\n```systemverilog\n// ISSUE: Metastability\n// Prevention: Double-flopping inputs if needed\nlogic [1:0] outTready_sync;\nalways_ff @(posedge clock) begin\n    outTready_sync <= {outTready_sync[0], outTready};\nend\n\n// ISSUE: Race conditions\n// Prevention: Clear sequencing\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        state <= IDLE;\n    end else begin\n        prev_state <= state;  // Track state transitions\n        case (state)\n            // Clear state progression\n        endcase\n    end\nend\n```\n\n6. Counter and Tracking Issues\n```systemverilog\n// ISSUE: Counter wraparound\n// Prevention: Size verification\ninitial begin\n    assert($bits(packet_counter) >= $clog2(MaxNumberOfPackets + 1))\n    else $error(\"Packet counter too small\");\nend\n\n// ISSUE: Lost tracking\n// Prevention: Redundant checking\nlogic [1:0] frame_phase_check;\nalways_ff @(posedge clock) begin\n    frame_phase_check <= {frame_phase_check[0],\n                         frame_in_progress};\n    assert(!(frame_phase_check == 2'b10 &&\n             !inAxi4St.tvalid)) else\n        $error(\"Lost frame tracking\");\nend\n```\n\n7. Resource and Performance Issues\n```systemverilog\n// ISSUE: Memory leaks\n// Prevention: Resource tracking\nalways_ff @(posedge clock) begin\n    if (packet_counter > 0)\n        assert(stored_bytes > 0) else\n            $error(\"Inconsistent storage state\");\nend\n\n// ISSUE: Performance bottlenecks\n// Prevention: Performance counters\nalways_ff @(posedge clock) begin\n    if (frame_out_progress && !outTready)\n        stall_counter <= stall_counter + 1;\nend\n```\n\nBug Prevention Strategy:\n1. Design Reviews\n- Regular code reviews\n- Architecture validation\n- Protocol compliance checks\n\n2. Verification Planning\n- Comprehensive test cases\n- Corner case coverage\n- Random stimulus testing\n\n3. Runtime Checks\n- Assertions for protocol\n- Counters for resource usage\n- State machine validation\n\n4. Documentation\n- Clear specifications\n- Interface requirements\n- Error handling procedures\n\n5. Defensive Coding\n- Parameter validation\n- State consistency checks\n- Resource monitoring\n\nThis approach ensures:\n1. Protocol compliance\n2. Resource management\n3. Timing correctness\n4. Error handling\n5. Performance monitoring\n6. Maintainable codeWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and their specific tasks:\n\n1. Frame Detector and Drop Controller\n```systemverilog\nmodule frame_detector (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  AxiStreamType           inAxi4St,\n    input  logic [CountWidth-1:0]  fifo_count,\n    output logic                   dropping_frame,\n    output logic                   frame_in_progress,\n    output logic                   inDropEvent\n);\n```\nTasks:\n- Detects frame boundaries\n- Makes drop decisions based on FIFO space\n- Tracks active frame status\n- Generates drop events\n\n2. Packet Counter\n```systemverilog\nmodule packet_counter (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  logic                    packet_start,\n    input  logic                    packet_end,\n    output logic [$clog2(MaxNumberOfPackets):0] count,\n    output logic                    max_packets_reached\n);\n```\nTasks:\n- Maintains count of stored packets\n- Detects maximum packet threshold\n- Tracks packet boundaries\n- Provides packet storage status\n\n3. FIFO Controller\n```systemverilog\nmodule fifo_controller (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  AxiStreamType           inAxi4St,\n    input  logic                    dropping_frame,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic                    inError,\n    output logic                    fifo_write,\n    output logic                    fifo_read,\n    output logic                    inFifoAfull\n);\n```\nTasks:\n- Manages FIFO write/read operations\n- Handles data/extra/error storage\n- Generates almost full status\n- Controls store-and-forward timing\n\n4. Store and Forward Controller\n```systemverilog\nmodule store_forward_controller (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  logic                    outTready,\n    input  AxiStreamType           fifo_data,\n    output AxiStreamType           outAxi4St,\n    output logic                    fifo_read_en\n);\n```\nTasks:\n- Controls frame transmission timing\n- Ensures continuous transmission\n- Handles backpressure\n- Maintains store-and-forward protocol\n\n5. Status Generator\n```systemverilog\nmodule status_generator (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  logic                    dropping_frame,\n    input  logic                    max_packets_reached,\n    input  logic [CountWidth-1:0]   fifo_count,\n    output logic                    inFifoAfull,\n    output logic                    inDropEvent,\n    output logic                    outDropEvent\n);\n```\nTasks:\n- Generates status signals\n- Tracks FIFO conditions\n- Reports drop events\n- Monitors resource usage\n\nTop-Level Integration:\n```systemverilog\nmodule dut (\n    // ... port list ...\n);\n    // Interconnect signals\n    logic dropping_frame;\n    logic frame_in_progress;\n    logic packet_start, packet_end;\n    logic [CountWidth-1:0] packet_count;\n    \n    // Instantiate submodules\n    frame_detector frame_det_inst (\n        .clock(clock),\n        .reset(reset),\n        // ... connections ...\n    );\n    \n    packet_counter pkt_cnt_inst (\n        .clock(clock),\n        .reset(reset),\n        // ... connections ...\n    );\n    \n    // ... other instantiations ...\n    \n    // Local FIFO instance\n    local_axist_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .Depth(Depth)\n    ) fifo_inst (\n        // ... connections ...\n    );\nendmodule\n```\n\nInteractions Between Blocks:\n```plaintext\nFrame Detector \u2192 FIFO Controller\n- Provides drop decisions\n- Signals frame boundaries\n\nPacket Counter \u2192 Status Generator\n- Provides packet counts\n- Signals maximum packet condition\n\nFIFO Controller \u2192 Store Forward Controller\n- Coordinates data transfer\n- Manages buffer status\n\nStore Forward Controller \u2192 Status Generator\n- Reports transmission status\n- Indicates completion\n```\n\nBenefits of This Modular Approach:\n1. Separation of Concerns\n- Each module has a specific responsibility\n- Easier to test and verify\n- Better maintainability\n\n2. Reusability\n- Modules can be used in other designs\n- Standardized interfaces\n- Configurable parameters\n\n3. Verification Advantages\n- Isolated testing possible\n- Clear boundaries for assertions\n- Simplified debug process\n\n4. Design Management\n- Better code organization\n- Easier team development\n- Clear documentation structure\n\nThis modular approach creates a well-organized, maintainable, and verifiable design while keeping the complexity manageable.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide the SystemVerilog code for each submodule and highlight the critical interfaces between them.\n\n1. Frame Detector and Drop Controller:\n```systemverilog\nmodule frame_detector #(\n    parameter int PacketMtuInBytes = 1500,\n    parameter int Depth = 4096,\n    parameter type AxiStreamType = logic\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    input  logic [CountWidth-1:0] fifo_count,\n    input  logic max_packets_reached,\n    output logic dropping_frame,\n    output logic frame_in_progress,\n    output logic inDropEvent,\n    output logic packet_start,\n    output logic packet_end\n);\n\n    logic should_drop;\n    logic enough_space;\n\n    // Space availability check\n    assign enough_space = (Depth - fifo_count) >= PacketMtuInBytes;\n    \n    // Drop decision\n    assign should_drop = !enough_space || max_packets_reached;\n\n    // Frame tracking\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_in_progress <= 1'b0;\n            dropping_frame <= 1'b0;\n            inDropEvent <= 1'b0;\n        end else begin\n            // Frame progress tracking\n            if (inAxi4St.tvalid && inAxi4St.tlast) begin\n                frame_in_progress <= 1'b0;\n                if (dropping_frame) inDropEvent <= 1'b1;\n            end else if (inAxi4St.tvalid && !frame_in_progress) begin\n                frame_in_progress <= 1'b1;\n                dropping_frame <= should_drop;\n            end\n            \n            // Clear drop event\n            if (!inAxi4St.tvalid) inDropEvent <= 1'b0;\n        end\n    end\n\n    // Packet boundary detection\n    assign packet_start = inAxi4St.tvalid && !frame_in_progress && !dropping_frame;\n    assign packet_end = inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame;\n\nendmodule\n```\n\n2. Packet Counter:\n```systemverilog\nmodule packet_counter #(\n    parameter int MaxNumberOfPackets = 32\n) (\n    input  logic clock,\n    input  logic reset,\n    input  logic packet_start,\n    input  logic packet_end,\n    output logic [$clog2(MaxNumberOfPackets+1)-1:0] count,\n    output logic max_packets_reached\n);\n\n    // Packet counting\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            count <= '0;\n        end else begin\n            if (packet_start && !packet_end)\n                count <= count + 1'b1;\n            else if (!packet_start && packet_end)\n                count <= count - 1'b1;\n        end\n    end\n\n    // Maximum packet detection\n    assign max_packets_reached = (count >= MaxNumberOfPackets);\n\nendmodule\n```\n\n3. FIFO Controller:\n```systemverilog\nmodule fifo_controller #(\n    parameter type AxiStreamType = logic,\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    input  logic dropping_frame,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic inError,\n    input  logic outTready,\n    output logic fifo_write,\n    output logic fifo_read,\n    output AxiStreamType fifo_in_data,\n    input  AxiStreamType fifo_out_data,\n    output logic [ExtraDataWidth-1:0] fifo_in_extra,\n    output logic fifo_in_error\n);\n\n    // Write control\n    assign fifo_write = inAxi4St.tvalid && !dropping_frame;\n    \n    // Read control\n    assign fifo_read = fifo_out_data.tvalid && outTready;\n    \n    // Data path\n    always_comb begin\n        fifo_in_data = inAxi4St;\n        fifo_in_extra = inExtra;\n        fifo_in_error = inError;\n    end\n\nendmodule\n```\n\n4. Store and Forward Controller:\n```systemverilog\nmodule store_forward_controller #(\n    parameter type AxiStreamType = logic\n) (\n    input  logic clock,\n    input  logic reset,\n    input  logic outTready,\n    input  AxiStreamType fifo_data,\n    output AxiStreamType outAxi4St,\n    output logic frame_transmitting\n);\n\n    // Frame transmission tracking\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_transmitting <= 1'b0;\n        end else begin\n            if (fifo_data.tvalid && fifo_data.tlast && outTready)\n                frame_transmitting <= 1'b0;\n            else if (fifo_data.tvalid && !frame_transmitting)\n                frame_transmitting <= 1'b1;\n        end\n    end\n\n    // Output assignment\n    always_comb begin\n        outAxi4St = fifo_data;\n        outAxi4St.tvalid = fifo_data.tvalid && frame_transmitting;\n    end\n\nendmodule\n```\n\nCritical Interfaces Between Submodules:\n\n1. Frame Detector to FIFO Controller:\n```systemverilog\n// Critical signals\nlogic dropping_frame;\nlogic frame_in_progress;\n```\nPurpose: Controls when data is written to FIFO\n\n2. Packet Counter to Frame Detector:\n```systemverilog\n// Critical signals\nlogic max_packets_reached;\nlogic packet_start;\nlogic packet_end;\n```\nPurpose: Influences drop decisions\n\n3. FIFO Controller to Store Forward Controller:\n```systemverilog\n// Critical signals\nAxiStreamType fifo_data;\nlogic fifo_read;\nlogic frame_transmitting;\n```\nPurpose: Manages data flow and transmission timing\n\nTop-Level Integration:\n```systemverilog\nmodule dut #(\n    // Parameters\n) (\n    // Ports\n);\n\n    // Internal signals\n    logic dropping_frame, frame_in_progress;\n    logic packet_start, packet_end;\n    logic max_packets_reached;\n    logic frame_transmitting;\n    AxiStreamType fifo_data;\n\n    // Instantiate submodules\n    frame_detector frame_det (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .dropping_frame(dropping_frame),\n        .frame_in_progress(frame_in_progress),\n        .max_packets_reached(max_packets_reached),\n        .packet_start(packet_start),\n        .packet_end(packet_end)\n    );\n\n    packet_counter pkt_counter (\n        .clock(clock),\n        .reset(reset),\n        .packet_start(packet_start),\n        .packet_end(packet_end),\n        .max_packets_reached(max_packets_reached)\n    );\n\n    // ... other instantiations ...\n\n    // Local FIFO instance\n    local_axist_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .Depth(Depth)\n    ) fifo_inst (\n        // ... connections ...\n    );\n\nendmodule\n```\n\nThe critical interfaces ensure:\n1. Proper frame handling\n2. Accurate packet counting\n3. Coordinated data flow\n4. Clean store-and-forward operation\n\nThis modular design with well-defined interfaces allows for:\n- Easy debugging\n- Independent testing\n- Clear functionality boundaries\n- Maintainable code structure\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = local_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = local_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_axist_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = local_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_storefwd_fifo_4"
  },
  {
    "index": 1,
    "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int unsigned AxiStreamWidth = 128,\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // MAC table entry definition\n    typedef struct packed {\n        logic valid;\n        logic [47:0] mac_addr;\n        logic [$clog2(NumPorts)-1:0] port_id;\n        logic [31:0] age_counter;\n    } mac_entry_t;\n\n    // MAC table storage\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n    logic [$clog2(MacTableDepth)-1:0] mac_write_ptr;\n\n    // Per-port signals\n    logic [NumPorts-1:0][47:0] dst_mac;\n    logic [NumPorts-1:0][47:0] src_mac;\n    logic [NumPorts-1:0] frame_start;\n    logic [NumPorts-1:0] frame_valid;\n    logic [NumPorts-1:0][NumPorts-1:0] route_mask;\n    logic [NumPorts-1:0] is_broadcast;\n    logic [NumPorts-1:0] is_multicast;\n    \n    // Frame processing state machine\n    typedef enum logic [1:0] {\n        IDLE,\n        HEADER,\n        PAYLOAD,\n        COMPLETE\n    } state_t;\n    \n    state_t [NumPorts-1:0] rx_state;\n    logic [NumPorts-1:0][$clog2(MaxFrameSize)-1:0] byte_count;\n\n    // MAC Table Management\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_table <= '{default: '0};\n            mac_write_ptr <= '0;\n        end else begin\n            // MAC Learning\n            for (int i = 0; i < NumPorts; i++) begin\n                if (frame_valid[i]) begin\n                    logic found = 0;\n                    // Check if MAC exists\n                    for (int j = 0; j < MacTableDepth; j++) begin\n                        if (mac_table[j].valid && mac_table[j].mac_addr == src_mac[i]) begin\n                            mac_table[j].port_id <= i[$clog2(NumPorts)-1:0];\n                            mac_table[j].age_counter <= '0;\n                            found = 1;\n                        end\n                    end\n                    // Add new entry if not found\n                    if (!found) begin\n                        mac_table[mac_write_ptr].valid <= 1'b1;\n                        mac_table[mac_write_ptr].mac_addr <= src_mac[i];\n                        mac_table[mac_write_ptr].port_id <= i[$clog2(NumPorts)-1:0];\n                        mac_table[mac_write_ptr].age_counter <= '0;\n                        mac_write_ptr <= mac_write_ptr + 1;\n                    end\n                end\n            end\n\n            // Aging\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                        mac_table[i].valid <= 1'b0;\n                    else\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                end\n            end\n        end\n    end\n\n    // Frame Processing Per Port\n    generate\n    for (genvar i = 0; i < NumPorts; i++) begin : port_logic\n        always_ff @(posedge clock) begin\n            if (reset) begin\n                rx_state[i] <= IDLE;\n                byte_count[i] <= '0;\n                dst_mac[i] <= '0;\n                src_mac[i] <= '0;\n                frame_valid[i] <= 1'b0;\n                route_mask[i] <= '0;\n                is_broadcast[i] <= 1'b0;\n                is_multicast[i] <= 1'b0;\n                outAxi4St[i] <= '{default: '0};\n            end else begin\n                case (rx_state[i])\n                    IDLE: begin\n                        if (inAxi4St[i].tvalid && inTready[i]) begin\n                            rx_state[i] <= HEADER;\n                            byte_count[i] <= '0;\n                        end\n                    end\n\n                    HEADER: begin\n                        if (inAxi4St[i].tvalid && inTready[i]) begin\n                            if (byte_count[i] < 6)\n                                dst_mac[i] <= {dst_mac[i][39:0], inAxi4St[i].tdata[7:0]};\n                            else if (byte_count[i] < 12)\n                                src_mac[i] <= {src_mac[i][39:0], inAxi4St[i].tdata[7:0]};\n                            \n                            byte_count[i] <= byte_count[i] + 1;\n                            \n                            if (byte_count[i] == 11) begin\n                                rx_state[i] <= PAYLOAD;\n                                frame_valid[i] <= 1'b1;\n                                is_broadcast[i] <= &dst_mac[i];\n                                is_multicast[i] <= dst_mac[i][40];\n                            end\n                        end\n                    end\n\n                    PAYLOAD: begin\n                        if (inAxi4St[i].tvalid && inTready[i] && inAxi4St[i].tlast) begin\n                            rx_state[i] <= COMPLETE;\n                            frame_valid[i] <= 1'b0;\n                        end\n                    end\n\n                    COMPLETE: begin\n                        rx_state[i] <= IDLE;\n                    end\n                endcase\n            end\n        end\n\n        // Route mask generation\n        always_comb begin\n            route_mask[i] = '0;\n            if (frame_valid[i]) begin\n                if (is_broadcast[i] || is_multicast[i]) begin\n                    route_mask[i] = ~(1 << i);\n                end else begin\n                    logic found = 0;\n                    logic [$clog2(NumPorts)-1:0] found_port;\n                    \n                    for (int j = 0; j < MacTableDepth; j++) begin\n                        if (mac_table[j].valid && mac_table[j].mac_addr == dst_mac[i]) begin\n                            found = 1;\n                            found_port = mac_table[j].port_id;\n                        end\n                    end\n                    \n                    if (found)\n                        route_mask[i] = (1 << found_port) & ~(1 << i);\n                    else\n                        route_mask[i] = ~(1 << i);\n                end\n            end\n        end\n\n        // Input ready generation\n        assign inTready[i] = (rx_state[i] != COMPLETE) && outTready[i];\n    end\n    endgenerate\n\n    // Frame forwarding\n    always_comb begin\n        for (int i = 0; i < NumPorts; i++) begin\n            for (int j = 0; j < NumPorts; j++) begin\n                if (route_mask[i][j]) begin\n                    outAxi4St[j] = inAxi4St[i];\n                end\n            end\n        end\n    end\n\n    // Drive egressFifoDropEvents to 0 as specified\n    assign egressFifoDropEvents = '0;\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram of this Layer-2 Ethernet Switch:\n\nMain Functionality:\n1. The module is a 4-port Ethernet switch that routes frames between ports based on MAC addresses\n2. Key features:\n   - MAC address learning (16-entry table)\n   - Frame forwarding based on destination MAC\n   - Broadcast/multicast support\n   - No loopback allowed\n   - Support for aging out MAC table entries\n   - AXI4-Stream interface for data transfer\n\nHigh-Level Block Diagram:\n```\n                                 Layer-2 Switch\n+--------------------------------------------------------------------------------+\n|                                                                                 |\n|  +-------------+     +----------------+     +------------------+                 |\n|  |             |     |                |     |                  |                 |\n|-->| Port 0 Rx  |     |  MAC Address   |     |   Port 0 Tx     |-->             |\n|   |  Buffer    |     |    Table       |     |    Buffer       |                 |\n|   |            |     |   (16 entries) |     |                 |                 |\n|-->| Port 1 Rx  |     |  +---------+   |     |   Port 1 Tx     |-->             |\n|   |  Buffer    |---->|  | MAC     |   |---->|    Buffer       |                 |\n|   |            |     |  | Port    |   |     |                 |                 |\n|-->| Port 2 Rx  |     |  | Age     |   |     |   Port 2 Tx     |-->             |\n|   |  Buffer    |     |  +---------+   |     |    Buffer       |                 |\n|   |            |     |                |     |                 |                 |\n|-->| Port 3 Rx  |     |                |     |   Port 3 Tx     |-->             |\n|   |  Buffer    |     |                |     |    Buffer       |                 |\n|   +-------------+     +----------------+     +------------------+                 |\n|                                                                                 |\n+--------------------------------------------------------------------------------+\n```\n\nKey Components:\n1. Input Ports (Rx):\n   - AXI4-Stream interfaces\n   - Backpressure support via inTready\n   - Frame buffering\n\n2. MAC Address Table:\n   - 16 entries\n   - Learning mechanism\n   - Aging mechanism (1.75B cycles timeout)\n   - Port mapping\n\n3. Output Ports (Tx):\n   - AXI4-Stream interfaces\n   - Backpressure handling via outTready\n   - Frame forwarding logic\n\n4. Control Logic:\n   - Frame routing decisions\n   - Broadcast/multicast handling\n   - No loopback enforcement\n\nThis module essentially acts as a smart frame router, learning MAC addresses and forwarding frames based on destination addresses while preventing loops and handling broadcast/multicast traffic appropriately.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let me identify the key parameterizable aspects and their reasonable default values:\n\n1. Already Specified Parameters:\n```systemverilog\nparameter int NumPorts = 4                                // Number of switch ports\nparameter type AxiStreamType = local_pkg::axi4st_128_s   // AXI4-Stream interface type\nparameter int unsigned AxiStreamWidth = 128              // Width of AXI data bus\nparameter int MacTableDepth = 16                         // MAC address table entries\nparameter int MacTableCyclesPerEpoch = 32'd1_750_000_000 // Aging timeout\n```\n\n2. Additional Recommended Parameters:\n\n```systemverilog\n// Frame size related\nparameter int MinFrameSize = 60    // Minimum Ethernet frame size\nparameter int MaxFrameSize = 1504  // Maximum Ethernet frame size\n\n// FIFO related\nparameter int FifoDepth = 32       // Depth of input/output FIFOs\nparameter int FifoAlmostFull = 28  // Threshold for backpressure\n\n// MAC table related\nparameter int MacAddrWidth = 48    // Width of MAC address\nparameter int PortIdWidth = $clog2(NumPorts) // Width of port ID field\n```\n\nReasoning for Default Values:\n\n1. Frame Buffers:\n   - FifoDepth = 32: Provides enough buffering for multiple frames while being resource-efficient\n   - FifoAlmostFull = 28: Allows time for backpressure to propagate\n\n2. MAC Table:\n   - MacTableDepth = 16: Good balance between resource usage and network size\n   - MacTableCyclesPerEpoch = 1.75B cycles: Reasonable aging time (~7 seconds at 250MHz)\n\n3. Interface:\n   - AxiStreamWidth = 128: Good balance between throughput and resource usage\n   - NumPorts = 4: Common configuration for small switches\n\n4. Frame Sizes:\n   - MinFrameSize = 60: Standard Ethernet minimum\n   - MaxFrameSize = 1504: Standard Ethernet maximum (including FCS)\n\nThese parameters allow the module to be configured for different:\n- Network sizes (NumPorts)\n- Performance requirements (AxiStreamWidth)\n- Memory constraints (FifoDepth, MacTableDepth)\n- Timing requirements (MacTableCyclesPerEpoch)\n- Protocol variations (frame sizes)\n\nThe default values provide a good starting point for most applications while allowing customization when needed.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing flow and required logic components:\n\nData Processing Flow:\n```\nInput Frame -> MAC Learning -> Route Decision -> Output Selection -> Frame Forwarding\n```\n\nRequired Components:\n\n1. Input Processing Logic:\n```systemverilog\n// Input registers per port\nlogic [NumPorts-1:0] frame_in_progress;\nlogic [NumPorts-1:0][47:0] current_src_mac;\nlogic [NumPorts-1:0][47:0] current_dst_mac;\nlogic [NumPorts-1:0][$clog2(MaxFrameSize)-1:0] frame_byte_count;\n```\n\n2. MAC Table Logic:\n```systemverilog\ntypedef struct packed {\n    logic valid;\n    logic [47:0] mac_addr;\n    logic [$clog2(NumPorts)-1:0] port_id;\n    logic [31:0] age_counter;\n} mac_table_entry_t;\n\nmac_table_entry_t [MacTableDepth-1:0] mac_table;\n```\n\n3. Route Decision Logic:\n```systemverilog\n// Per input port\nlogic [NumPorts-1:0] output_port_mask;  // Destination ports\nlogic is_broadcast;\nlogic is_multicast;\nlogic mac_table_hit;\nlogic [$clog2(NumPorts)-1:0] dest_port;\n```\n\n4. Output Selection Logic:\n```systemverilog\n// Per output port\nlogic [NumPorts-1:0] port_busy;\nlogic [NumPorts-1:0] port_grant;\nlogic [$clog2(NumPorts)-1:0] selected_input;\n```\n\nProcessing Steps:\n\n1. Input Frame Processing:\n```systemverilog\n// For each input port\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_in_progress <= '0;\n    end else if (inAxi4St[port].tvalid && inTready[port]) begin\n        if (frame_byte_count == 0) begin\n            // Capture MAC addresses from frame header\n            current_dst_mac[port] <= inAxi4St[port].tdata[47:0];\n            current_src_mac[port] <= inAxi4St[port].tdata[95:48];\n        end\n        frame_in_progress[port] <= !inAxi4St[port].tlast;\n    end\nend\n```\n\n2. MAC Learning:\n```systemverilog\n// MAC table update logic\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        mac_table <= '{default: '0};\n    end else begin\n        // Add/update source MAC entries\n        if (new_mac_detected) begin\n            mac_table[free_entry].valid <= 1'b1;\n            mac_table[free_entry].mac_addr <= current_src_mac;\n            mac_table[free_entry].port_id <= current_port;\n            mac_table[free_entry].age_counter <= '0;\n        end\n        \n        // Age counter management\n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (mac_table[i].valid) begin\n                if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                    mac_table[i].valid <= 1'b0;\n                else\n                    mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n            end\n        end\n    end\nend\n```\n\n3. Route Decision:\n```systemverilog\n// Combinational logic for routing\nalways_comb begin\n    is_broadcast = &current_dst_mac;\n    is_multicast = current_dst_mac[40];\n    \n    // Generate output port mask\n    if (is_broadcast || is_multicast) begin\n        output_port_mask = ~(1 << input_port);  // All ports except input\n    end else if (mac_table_hit) begin\n        output_port_mask = (1 << dest_port) & ~(1 << input_port);\n    end else begin\n        output_port_mask = ~(1 << input_port);  // Unknown MAC -> flood\n    end\nend\n```\n\n4. Output Selection:\n```systemverilog\n// Round-robin arbitration per output port\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        port_grant <= '0;\n    end else begin\n        // Implement round-robin selection among requesting inputs\n        port_grant <= next_grant(port_grant, output_port_mask);\n    end\nend\n```\n\nKey Considerations:\n1. Proper handling of AXI4-Stream protocol signals\n2. Efficient MAC table lookup and update\n3. Fair arbitration for output port selection\n4. Proper frame buffering and backpressure handling\n5. Error handling for malformed frames\n6. Efficient aging mechanism for MAC table entries\n\nThis design requires careful timing consideration and proper pipeline stages to meet timing requirements while maintaining wire-speed performance.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description and typical Ethernet switch requirements, let me analyze the timing aspects:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock    // System clock\ninput logic reset    // Synchronous reset (specified in requirements)\n```\n\nTypical Clock Frequencies:\n- For 1Gbps Ethernet: 125 MHz minimum\n- For internal processing: Usually 2-4x faster (250-500 MHz)\n- Target frequency should allow processing of maximum throughput\n\nLatency Requirements:\n1. Input Processing:\n```systemverilog\n// Typical pipeline stages\nparameter int InputLatency = 2;    // MAC address extraction\nparameter int LookupLatency = 2;   // MAC table lookup\nparameter int RouteLatency = 1;    // Route decision\nparameter int OutputLatency = 2;   // Output selection and forwarding\n```\n\nTotal latency: ~7 clock cycles minimum per frame\n\nThroughput Requirements:\n1. Must handle line rate:\n```systemverilog\n// For 1Gbps Ethernet with 128-bit data path:\n// 1Gbps / 8 bits = 125 MB/s\n// 125 MB/s / 16 bytes = 7.8M transfers/sec minimum\n```\n\nReset Requirements (Synchronous):\n1. Registers requiring reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Control registers\n        frame_in_progress <= '0;\n        frame_byte_count <= '0;\n        \n        // MAC table\n        mac_table <= '{default: '0};\n        \n        // Output control\n        port_grant <= '0;\n        output_valid <= '0;\n        \n        // AXI4-Stream control\n        inTready <= '0;\n        outAxi4St <= '{default: '0};\n    end\nend\n```\n\n2. Registers not requiring reset:\n```systemverilog\n// Data registers (will be overwritten)\ncurrent_src_mac\ncurrent_dst_mac\nframe_data_buffer\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n```tcl\n# Example SDC constraints\ncreate_clock -name clock -period 4.000 [get_ports clock]\nset_input_delay -clock clock -max 2.000 [all_inputs]\nset_output_delay -clock clock -max 2.000 [all_outputs]\n```\n\n2. Critical Paths:\n- MAC table lookup path\n- Route decision logic\n- Output arbitration\n\nPipeline Structure:\n```systemverilog\n// Stage 1: Input Processing\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        stage1_valid <= '0;\n    end else begin\n        if (inAxi4St[port].tvalid && inTready[port]) begin\n            stage1_data <= inAxi4St[port].tdata;\n            stage1_valid <= 1'b1;\n        end\n    end\nend\n\n// Stage 2: MAC Table Lookup\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        stage2_valid <= '0;\n    end else begin\n        if (stage1_valid) begin\n            // MAC table lookup logic\n            stage2_valid <= stage1_valid;\n        end\n    end\nend\n\n// Additional pipeline stages...\n```\n\nPerformance Considerations:\n1. Throughput Guarantees:\n```systemverilog\n// Ensure input ready when buffers not full\nassign inTready = ~fifo_almost_full & ~reset;\n\n// Track buffer occupancy\nalways_ff @(posedge clock) begin\n    if (reset)\n        fifo_count <= '0;\n    else if (write_en && !read_en)\n        fifo_count <= fifo_count + 1;\n    else if (!write_en && read_en)\n        fifo_count <= fifo_count - 1;\nend\n```\n\n2. Backpressure Handling:\n```systemverilog\n// Assert backpressure when buffers near full\nassign fifo_almost_full = (fifo_count >= FifoAlmostFull);\n```\n\nCritical Design Points:\n1. Use synchronous reset as specified\n2. Implement proper pipeline stages to meet timing\n3. Ensure no combinational loops in routing logic\n4. Handle backpressure properly to prevent data loss\n5. Balance latency vs. resource usage in pipeline design\n6. Consider using timing constraints for synthesis optimization\n7. Implement proper clock domain crossing if needed in the future\n\nThese timing considerations ensure reliable operation while maintaining wire-speed performance.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n\n1. Basic Frame Forwarding:\n```systemverilog\n// Test basic unicast forwarding\ntask test_basic_forwarding;\n    // Send frame with known destination\n    send_frame(0, DEST_MAC_A, SRC_MAC_B, test_data);\n    // Verify correct output port\n    check_frame(1, DEST_MAC_A, SRC_MAC_B, test_data);\nendtask\n```\n\n2. MAC Learning:\n```systemverilog\n// Test MAC learning functionality\ntask test_mac_learning;\n    // Send frame to learn source MAC\n    send_frame(0, DEST_MAC_A, SRC_MAC_B, test_data);\n    // Verify MAC table entry\n    check_mac_table_entry(SRC_MAC_B, 0);\n    // Send response to learned MAC\n    send_frame(1, SRC_MAC_B, DEST_MAC_A, test_data);\n    // Verify direct forwarding\n    check_frame(0, SRC_MAC_B, DEST_MAC_A, test_data);\nendtask\n```\n\n3. Broadcast/Multicast:\n```systemverilog\n// Test broadcast handling\ntask test_broadcast;\n    // Send broadcast frame\n    send_frame(0, BROADCAST_MAC, SRC_MAC_A, test_data);\n    // Verify frame on all ports except source\n    fork\n        check_frame(1, BROADCAST_MAC, SRC_MAC_A, test_data);\n        check_frame(2, BROADCAST_MAC, SRC_MAC_A, test_data);\n        check_frame(3, BROADCAST_MAC, SRC_MAC_A, test_data);\n    join\nendtask\n```\n\n4. MAC Table Aging:\n```systemverilog\n// Test MAC aging functionality\ntask test_mac_aging;\n    // Learn MAC address\n    send_frame(0, DEST_MAC_A, SRC_MAC_B, test_data);\n    // Wait aging period\n    repeat(MacTableCyclesPerEpoch) @(posedge clock);\n    // Verify MAC entry invalidated\n    check_mac_table_entry_invalid(SRC_MAC_B);\nendtask\n```\n\nAssertions:\n\n1. Protocol Compliance:\n```systemverilog\n// Check AXI4-Stream protocol rules\nproperty axi4_valid_ready_p;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St[*].tvalid) |-> !$fell(inTready[*]);\nendproperty\nassert property(axi4_valid_ready_p) else\n    $error(\"AXI4-Stream protocol violation\");\n\n// Check frame size limits\nproperty frame_size_p;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St[*].tlast) |-> \n        (frame_byte_count >= MinFrameSize && frame_byte_count <= MaxFrameSize);\nendproperty\nassert property(frame_size_p) else\n    $error(\"Invalid frame size detected\");\n```\n\n2. Functional Checks:\n```systemverilog\n// No loopback allowed\nproperty no_loopback_p;\n    @(posedge clock) disable iff (reset)\n    output_port_mask[*] |-> !(output_port_mask[current_input_port]);\nendproperty\nassert property(no_loopback_p) else\n    $error(\"Loopback detected\");\n\n// MAC table consistency\nproperty mac_table_valid_p;\n    @(posedge clock) disable iff (reset)\n    mac_table[*].valid |-> (mac_table[*].port_id < NumPorts);\nendproperty\nassert property(mac_table_valid_p) else\n    $error(\"Invalid port ID in MAC table\");\n```\n\n3. Resource Management:\n```systemverilog\n// FIFO overflow protection\nproperty fifo_overflow_p;\n    @(posedge clock) disable iff (reset)\n    fifo_count <= FifoDepth;\nendproperty\nassert property(fifo_overflow_p) else\n    $error(\"FIFO overflow detected\");\n\n// Backpressure assertion\nproperty backpressure_p;\n    @(posedge clock) disable iff (reset)\n    fifo_almost_full |-> !inTready;\nendproperty\nassert property(backpressure_p) else\n    $error(\"Backpressure not properly applied\");\n```\n\nCoverage Points:\n\n1. Functional Coverage:\n```systemverilog\ncovergroup switch_cg;\n    port_cp: coverpoint current_input_port {\n        bins ports[] = {[0:NumPorts-1]};\n    }\n    \n    frame_size_cp: coverpoint frame_byte_count {\n        bins min_size = {MinFrameSize};\n        bins max_size = {MaxFrameSize};\n        bins mid_sizes[] = {[MinFrameSize+1:MaxFrameSize-1]};\n    }\n    \n    mac_type_cp: coverpoint frame_type {\n        bins unicast = {0};\n        bins broadcast = {1};\n        bins multicast = {2};\n    }\nendgroup\n```\n\n2. Corner Cases:\n```systemverilog\n// Test simultaneous ports active\nproperty multi_port_activity_p;\n    @(posedge clock)\n    $countones(inAxi4St.tvalid) > 1;\nendproperty\ncover property(multi_port_activity_p);\n\n// Test MAC table full condition\nproperty mac_table_full_p;\n    @(posedge clock)\n    $countones(mac_table.valid) == MacTableDepth;\nendproperty\ncover property(mac_table_full_p);\n```\n\nTest Infrastructure:\n```systemverilog\nclass switch_test;\n    // Test configuration\n    virtual switch_if vif;\n    mailbox #(frame_t) exp_mb[NumPorts];\n    \n    // Scoreboard\n    task run_scoreboard();\n        forever begin\n            check_all_ports();\n            compare_expected_actual();\n        end\n    endtask\n    \n    // Random stimulus\n    task generate_random_traffic();\n        repeat(1000) begin\n            randomize_frame();\n            send_random_frame();\n        end\n    endtask\nendclass\n```\n\nThese test scenarios and assertions provide comprehensive verification coverage of the switch functionality.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and describe their specific functions:\n\n1. MAC Address Extractor\n```systemverilog\nmodule mac_extractor (\n    // Extracts MAC addresses from incoming frames\n    input  logic clock, reset,\n    input  AxiStreamType in_axi,\n    output logic [47:0] dst_mac,\n    output logic [47:0] src_mac,\n    output logic mac_valid\n);\n```\nFunction: Extracts source and destination MAC addresses from frame headers\n\n2. MAC Table Manager\n```systemverilog\nmodule mac_table (\n    // Manages MAC address learning and aging\n    input  logic clock, reset,\n    input  logic [47:0] learn_mac,\n    input  logic [$clog2(NumPorts)-1:0] learn_port,\n    input  logic learn_valid,\n    input  logic [47:0] lookup_mac,\n    output logic [$clog2(NumPorts)-1:0] found_port,\n    output logic lookup_hit\n);\n```\nFunction: Maintains MAC address table, handles learning and aging\n\n3. Route Decision Logic\n```systemverilog\nmodule route_resolver (\n    // Determines output port(s) for frames\n    input  logic clock, reset,\n    input  logic [47:0] dst_mac,\n    input  logic [$clog2(NumPorts)-1:0] src_port,\n    input  logic lookup_hit,\n    input  logic [$clog2(NumPorts)-1:0] found_port,\n    output logic [NumPorts-1:0] output_mask\n);\n```\nFunction: Determines frame routing based on MAC addresses\n\n4. Input Port Controller (one per port)\n```systemverilog\nmodule input_controller (\n    // Manages input port operations\n    input  logic clock, reset,\n    input  AxiStreamType in_axi,\n    output logic tready,\n    output logic frame_valid,\n    output logic [AxiStreamWidth-1:0] frame_data,\n    output logic frame_last\n);\n```\nFunction: Handles input buffering and flow control\n\n5. Output Port Controller (one per port)\n```systemverilog\nmodule output_controller (\n    // Manages output port operations\n    input  logic clock, reset,\n    input  logic [NumPorts-1:0] input_requests,\n    input  logic outTready,\n    output AxiStreamType out_axi,\n    output logic grant_valid\n);\n```\nFunction: Handles output arbitration and transmission\n\n6. Frame Buffer\n```systemverilog\nmodule frame_buffer (\n    // Stores frames during processing\n    input  logic clock, reset,\n    input  AxiStreamType in_data,\n    input  logic write_en,\n    output AxiStreamType out_data,\n    output logic full,\n    output logic empty\n);\n```\nFunction: Provides frame storage and buffering\n\n7. Port Arbiter\n```systemverilog\nmodule port_arbiter (\n    // Arbitrates between multiple input requests\n    input  logic clock, reset,\n    input  logic [NumPorts-1:0] requests,\n    output logic [NumPorts-1:0] grants,\n    input  logic outTready\n);\n```\nFunction: Implements fair arbitration for output ports\n\nTop-level Integration:\n```systemverilog\nmodule dut (\n    // Top-level switch module\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // Instantiate submodules\n    mac_extractor mac_extract_inst[NumPorts-1:0] (...);\n    mac_table mac_table_inst (...);\n    route_resolver route_resolve_inst (...);\n    input_controller in_ctrl_inst[NumPorts-1:0] (...);\n    output_controller out_ctrl_inst[NumPorts-1:0] (...);\n    frame_buffer frame_buff_inst[NumPorts-1:0] (...);\n    port_arbiter port_arb_inst[NumPorts-1:0] (...);\n\nendmodule\n```\n\nInteraction Flow:\n```\nInput Frame \u2192 MAC Extractor \u2192 MAC Table\n                           \u2193\n                    Route Resolver\n                           \u2193\nInput Controller \u2192 Frame Buffer \u2192 Output Controller\n                                       \u2191\n                                 Port Arbiter\n```\n\nKey Responsibilities:\n\n1. MAC Address Extractor:\n- Frame header parsing\n- MAC address extraction\n- Validation checks\n\n2. MAC Table Manager:\n- Address learning\n- Table lookups\n- Entry aging\n- Table maintenance\n\n3. Route Decision Logic:\n- Broadcast/multicast detection\n- Route determination\n- Loopback prevention\n\n4. Input Port Controller:\n- Flow control\n- Input buffering\n- Frame validation\n\n5. Output Port Controller:\n- Transmission scheduling\n- Output flow control\n- Frame transmission\n\n6. Frame Buffer:\n- Frame storage\n- Overflow protection\n- Underflow prevention\n\n7. Port Arbiter:\n- Fair arbitration\n- Grant generation\n- Conflict resolution\n\nThis modular approach provides:\n- Clear separation of concerns\n- Simplified testing and verification\n- Easier maintenance and modifications\n- Reusable components\n- Better scalabilityWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nLet me write the SystemVerilog code for each submodule and highlight their critical interfaces:\n\n1. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType in_axi,\n    output logic [47:0] dst_mac,\n    output logic [47:0] src_mac,\n    output logic mac_valid,\n    output logic mac_ready\n);\n    // States for header extraction\n    typedef enum logic [1:0] {\n        IDLE,\n        EXTRACT,\n        FORWARD\n    } state_t;\n    \n    state_t state, next_state;\n    logic [2:0] byte_count;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= '0;\n            dst_mac <= '0;\n            src_mac <= '0;\n            mac_valid <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in_axi.tvalid) begin\n                        state <= EXTRACT;\n                        byte_count <= '0;\n                    end\n                end\n                \n                EXTRACT: begin\n                    if (in_axi.tvalid) begin\n                        if (byte_count < 6)\n                            dst_mac <= {dst_mac[39:0], in_axi.tdata[7:0]};\n                        else if (byte_count < 12)\n                            src_mac <= {src_mac[39:0], in_axi.tdata[7:0]};\n                            \n                        byte_count <= byte_count + 1;\n                        if (byte_count == 11) begin\n                            state <= FORWARD;\n                            mac_valid <= 1'b1;\n                        end\n                    end\n                end\n                \n                FORWARD: begin\n                    if (in_axi.tlast) begin\n                        state <= IDLE;\n                        mac_valid <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    assign mac_ready = (state != EXTRACT);\n\nendmodule\n```\n\n2. MAC Table Manager:\n```systemverilog\nmodule mac_table #(\n    parameter int MacTableDepth = 16\n) (\n    input  logic clock,\n    input  logic reset,\n    input  logic [47:0] learn_mac,\n    input  logic [$clog2(NumPorts)-1:0] learn_port,\n    input  logic learn_valid,\n    input  logic [47:0] lookup_mac,\n    output logic [$clog2(NumPorts)-1:0] found_port,\n    output logic lookup_hit\n);\n\n    typedef struct packed {\n        logic valid;\n        logic [47:0] mac_addr;\n        logic [$clog2(NumPorts)-1:0] port_id;\n        logic [31:0] age_counter;\n    } mac_entry_t;\n    \n    mac_entry_t [MacTableDepth-1:0] mac_table;\n    logic [$clog2(MacTableDepth)-1:0] free_index;\n    \n    // MAC lookup logic\n    always_comb begin\n        lookup_hit = 1'b0;\n        found_port = '0;\n        \n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (mac_table[i].valid && mac_table[i].mac_addr == lookup_mac) begin\n                lookup_hit = 1'b1;\n                found_port = mac_table[i].port_id;\n            end\n        end\n    end\n    \n    // MAC learning and aging logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_table <= '{default: '0};\n            free_index <= '0;\n        end else begin\n            // Learning\n            if (learn_valid) begin\n                // Check if MAC already exists\n                logic found = 0;\n                for (int i = 0; i < MacTableDepth; i++) begin\n                    if (mac_table[i].valid && mac_table[i].mac_addr == learn_mac) begin\n                        mac_table[i].port_id <= learn_port;\n                        mac_table[i].age_counter <= '0;\n                        found = 1;\n                    end\n                end\n                \n                // Add new entry if not found\n                if (!found) begin\n                    mac_table[free_index].valid <= 1'b1;\n                    mac_table[free_index].mac_addr <= learn_mac;\n                    mac_table[free_index].port_id <= learn_port;\n                    mac_table[free_index].age_counter <= '0;\n                    free_index <= free_index + 1;\n                end\n            end\n            \n            // Aging\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                        mac_table[i].valid <= 1'b0;\n                    else\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                end\n            end\n        end\n    end\n\nendmodule\n```\n\n3. Route Decision Logic:\n```systemverilog\nmodule route_resolver (\n    input  logic clock,\n    input  logic reset,\n    input  logic [47:0] dst_mac,\n    input  logic [$clog2(NumPorts)-1:0] src_port,\n    input  logic lookup_hit,\n    input  logic [$clog2(NumPorts)-1:0] found_port,\n    output logic [NumPorts-1:0] output_mask\n);\n\n    logic is_broadcast, is_multicast;\n    \n    assign is_broadcast = &dst_mac;\n    assign is_multicast = dst_mac[40];\n    \n    always_comb begin\n        output_mask = '0;\n        \n        if (is_broadcast || is_multicast) begin\n            // Send to all ports except source\n            output_mask = ~(1 << src_port);\n        end else if (lookup_hit) begin\n            // Send to specific port\n            output_mask = (1 << found_port) & ~(1 << src_port);\n        end else begin\n            // Unknown destination - flood\n            output_mask = ~(1 << src_port);\n        end\n    end\n\nendmodule\n```\n\n4. Input Port Controller:\n```systemverilog\nmodule input_controller (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType in_axi,\n    output logic tready,\n    output logic frame_valid,\n    output logic [AxiStreamWidth-1:0] frame_data,\n    output logic frame_last\n);\n\n    typedef enum logic [1:0] {\n        IDLE,\n        RECEIVE,\n        WAIT_END\n    } state_t;\n    \n    state_t state;\n    logic fifo_full;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            state <= IDLE;\n            frame_valid <= 1'b0;\n            tready <= 1'b1;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in_axi.tvalid && !fifo_full) begin\n                        state <= RECEIVE;\n                        frame_valid <= 1'b1;\n                        frame_data <= in_axi.tdata;\n                        frame_last <= in_axi.tlast;\n                    end\n                end\n                \n                RECEIVE: begin\n                    if (in_axi.tvalid && !fifo_full) begin\n                        frame_data <= in_axi.tdata;\n                        frame_last <= in_axi.tlast;\n                        if (in_axi.tlast)\n                            state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    assign tready = !fifo_full && (state != WAIT_END);\n\nendmodule\n```\n\nCritical Interfaces between modules:\n\n1. MAC Extractor \u2192 MAC Table:\n- MAC addresses for learning/lookup\n- Validation signals\n\n2. MAC Table \u2192 Route Resolver:\n- Lookup results\n- Port mapping information\n\n3. Route Resolver \u2192 Output Controller:\n- Port mask for frame forwarding\n- Frame routing decisions\n\n4. Input Controller \u2192 Frame Buffer:\n- Frame data and control signals\n- Flow control signals\n\n5. Frame Buffer \u2192 Output Controller:\n- Buffered frame data\n- Buffer status signals\n\nThese interfaces need careful handling of:\n- Timing synchronization\n- Flow control\n- Data validity\n- Error conditions\n- Handshaking protocols\n\nWould you like me to continue with the remaining submodules or provide more detail on any particular aspect?\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/test_l2_switch_lite_5/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule custom_tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n",
    "name": "test_l2_switch_lite_5"
  }
]