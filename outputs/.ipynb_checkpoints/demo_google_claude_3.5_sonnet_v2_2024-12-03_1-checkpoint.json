[
  {
    "index": 3,
    "dut": "module rate_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        i_rate_by_frame,\n    input  logic        transfer_valid,\n    input  logic        frame_end,\n    output logic        throttle_active\n);\n    logic [7:0] credit_counter;\n    logic       rate_exceeded;\n\n    assign rate_exceeded = (credit_counter >= i_rate_denominator);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            credit_counter <= '0;\n            throttle_active <= 1'b0;\n        end else begin\n            if (transfer_valid) begin\n                credit_counter <= credit_counter + i_rate_numerator;\n            end\n\n            if (i_rate_by_frame) begin\n                if (frame_end) begin\n                    throttle_active <= rate_exceeded;\n                    if (rate_exceeded) credit_counter <= '0;\n                end\n            end else begin\n                throttle_active <= rate_exceeded;\n                if (rate_exceeded) credit_counter <= '0;\n            end\n        end\n    end\nendmodule\n\nmodule frame_tracker (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic tlast,\n    output logic in_frame,\n    output logic frame_complete\n);\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_frame <= 1'b0;\n            frame_complete <= 1'b0;\n        end else begin\n            frame_complete <= tvalid && tlast;\n            \n            if (tvalid && tlast) begin\n                in_frame <= 1'b0;\n            end else if (tvalid && !in_frame) begin\n                in_frame <= 1'b1;\n            end\n        end\n    end\nendmodule\n\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic                      clock,\n    input  logic                      reset,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    input  logic                      valid,\n    input  logic                      advance\n);\n    logic [ExtraDataWidth-1:0] extra_buffer;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            extra_buffer <= '0;\n            outExtra <= '0;\n        end else if (valid && advance) begin\n            extra_buffer <= inExtra;\n            outExtra <= inExtra;\n        end\n    end\nendmodule\n\nmodule flow_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        throttle_active,\n    input  logic        outTready,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St\n);\n    always_comb begin\n        inTready = !throttle_active && outTready;\n        outAxi4St = inAxi4St;\n        outAxi4St.tvalid = !throttle_active && inAxi4St.tvalid;\n    end\nendmodule\n\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    input  logic                          clock,\n    input  logic                          reset,\n    input  AxiStreamType                  inAxi4St,\n    output logic                          inTready,\n    output AxiStreamType                  outAxi4St,\n    input  logic                          outTready,\n    input  logic [ExtraDataWidth-1:0]     inExtra,\n    output logic [ExtraDataWidth-1:0]     outExtra,\n    input  logic [7:0]                    i_rate_numerator,\n    input  logic [7:0]                    i_rate_denominator,\n    input  logic                          i_rate_by_frame\n);\n\n    logic throttle_active;\n    logic frame_end;\n    logic in_frame;\n    \n    // Pipeline stage for AXI Stream data\n    AxiStreamType pipe_axi4st;\n    logic pipe_tready;\n    \n    local_axist_pipe #(\n        .NumStages(1),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(pipe_tready),\n        .pipeAxi4St(),  // Not used\n        .pipeTready(),  // Not used \n        .outAxi4St(pipe_axi4st),\n        .outTready(outTready)\n    );\n\n    rate_controller u_rate_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .i_rate_numerator(i_rate_numerator),\n        .i_rate_denominator(i_rate_denominator),\n        .i_rate_by_frame(i_rate_by_frame),\n        .transfer_valid(pipe_axi4st.tvalid && outTready),\n        .frame_end(frame_end),\n        .throttle_active(throttle_active)\n    );\n\n    frame_tracker u_frame_track (\n        .clock(clock),\n        .reset(reset),\n        .tvalid(pipe_axi4st.tvalid),\n        .tlast(pipe_axi4st.tlast),\n        .in_frame(in_frame),\n        .frame_complete(frame_end)\n    );\n\n    flow_controller u_flow_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .throttle_active(throttle_active),\n        .outTready(outTready),\n        .inAxi4St(pipe_axi4st),\n        .inTready(inTready),\n        .outAxi4St(outAxi4St)\n    );\n\n    extra_data_handler #(\n        .ExtraDataWidth(ExtraDataWidth)\n    ) u_extra_handler (\n        .clock(clock),\n        .reset(reset),\n        .inExtra(inExtra),\n        .outExtra(outExtra),\n        .valid(pipe_axi4st.tvalid),\n        .advance(pipe_tready && outTready)\n    );\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nThe main functionality of this module is to implement rate limiting on an AXI4-Stream interface. It acts as a traffic shaper that controls the data flow rate between an input AXI4-Stream and an output AXI4-Stream interface.\n\nKey features:\n1. Rate limiting is configured using numerator/denominator ratio (i_rate_numerator/i_rate_denominator)\n2. Two modes of operation based on i_rate_by_frame:\n   - Per-phit mode (i_rate_by_frame=0): Can throttle data at any point\n   - Frame mode (i_rate_by_frame=1): Only throttles between complete frames/packets\n\nHigh-level block diagram:\n\n```\n                     Rate Control Logic\n                            |\n                            v\ninAxi4St -----> [Buffer/Pipeline] -----> outAxi4St\ninExtra  ------>     Stage      -----> outExtra\n                         ^\n                         |\n               Rate Parameters:\n               - i_rate_numerator\n               - i_rate_denominator\n               - i_rate_by_frame\n```\n\nThe module consists of:\n1. Input stage handling AXI4-Stream input and inExtra data\n2. Rate control logic that:\n   - Tracks data transfer rates\n   - Makes throttling decisions based on configured parameters\n   - Controls inTready and outAxi4St.tvalid signals\n3. Pipeline/buffer stage (using local_axist_pipe) for data storage\n4. Output stage delivering rate-limited data\n\nThe module maintains AXI4-Stream protocol compliance while implementing the rate limiting functionality, using ready/valid handshaking for flow control.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, the following aspects should be parameterizable:\n\n1. AxiStreamType (Required)\n- Default = local_pkg::axi4st_8_s\n- Defines the structure of the AXI4-Stream interface\n- Contains {tdata, tkeep, tuser, tlast, tvalid}\n\n2. AxiStreamWidth (Required)\n- Default = 8\n- Specifies the width of tdata field\n- Must be included but not necessarily used in implementation\n\n3. ExtraDataWidth (Required)\n- Default = 1\n- Defines the width of additional data (inExtra/outExtra) that flows alongside the main AXI stream\n\nReasonable additional parameters that could be helpful (though not specified in requirements):\n\n4. Pipeline Depth for local_axist_pipe\n- Suggested default = 1\n- Controls buffering depth\n\n5. Rate Limit Parameters\n- While these are specified as inputs (i_rate_numerator, i_rate_denominator), they could be parameterized with defaults:\n  * Default numerator = 1\n  * Default denominator = 1 (representing no rate limiting)\n\nImportant parameter constraints:\n- AxiStreamWidth must be > 0\n- ExtraDataWidth must be \u2265 0\n- Pipeline depth must be > 0\n- All parameters should be static/constant during operation\n\nThe problem explicitly requires these parameters in the module declaration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n) ( ... );\n```\n\nThese parameters provide sufficient flexibility while maintaining reasonable defaults for basic operation.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nThe data processing and transformation requires several key components and logic stages:\n\nRequired Registers:\n1. Rate Tracking\n```systemverilog\nlogic [7:0] credit_counter;      // Tracks available bandwidth\nlogic [7:0] frame_byte_counter;  // Counts bytes in current frame (for frame mode)\nlogic       in_frame;            // Indicates if currently processing a frame\n```\n\n2. Data Pipeline (using local_axist_pipe)\n```systemverilog\nAxiStreamType pipe_data;         // Buffered AXI stream data\nlogic [ExtraDataWidth-1:0] pipe_extra; // Buffered extra data\n```\n\n3. Control States\n```systemverilog\nlogic throttle_active;           // Indicates if rate limiting is active\nlogic frame_complete;            // Indicates end of frame detected\n```\n\nRequired Combinational Logic:\n1. Rate Calculation\n```systemverilog\n// Determine if transfer should be throttled\nwire rate_exceeded = (credit_counter >= i_rate_denominator);\n\n// Calculate next credit value\nwire [7:0] next_credit = credit_counter + i_rate_numerator;\n```\n\n2. Transfer Control\n```systemverilog\n// Ready/Valid control\nassign inTready = !throttle_active && outTready;\nassign outAxi4St.tvalid = !throttle_active && inAxi4St.tvalid;\n\n// Data path\nassign outAxi4St.tdata = pipe_data.tdata;\nassign outAxi4St.tlast = pipe_data.tlast;\nassign outExtra = pipe_extra;\n```\n\nData Flow Process:\n1. Input Stage:\n   - Check rate limit conditions\n   - Control inTready based on rate limiting\n   - Capture input data when valid\n\n2. Pipeline Stage:\n   - Buffer data using local_axist_pipe\n   - Maintain data alignment with extra signals\n\n3. Output Stage:\n   - Apply rate limiting by controlling tvalid\n   - Forward data when allowed\n\n4. Rate Control Logic:\n   - For i_rate_by_frame = 0:\n     * Update credit counter every transfer\n     * Throttle immediately when rate exceeded\n   - For i_rate_by_frame = 1:\n     * Track frame boundaries\n     * Only apply throttling between frames\n     * Accumulate frame statistics for rate calculation\n\nThis implementation ensures proper data handling while maintaining rate limiting requirements and AXI4-Stream protocol compliance.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nFrom the problem description, here are the key timing and reset considerations:\n\nClocking:\n1. Single clock domain design (clock input)\n2. All operations are synchronous to the clock\n\nReset Requirements:\n1. Synchronous reset (explicitly stated in requirements)\n2. Signals that need to be reset:\n   ```systemverilog\n   // Control registers\n   logic [7:0] credit_counter;\n   logic [7:0] frame_byte_counter;\n   logic       in_frame;\n   logic       throttle_active;\n   \n   // Pipeline control signals\n   logic       pipe_valid;\n   ```\n\nLatency:\n1. Minimum latency of 1 clock cycle due to the required use of local_axist_pipe\n2. Additional latency when rate limiting is active:\n   - For per-phit mode: Variable latency based on rate parameters\n   - For frame mode: Frame-boundary aligned latency\n\nThroughput:\n1. Maximum throughput: One transfer per clock when not rate-limited\n2. Effective throughput = (i_rate_numerator/i_rate_denominator) * maximum throughput\n3. For frame mode, full frame throughput when active, zero when throttled\n\nTiming Considerations:\n1. Ready/Valid handshaking must follow AXI4-Stream timing:\n   - tvalid must not depend on tready\n   - Data must be stable when tvalid is high\n   - tready can change anytime\n\n2. Critical paths:\n   - Rate calculation logic\n   - Frame boundary detection\n   - Credit counter updates\n\nSample reset logic:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        credit_counter <= '0;\n        frame_byte_counter <= '0;\n        in_frame <= 1'b0;\n        throttle_active <= 1'b0;\n        pipe_valid <= 1'b0;\n    end else begin\n        // Normal operation logic\n    end\nend\n```\n\nThe design should prioritize:\n1. Maintaining AXI4-Stream protocol timing\n2. Clean synchronous reset behavior\n3. Predictable latency through the pipeline\n4. Meeting throughput requirements based on rate parameters\n\nNo specific maximum frequency requirements are mentioned, but design should follow standard synchronous design practices.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nKey test scenarios and assertions needed for this rate limiting module:\n\nTest Scenarios:\n1. Basic Functionality:\n```systemverilog\n// Test different rate configurations\n- No rate limiting (num/denom = 1/1)\n- Half rate (num/denom = 1/2)\n- Zero rate (num/denom = 0/x)\n- Maximum rate (num=denom)\n```\n\n2. Frame Mode Testing:\n```systemverilog\n// Test frame-based rate limiting\n- Single-phit frames\n- Multi-phit frames\n- Back-to-back frames\n- Frames with gaps\n- Frame boundary detection\n```\n\n3. Protocol Compliance:\n```systemverilog\n// Test AXI4-Stream handshaking\n- Backpressure scenarios (varying outTready)\n- Valid/Ready interactions\n- TLAST signal behavior\n```\n\n4. Edge Cases:\n```systemverilog\n- Reset during active transfer\n- Rate parameter changes during operation\n- Maximum frame size handling\n- Minimum frame size handling\n```\n\nAssertions:\n1. Protocol Checks:\n```systemverilog\n// AXI4-Stream protocol rules\nassert property (@(posedge clock) disable iff (reset)\n    outAxi4St.tvalid |-> $stable(outAxi4St.tdata));\n\n// Valid/Ready handshaking\nassert property (@(posedge clock)\n    outAxi4St.tvalid && !outTready |-> ##1 outAxi4St.tvalid);\n```\n\n2. Rate Limiting Checks:\n```systemverilog\n// Rate compliance\nassert property (@(posedge clock) disable iff (reset)\n    credit_counter <= i_rate_denominator);\n\n// Frame mode behavior\nassert property (@(posedge clock) disable iff (reset)\n    i_rate_by_frame && in_frame |-> !throttle_active);\n```\n\n3. Data Integrity:\n```systemverilog\n// Extra data alignment\nassert property (@(posedge clock)\n    outAxi4St.tvalid |-> $stable(outExtra));\n\n// TLAST propagation\nassert property (@(posedge clock)\n    outAxi4St.tvalid && outAxi4St.tlast |-> frame_complete);\n```\n\n4. Reset Behavior:\n```systemverilog\n// Reset state verification\nassert property (@(posedge clock)\n    reset |=> !outAxi4St.tvalid && !in_frame);\n```\n\n5. Parameter Checks:\n```systemverilog\n// Static parameter validation\ninitial begin\n    assert (ExtraDataWidth > 0);\n    assert (AxiStreamWidth == 8);\nend\n```\n\nCoverage Points:\n1. Rate Parameters:\n```systemverilog\ncovergroup rate_cg;\n    cp_numerator: coverpoint i_rate_numerator;\n    cp_denominator: coverpoint i_rate_denominator;\n    cross_rate: cross cp_numerator, cp_denominator;\nendgroup\n```\n\n2. Frame Statistics:\n```systemverilog\ncovergroup frame_cg;\n    cp_frame_size: coverpoint frame_byte_counter;\n    cp_throttle: coverpoint throttle_active;\nendgroup\n```\n\nThese tests and assertions ensure:\n1. Correct rate limiting functionality\n2. Protocol compliance\n3. Data integrity\n4. Proper reset behavior\n5. Parameter validation\n6. Coverage of important scenariosWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nThis design can be logically divided into several functional blocks/submodules:\n\n1. Rate Control Unit\n```systemverilog\nmodule rate_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        i_rate_by_frame,\n    input  logic        transfer_valid,\n    input  logic        frame_end,\n    output logic        throttle_active\n);\n```\nTask: Manages rate limiting calculations and decisions\n- Tracks credit counter\n- Implements rate limiting algorithm\n- Generates throttle signals\n- Handles frame vs. phit-based mode selection\n\n2. Data Pipeline (using local_axist_pipe)\n```systemverilog\n// Instance of provided module\nlocal_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n) data_pipe ( ... );\n```\nTask: Handles data buffering and flow\n- Buffers AXI4-Stream data\n- Maintains data alignment\n- Provides pipeline stages\n\n3. Extra Data Handler\n```systemverilog\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    input  logic                      valid,\n    input  logic                      advance\n);\n```\nTask: Manages extra data path\n- Aligns extra data with main data path\n- Handles buffering of extra data\n- Maintains synchronization\n\n4. Frame Tracker\n```systemverilog\nmodule frame_tracker (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic tlast,\n    output logic in_frame,\n    output logic frame_complete\n);\n```\nTask: Tracks frame boundaries\n- Detects start/end of frames\n- Maintains frame state\n- Generates frame-related control signals\n\n5. Flow Control Manager\n```systemverilog\nmodule flow_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        throttle_active,\n    input  logic        outTready,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St\n);\n```\nTask: Manages AXI4-Stream handshaking\n- Generates ready/valid signals\n- Implements flow control logic\n- Ensures protocol compliance\n\nTop-level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    // ... ports ...\n);\n    // Instantiate and connect submodules\n    rate_controller rate_ctrl_inst ( ... );\n    local_axist_pipe data_pipe_inst ( ... );\n    extra_data_handler extra_handler_inst ( ... );\n    frame_tracker frame_track_inst ( ... );\n    flow_controller flow_ctrl_inst ( ... );\nendmodule\n```\n\nThis modular approach provides several benefits:\n1. Clear separation of concerns\n2. Easier testing and verification\n3. Better maintainability\n4. Simplified debugging\n5. Potential for reuse of components\n6. Clearer documentation and understanding\n\nEach submodule has a specific responsibility and clear interfaces, making the overall design more manageable and robust.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide SystemVerilog code for each submodule and identify the critical interfaces:\n\n1. Rate Controller:\n```systemverilog\nmodule rate_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        i_rate_by_frame,\n    input  logic        transfer_valid,\n    input  logic        frame_end,\n    output logic        throttle_active\n);\n\n    logic [7:0] credit_counter;\n    logic       rate_exceeded;\n\n    assign rate_exceeded = (credit_counter >= i_rate_denominator);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            credit_counter <= '0;\n            throttle_active <= 1'b0;\n        end else begin\n            if (transfer_valid) begin\n                credit_counter <= credit_counter + i_rate_numerator;\n            end\n\n            if (i_rate_by_frame) begin\n                if (frame_end) begin\n                    throttle_active <= rate_exceeded;\n                    if (rate_exceeded) credit_counter <= '0;\n                end\n            end else begin\n                throttle_active <= rate_exceeded;\n                if (rate_exceeded) credit_counter <= '0;\n            end\n        end\n    end\nendmodule\n```\n\n2. Frame Tracker:\n```systemverilog\nmodule frame_tracker (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic tlast,\n    output logic in_frame,\n    output logic frame_complete\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_frame <= 1'b0;\n            frame_complete <= 1'b0;\n        end else begin\n            frame_complete <= tvalid && tlast;\n            \n            if (tvalid && tlast) begin\n                in_frame <= 1'b0;\n            end else if (tvalid && !in_frame) begin\n                in_frame <= 1'b1;\n            end\n        end\n    end\nendmodule\n```\n\n3. Extra Data Handler:\n```systemverilog\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic                      clock,\n    input  logic                      reset,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    input  logic                      valid,\n    input  logic                      advance\n);\n\n    logic [ExtraDataWidth-1:0] extra_buffer;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            extra_buffer <= '0;\n            outExtra <= '0;\n        end else if (valid && advance) begin\n            extra_buffer <= inExtra;\n            outExtra <= inExtra;\n        end\n    end\nendmodule\n```\n\n4. Flow Controller:\n```systemverilog\nmodule flow_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        throttle_active,\n    input  logic        outTready,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St\n);\n\n    always_comb begin\n        // Ready/Valid control\n        inTready = !throttle_active && outTready;\n        outAxi4St = inAxi4St;\n        outAxi4St.tvalid = !throttle_active && inAxi4St.tvalid;\n    end\n    \nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Rate Controller and Flow Controller:\n```systemverilog\n// Throttle signal controls data flow\nthrottle_active\n```\n\n2. Between Frame Tracker and Rate Controller:\n```systemverilog\n// Frame state information for rate limiting\nframe_end\nin_frame\n```\n\n3. Between Flow Controller and Data Pipeline:\n```systemverilog\n// AXI4-Stream signals\ninAxi4St\noutAxi4St\ninTready\noutTready\n```\n\n4. Between Extra Data Handler and Main Data Path:\n```systemverilog\n// Extra data synchronization\nvalid\nadvance\ninExtra\noutExtra\n```\n\nTop-level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    input  logic                          clock,\n    input  logic                          reset,\n    input  AxiStreamType                  inAxi4St,\n    output logic                          inTready,\n    output AxiStreamType                  outAxi4St,\n    input  logic                          outTready,\n    input  logic [ExtraDataWidth-1:0]     inExtra,\n    output logic [ExtraDataWidth-1:0]     outExtra,\n    input  logic [7:0]                    i_rate_numerator,\n    input  logic [7:0]                    i_rate_denominator,\n    input  logic                          i_rate_by_frame\n);\n\n    logic throttle_active;\n    logic frame_end;\n    logic in_frame;\n    \n    rate_controller rate_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .i_rate_numerator(i_rate_numerator),\n        .i_rate_denominator(i_rate_denominator),\n        .i_rate_by_frame(i_rate_by_frame),\n        .transfer_valid(inAxi4St.tvalid && inTready),\n        .frame_end(frame_end),\n        .throttle_active(throttle_active)\n    );\n\n    frame_tracker frame_track (\n        .clock(clock),\n        .reset(reset),\n        .tvalid(inAxi4St.tvalid),\n        .tlast(inAxi4St.tlast),\n        .in_frame(in_frame),\n        .frame_complete(frame_end)\n    );\n\n    flow_controller flow_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .throttle_active(throttle_active),\n        .outTready(outTready),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .outAxi4St(outAxi4St)\n    );\n\n    extra_data_handler #(\n        .ExtraDataWidth(ExtraDataWidth)\n    ) extra_handler (\n        .clock(clock),\n        .reset(reset),\n        .inExtra(inExtra),\n        .outExtra(outExtra),\n        .valid(inAxi4St.tvalid),\n        .advance(inTready && outTready)\n    );\n\nendmodule\n```\n\nThese submodules work together to implement the rate limiting functionality while maintaining proper AXI4-Stream protocol compliance and handling extra data synchronization.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_3"
  },
  {
    "index": 1,
    "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int unsigned AxiStreamWidth = 128,\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n// Internal signals for MAC table management\nlogic [MacTableDepth-1:0][47:0] mac_addresses;\nlogic [MacTableDepth-1:0][3:0] port_numbers;\nlogic [MacTableDepth-1:0] valid_entries;\nlogic [MacTableDepth-1:0][31:0] age_counters;\n\n// Per-port frame processing signals\nlogic [NumPorts-1:0][47:0] src_macs;\nlogic [NumPorts-1:0][47:0] dst_macs;\nlogic [NumPorts-1:0] frame_valids;\nlogic [NumPorts-1:0] frame_starts;\nlogic [NumPorts-1:0] frame_lasts;\nlogic [NumPorts-1:0][NumPorts-1:0] dest_port_maps;\n\n// Generate input frame processors\ngenvar i;\ngenerate\n    for (i = 0; i < NumPorts; i++) begin : gen_input_processors\n        input_frame_processor #(\n            .AxiStreamType(AxiStreamType)\n        ) input_proc (\n            .clock(clock),\n            .reset(reset),\n            .inAxi4St(inAxi4St[i]),\n            .inTready(inTready[i]),\n            .src_mac(src_macs[i]),\n            .dst_mac(dst_macs[i]),\n            .frame_valid(frame_valids[i]),\n            .frame_start(frame_starts[i]),\n            .frame_last(frame_lasts[i])\n        );\n    end\nendgenerate\n\n// MAC Table Management\nmac_table_manager #(\n    .MacTableDepth(MacTableDepth)\n) mac_table (\n    .clock(clock),\n    .reset(reset),\n    .mac_addresses(mac_addresses),\n    .port_numbers(port_numbers),\n    .valid_entries(valid_entries),\n    .age_counters(age_counters),\n    .src_macs(src_macs),\n    .dst_macs(dst_macs),\n    .frame_valids(frame_valids),\n    .dest_port_maps(dest_port_maps)\n);\n\n// Output Frame Control\ngenvar j;\ngenerate\n    for (j = 0; j < NumPorts; j++) begin : gen_output_controllers\n        output_frame_controller #(\n            .AxiStreamType(AxiStreamType)\n        ) output_ctrl (\n            .clock(clock),\n            .reset(reset),\n            .inAxi4St(inAxi4St),\n            .dest_ports(dest_port_maps[j]),\n            .outAxi4St(outAxi4St[j]),\n            .outTready(outTready[j])\n        );\n    end\nendgenerate\n\n// Drive drop events to 0 as specified\nassign egressFifoDropEvents = '0;\n\n// Input Frame Processor Module\nmodule input_frame_processor #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    output logic inTready,\n    output logic [47:0] src_mac,\n    output logic [47:0] dst_mac,\n    output logic frame_valid,\n    output logic frame_start,\n    output logic frame_last\n);\n    typedef enum logic [1:0] {\n        IDLE,\n        HEADER,\n        PAYLOAD\n    } state_t;\n\n    state_t state, next_state;\n    logic [15:0] byte_count;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= '0;\n            src_mac <= '0;\n            dst_mac <= '0;\n            frame_valid <= '0;\n            frame_start <= '0;\n            frame_last <= '0;\n            inTready <= '0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    inTready <= 1'b1;\n                    if (inAxi4St.tvalid && inTready) begin\n                        dst_mac <= inAxi4St.tdata[47:0];\n                        frame_start <= 1'b1;\n                        state <= HEADER;\n                    end\n                end\n                \n                HEADER: begin\n                    if (inAxi4St.tvalid && inTready) begin\n                        src_mac <= inAxi4St.tdata[47:0];\n                        frame_valid <= 1'b1;\n                        state <= PAYLOAD;\n                    end\n                end\n                \n                PAYLOAD: begin\n                    if (inAxi4St.tvalid && inTready && inAxi4St.tlast) begin\n                        frame_last <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n\n// MAC Table Manager Module\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16\n)(\n    input  logic clock,\n    input  logic reset,\n    output logic [MacTableDepth-1:0][47:0] mac_addresses,\n    output logic [MacTableDepth-1:0][3:0] port_numbers,\n    output logic [MacTableDepth-1:0] valid_entries,\n    output logic [MacTableDepth-1:0][31:0] age_counters,\n    input  logic [NumPorts-1:0][47:0] src_macs,\n    input  logic [NumPorts-1:0][47:0] dst_macs,\n    input  logic [NumPorts-1:0] frame_valids,\n    output logic [NumPorts-1:0][NumPorts-1:0] dest_port_maps\n);\n    logic [47:0] broadcast_addr = 48'hFFFFFFFFFFFF;\n    logic [47:0] multicast_mask = 48'h010000000000;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_addresses <= '{default: '0};\n            port_numbers <= '{default: '0};\n            valid_entries <= '0;\n            age_counters <= '{default: '0};\n            dest_port_maps <= '{default: '0};\n        end else begin\n            // Age counter management\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (valid_entries[i]) begin\n                    if (age_counters[i] >= MacTableCyclesPerEpoch)\n                        valid_entries[i] <= 1'b0;\n                    else\n                        age_counters[i] <= age_counters[i] + 1;\n                end\n            end\n            \n            // Process incoming frames\n            for (int port = 0; port < NumPorts; port++) begin\n                if (frame_valids[port]) begin\n                    // Learning phase\n                    learn_mac_address(src_macs[port], port);\n                    \n                    // Forwarding phase\n                    if (dst_macs[port] == broadcast_addr || \n                        (dst_macs[port] & multicast_mask)) begin\n                        dest_port_maps[port] <= ~(1 << port);\n                    end else begin\n                        dest_port_maps[port] <= get_dest_ports(dst_macs[port], port);\n                    end\n                end\n            end\n        end\n    end\n\n    // Helper function to learn MAC addresses\n    function void learn_mac_address(logic [47:0] mac, logic [3:0] port);\n        logic found = 0;\n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (valid_entries[i] && mac_addresses[i] == mac) begin\n                port_numbers[i] <= port;\n                age_counters[i] <= '0;\n                found = 1;\n                break;\n            end\n        end\n        \n        if (!found) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (!valid_entries[i]) begin\n                    mac_addresses[i] <= mac;\n                    port_numbers[i] <= port;\n                    valid_entries[i] <= 1'b1;\n                    age_counters[i] <= '0;\n                    break;\n                end\n            end\n        end\n    endfunction\n\n    // Helper function to get destination ports\n    function logic [NumPorts-1:0] get_dest_ports(logic [47:0] mac, logic [3:0] src_port);\n        logic [NumPorts-1:0] result = '0;\n        logic found = 0;\n        \n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (valid_entries[i] && mac_addresses[i] == mac) begin\n                result = (1 << port_numbers[i]);\n                found = 1;\n                break;\n            end\n        end\n        \n        if (!found) begin\n            result = ~(1 << src_port);\n        end\n        \n        return result;\n    endfunction\nendmodule\n\n// Output Frame Controller Module\nmodule output_frame_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    input  logic [NumPorts-1:0] dest_ports,\n    output AxiStreamType outAxi4St,\n    input  logic outTready\n);\n    typedef enum logic [1:0] {\n        IDLE,\n        TRANSMIT\n    } state_t;\n\n    state_t state;\n    logic [3:0] current_input_port;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            state <= IDLE;\n            outAxi4St <= '{default: '0};\n            current_input_port <= '0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    for (int i = 0; i < NumPorts; i++) begin\n                        if (dest_ports[i] && inAxi4St[i].tvalid) begin\n                            state <= TRANSMIT;\n                            current_input_port <= i;\n                            outAxi4St <= inAxi4St[i];\n                            break;\n                        end\n                    end\n                end\n                \n                TRANSMIT: begin\n                    if (outTready) begin\n                        outAxi4St <= inAxi4St[current_input_port];\n                        if (inAxi4St[current_input_port].tlast) begin\n                            state <= IDLE;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module implements a 4-port Layer-2 Ethernet Switch with the following key features:\n1. MAC Address Learning: Automatically learns source MAC addresses from incoming frames and maintains a 16-entry MAC address table\n2. Frame Forwarding: Routes incoming Ethernet frames based on destination MAC addresses\n3. Broadcast/Multicast Handling: Forwards such frames to all ports except the receiving port\n4. AXI4-Stream Interface: Uses AXI4-Stream protocol for data transfer\n5. Aging Mechanism: Invalidates MAC table entries that haven't been used for a specified time period\n\nHigh-Level Block Diagram would consist of:\n\n1. Input Processing Blocks (\u00d74):\n   - AXI4-Stream receiver interface\n   - Frame buffer/FIFO\n   - MAC address extraction logic\n\n2. MAC Address Table:\n   - 16-entry table storing MAC addresses and corresponding ports\n   - Aging counter for each entry\n   - Learning logic for new MAC addresses\n\n3. Forwarding Decision Logic:\n   - MAC address lookup\n   - Broadcast/Multicast detection\n   - Port selection logic\n\n4. Output Processing Blocks (\u00d74):\n   - Frame forwarding multiplexer\n   - AXI4-Stream transmitter interface\n   - Output FIFOs\n\n5. Control Logic:\n   - Clock domain logic\n   - Reset handling\n   - Backpressure management (ready/valid handshaking)\n\nThe data flow would be:\nInput Port \u2192 MAC Learning \u2192 Forwarding Decision \u2192 Output Port Selection \u2192 Output Port(s)\n\nThis creates a non-blocking switch architecture where multiple ports can simultaneously receive and transmit frames, subject to output port availability.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nAlready Specified Parameters:\n1. NumPorts\n   - Default: 4\n   - Purpose: Number of switch ports\n   - This is fixed in the specification\n\n2. AxiStreamType\n   - Default: local_pkg::axi4st_128_s\n   - Purpose: Defines the AXI4-Stream interface structure\n   - Width options could be 8, 16, 32, 64, 128, 256, 512 bits\n\n3. AxiStreamWidth\n   - Default: 128\n   - Purpose: Width of tdata field\n   - Should match AxiStreamType\n\n4. MacTableDepth\n   - Default: 16\n   - Purpose: Number of MAC table entries\n   - Specification fixes this at 16\n\n5. MacTableCyclesPerEpoch\n   - Default: 32'd1_750_000_000\n   - Purpose: Aging timeout for MAC table entries\n\nAdditional Parameters that could be useful:\n\n6. FIFO_DEPTH\n   - Suggested Default: 2048 (bytes)\n   - Purpose: Depth of input/output FIFOs\n   - Should accommodate max frame size (1504 bytes)\n\n7. MIN_FRAME_SIZE\n   - Default: 60 (bytes)\n   - Purpose: Minimum Ethernet frame size\n   - Fixed by specification\n\n8. MAX_FRAME_SIZE\n   - Default: 1504 (bytes)\n   - Purpose: Maximum Ethernet frame size\n   - Fixed by specification\n\n9. MAC_ADDR_WIDTH\n   - Default: 48 (bits)\n   - Purpose: Width of MAC address\n   - Standard Ethernet value\n\n10. BROADCAST_ADDR\n    - Default: 48'hFF_FF_FF_FF_FF_FF\n    - Purpose: Broadcast address constant\n\n11. MULTICAST_MASK\n    - Default: 48'h01_00_00_00_00_00\n    - Purpose: For detecting multicast addresses\n\nThese parameters allow for:\n- Scaling the switch size\n- Adjusting interface widths\n- Modifying buffer sizes\n- Tuning aging behavior\n- Maintaining flexibility for different implementations\n\nThe defaults are chosen based on:\n- Standard Ethernet specifications\n- Typical implementation requirements\n- Performance/resource trade-offs\n- Common industry practicesHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing flow and required registers/logic:\n\nData Processing Flow:\n1. Input Stage:\n```\nRegisters needed:\n- Input frame buffers (per port)\n- Frame state tracking registers\n- MAC address extraction registers\n- Input valid/ready state registers\n\nCombinational logic:\n- AXI4-Stream handshaking logic\n- MAC address extraction logic\n- Frame validation logic\n```\n\n2. MAC Table Management:\n```\nRegisters needed:\n- MAC address table entries [MacTableDepth]:\n  * MAC address (48 bits)\n  * Port number (log2(NumPorts) bits)\n  * Valid bit\n  * Age counter (sufficient bits for MacTableCyclesPerEpoch)\n  * Last access timestamp\n\nCombinational logic:\n- MAC address comparison logic\n- Table lookup logic\n- Aging logic\n- Learning logic for new addresses\n```\n\n3. Forwarding Decision:\n```\nRegisters needed:\n- Destination port selection register\n- Broadcast/multicast flags\n- Frame forwarding state\n\nCombinational logic:\n- MAC address matching logic\n- Broadcast/multicast detection\n- Port selection logic\n- Loopback prevention logic\n```\n\n4. Output Stage:\n```\nRegisters needed:\n- Output frame buffers (per port)\n- Output state machines\n- Transmission control registers\n\nCombinational logic:\n- Output multiplexing logic\n- AXI4-Stream output control logic\n- Backpressure handling logic\n```\n\nKey Transformations:\n1. Input Processing:\n   - AXI4-Stream to frame buffer conversion\n   - MAC address extraction from frame headers\n   - Frame validation\n\n2. Forwarding:\n   - MAC table lookup\n   - Port selection based on destination MAC\n   - Broadcast/multicast handling\n\n3. Output Processing:\n   - Frame buffer to AXI4-Stream conversion\n   - Multi-port transmission control\n   - Backpressure handling\n\nCritical State Machines:\n1. Input Frame State Machine:\n   - IDLE\n   - RECEIVE_HEADER\n   - RECEIVE_PAYLOAD\n   - STORE_FRAME\n\n2. MAC Table Management State Machine:\n   - LOOKUP\n   - UPDATE\n   - LEARN_NEW\n   - AGE_CHECK\n\n3. Output Frame State Machine:\n   - IDLE\n   - TRANSMIT_HEADER\n   - TRANSMIT_PAYLOAD\n   - WAIT_COMPLETION\n\nThe design requires careful consideration of:\n- Clock domain synchronization\n- Backpressure propagation\n- Buffer management\n- Concurrent port operations\n- Error handling\n- Timing closureWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description and typical Ethernet switch requirements, let's analyze these aspects:\n\nClocking Requirements:\n1. Single Clock Domain:\n- The specification mentions a single 'clock' input\n- All operations are synchronous to this clock\n- No clock domain crossing (CDC) required\n\nReset Requirements:\n1. Synchronous Reset:\n- Explicitly specified as synchronous reset\n- Should reset:\n  * MAC address table\n  * All state machines\n  * Input/output buffers\n  * Control registers\n  * Frame counters\n  * AXI4-Stream interface signals\n\nLatency Considerations:\n1. Input Processing:\n- MAC address extraction: 1-2 cycles\n- MAC table lookup: 1-2 cycles\n- Forwarding decision: 1 cycle\n- Typical total: 3-5 cycles from input to forwarding decision\n\n2. Output Processing:\n- Port selection: 1 cycle\n- Output scheduling: 1-2 cycles\n- Typical total: 2-3 cycles from decision to output\n\nThroughput Requirements:\n1. AXI4-Stream Interface:\n- Must support full line rate on all ports\n- With 128-bit tdata:\n  * Can transfer 16 bytes per cycle\n  * Minimum frame (60 bytes): 4 cycles\n  * Maximum frame (1504 bytes): 94 cycles\n\n2. MAC Table:\n- Must support concurrent:\n  * Source MAC learning\n  * Destination MAC lookup\n  * Aging checks\n\nTiming Constraints:\n1. Primary Constraints:\n- Setup time for all flip-flops\n- Hold time for all flip-flops\n- Clock-to-Q delay\n- Combinational logic delay\n\n2. Critical Paths:\n- MAC address comparison logic\n- Forwarding decision logic\n- Output port selection\n- Ready/valid handshaking\n\n3. Performance Targets:\n- Should support wire-speed switching\n- Minimal latency for critical paths\n- No dropped frames under normal operation\n\nReset Strategy:\n1. Initial Reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    // Reset all registers to known states\n    mac_table <= '{default: '0};\n    state_machines <= IDLE;\n    axi_signals <= '{default: '0};\n  end\nend\n```\n\n2. Recovery from Reset:\n- Graceful recovery without frame corruption\n- Clear all buffers and state machines\n- Initialize MAC table to empty\n- Set all AXI4-Stream signals to inactive\n\nSpecific Signals to Reset:\n1. Control Signals:\n- All state machine states\n- Valid/ready handshaking signals\n- Frame counters and flags\n\n2. Data Path:\n- Input/output buffers\n- MAC table valid bits\n- Port selection registers\n\n3. Status Signals:\n- Error flags\n- Drop counters\n- Status registers\n\nThis design requires careful attention to:\n- Meeting timing closure\n- Maintaining throughput\n- Managing latency\n- Ensuring proper reset sequencing\n- Preventing frame corruption\n- Supporting backpressureWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nHere's a comprehensive test and verification strategy:\n\nTest Scenarios:\n1. Basic Functionality:\n```systemverilog\n// Basic frame forwarding\n- Single frame transmission\n- Port-to-port routing\n- MAC address learning\n- Broadcast handling\n```\n\n2. MAC Table Operations:\n```systemverilog\n// MAC learning\n- New MAC address learning\n- MAC table update with existing address\n- MAC table full condition\n- MAC aging timeouts\n```\n\n3. Forwarding Rules:\n```systemverilog\n// Routing scenarios\n- Known destination MAC\n- Unknown destination MAC\n- Broadcast frames\n- Multicast frames\n- Loopback prevention\n```\n\n4. Performance Tests:\n```systemverilog\n- Maximum frame rate on all ports\n- Minimum frame size handling\n- Maximum frame size handling\n- Back-to-back frames\n- Multiple concurrent transmissions\n```\n\n5. Error Conditions:\n```systemverilog\n- Buffer overflow conditions\n- Backpressure handling\n- Invalid frame sizes\n- Corrupted frames\n- Reset during operation\n```\n\nKey Assertions:\n\n1. Protocol Checks:\n```systemverilog\n// AXI4-Stream Protocol\nproperty axi_valid_ready_p;\n  @(posedge clock) disable iff (reset)\n    inAxi4St[*].tvalid && !inTready |=> $stable(inAxi4St[*].tdata);\nendproperty\nassert property(axi_valid_ready_p);\n\n// Frame Size\nproperty frame_size_check_p;\n  @(posedge clock) disable iff (reset)\n    frame_end |-> (frame_size >= MIN_FRAME_SIZE && frame_size <= MAX_FRAME_SIZE);\nendproperty\n```\n\n2. Functional Checks:\n```systemverilog\n// No Loopback\nproperty no_loopback_p;\n  @(posedge clock) disable iff (reset)\n    (rx_port_valid) |-> (tx_port != rx_port);\nendproperty\n\n// MAC Table Consistency\nproperty mac_table_valid_p;\n  @(posedge clock) disable iff (reset)\n    mac_table_write |-> !mac_table_read;\nendproperty\n```\n\n3. Timing Checks:\n```systemverilog\n// Valid-Ready Handshake\nproperty valid_ready_handshake_p;\n  @(posedge clock) disable iff (reset)\n    inAxi4St[*].tvalid && !inTready |=> inAxi4St[*].tvalid;\nendproperty\n\n// Frame Completion\nproperty frame_completion_p;\n  @(posedge clock) disable iff (reset)\n    frame_start |-> eventually frame_end;\nendproperty\n```\n\n4. Resource Checks:\n```systemverilog\n// Buffer Overflow Prevention\nproperty buffer_overflow_p;\n  @(posedge clock) disable iff (reset)\n    buffer_almost_full |-> !write_enable;\nendproperty\n\n// MAC Table Overflow\nproperty mac_table_overflow_p;\n  @(posedge clock) disable iff (reset)\n    mac_table_write |-> (valid_entries < MacTableDepth);\nendproperty\n```\n\n5. Coverage Points:\n```systemverilog\n// State Coverage\ncoverpoint state_machine {\n    bins idle = {IDLE};\n    bins receiving = {RECEIVE};\n    bins forwarding = {FORWARD};\n}\n\n// MAC Table Coverage\ncoverpoint mac_table_ops {\n    bins learn = {LEARN_NEW};\n    bins update = {UPDATE_EXISTING};\n    bins lookup = {TABLE_LOOKUP};\n}\n```\n\nTest Environment Structure:\n1. Testbench Components:\n- Frame generator\n- Protocol checker\n- Scoreboard\n- Coverage collector\n- Error injector\n\n2. Verification Methodology:\n- UVM-based testbench\n- Constrained random testing\n- Directed tests for corner cases\n- Coverage-driven verification\n\n3. Performance Metrics:\n- Latency measurements\n- Throughput monitoring\n- Resource utilization\n- Timing closure verification\n\n4. Debug Features:\n- Wave dumping\n- Transaction logging\n- Error reporting\n- Performance counters\n\nThis comprehensive verification approach ensures:\n- Protocol compliance\n- Functional correctness\n- Performance requirements\n- Error handling\n- Corner case coverageWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nHere's a logical breakdown of the design into functional blocks/submodules:\n\n1. Input Frame Processor (per port):\n```systemverilog\nmodule input_frame_processor (\n    // Handles incoming AXI4-Stream frames\n    // Tasks:\n    - AXI4-Stream interface handling\n    - Frame buffering\n    - MAC address extraction\n    - Frame validation\n    - Backpressure management\n);\n```\n\n2. MAC Address Table Manager:\n```systemverilog\nmodule mac_table_manager (\n    // Manages MAC address table\n    // Tasks:\n    - MAC address learning from source addresses\n    - MAC address lookup for destinations\n    - Age counter management\n    - Table entry validation/invalidation\n    - Concurrent access arbitration\n);\n```\n\n3. Forwarding Decision Engine:\n```systemverilog\nmodule forwarding_decision (\n    // Determines frame routing\n    // Tasks:\n    - MAC address matching\n    - Broadcast/multicast detection\n    - Output port selection\n    - Loopback prevention\n    - Multiple destination handling\n);\n```\n\n4. Output Frame Controller (per port):\n```systemverilog\nmodule output_frame_controller (\n    // Manages frame transmission\n    // Tasks:\n    - Frame buffering\n    - AXI4-Stream output formatting\n    - Backpressure handling\n    - Frame scheduling\n    - Multiple source arbitration\n);\n```\n\n5. Switch Core Controller:\n```systemverilog\nmodule switch_core_controller (\n    // Central control unit\n    // Tasks:\n    - State machine coordination\n    - Reset handling\n    - Error management\n    - Status reporting\n    - Resource allocation\n);\n```\n\n6. Frame Buffer Manager:\n```systemverilog\nmodule frame_buffer_manager (\n    // Manages frame storage\n    // Tasks:\n    - Buffer allocation\n    - Memory management\n    - Buffer overflow prevention\n    - Frame queuing\n    - Buffer status tracking\n);\n```\n\n7. Port Arbiter:\n```systemverilog\nmodule port_arbiter (\n    // Handles port contention\n    // Tasks:\n    - Output port arbitration\n    - Priority handling\n    - Fairness enforcement\n    - Deadlock prevention\n    - Backpressure propagation\n);\n```\n\n8. Statistics and Monitoring:\n```systemverilog\nmodule statistics_monitor (\n    // Tracks switch performance\n    // Tasks:\n    - Frame counting\n    - Drop event tracking\n    - Port statistics\n    - MAC table usage monitoring\n    - Performance metrics\n);\n```\n\nInterconnections:\n\n1. Top-Level Integration:\n```systemverilog\nmodule dut (\n    // Instantiates and connects all submodules\n    // Main data flow:\n    Input Frame Processor \n    -> MAC Table Manager \n    -> Forwarding Decision \n    -> Port Arbiter \n    -> Output Frame Controller\n);\n```\n\n2. Control Flow:\n```systemverilog\n// Central control signals:\n- Clock distribution\n- Reset coordination\n- Status collection\n- Error handling\n- Configuration management\n```\n\n3. Data Flow:\n```systemverilog\n// Main data paths:\n- Frame data movement\n- MAC address distribution\n- Control signal propagation\n- Status reporting\n- Error notification\n```\n\nKey Interfaces Between Blocks:\n\n1. Input to MAC Table:\n```systemverilog\ninterface input_mac_if;\n    logic [47:0] src_mac;\n    logic [47:0] dst_mac;\n    logic        valid;\n    logic        ready;\nendinterface\n```\n\n2. MAC Table to Forwarding:\n```systemverilog\ninterface forwarding_if;\n    logic [NumPorts-1:0] dest_ports;\n    logic                valid;\n    logic                broadcast;\n    logic                found;\nendinterface\n```\n\n3. Forwarding to Output:\n```systemverilog\ninterface output_control_if;\n    logic [NumPorts-1:0] port_enable;\n    logic                frame_valid;\n    logic                ready;\nendinterface\n```\n\nBenefits of this modular approach:\n- Clear separation of concerns\n- Simplified testing\n- Easier maintenance\n- Parallel development\n- Reusable components\n- Scalable design\n- Better error isolation\n\nThis modular structure allows for:\n- Independent verification\n- Configurable implementations\n- Easy modifications\n- Performance optimization\n- Resource sharing\n- Debug accessibilityWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write SystemVerilog code for the key submodules. Let's start with the interfaces and first few critical submodules:\n\n1. First, common interfaces:\n```systemverilog\n// Common interfaces between submodules\ninterface mac_table_if;\n    logic [47:0] src_mac;\n    logic [47:0] dst_mac;\n    logic [3:0]  src_port;\n    logic        valid;\n    logic        ready;\n    logic        lookup_hit;\n    logic [3:0]  dest_port;\n    modport requester (\n        output src_mac, dst_mac, src_port, valid,\n        input  ready, lookup_hit, dest_port\n    );\n    modport responder (\n        input  src_mac, dst_mac, src_port, valid,\n        output ready, lookup_hit, dest_port\n    );\nendinterface\n\ninterface frame_ctrl_if;\n    logic [NumPorts-1:0] dest_ports;\n    logic                frame_valid;\n    logic                frame_last;\n    logic                ready;\n    modport sender (\n        output dest_ports, frame_valid, frame_last,\n        input  ready\n    );\n    modport receiver (\n        input  dest_ports, frame_valid, frame_last,\n        output ready\n    );\nendinterface\n```\n\n2. Input Frame Processor:\n```systemverilog\nmodule input_frame_processor #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n)(\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output logic [47:0] src_mac,\n    output logic [47:0] dst_mac,\n    output logic        frame_valid,\n    output logic        frame_start,\n    output logic        frame_last\n);\n    typedef enum logic [2:0] {\n        IDLE,\n        HEADER,\n        PAYLOAD,\n        COMPLETE\n    } state_t;\n    \n    state_t state, next_state;\n    logic [15:0] byte_count;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= '0;\n            src_mac <= '0;\n            dst_mac <= '0;\n            frame_valid <= '0;\n            frame_start <= '0;\n            frame_last <= '0;\n            inTready <= '0;\n        end else begin\n            state <= next_state;\n            \n            case (state)\n                IDLE: begin\n                    inTready <= 1'b1;\n                    if (inAxi4St.tvalid && inTready) begin\n                        dst_mac <= inAxi4St.tdata[47:0];\n                        frame_start <= 1'b1;\n                        byte_count <= 16'd6;\n                    end\n                end\n                \n                HEADER: begin\n                    frame_start <= 1'b0;\n                    if (inAxi4St.tvalid && inTready) begin\n                        src_mac <= inAxi4St.tdata[47:0];\n                        frame_valid <= 1'b1;\n                        byte_count <= byte_count + 16'd6;\n                    end\n                end\n                \n                // Additional states and logic...\n            endcase\n        end\n    end\n    \n    // State machine next state logic\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: \n                if (inAxi4St.tvalid && inTready) next_state = HEADER;\n            HEADER:\n                if (inAxi4St.tvalid && inTready) next_state = PAYLOAD;\n            // Additional state transitions...\n        endcase\n    end\nendmodule\n```\n\n3. MAC Table Manager:\n```systemverilog\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16\n)(\n    input  logic        clock,\n    input  logic        reset,\n    mac_table_if.responder mac_if,\n    \n    // MAC table storage\n    logic [MacTableDepth-1:0][47:0] mac_addresses,\n    logic [MacTableDepth-1:0][3:0]  port_numbers,\n    logic [MacTableDepth-1:0]       valid_entries,\n    logic [MacTableDepth-1:0][31:0] age_counters\n);\n\n    typedef enum logic [2:0] {\n        IDLE,\n        LOOKUP,\n        LEARN,\n        UPDATE,\n        AGE\n    } state_t;\n    \n    state_t state, next_state;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_addresses <= '{default: '0};\n            port_numbers <= '{default: '0};\n            valid_entries <= '0;\n            age_counters <= '{default: '0};\n            mac_if.lookup_hit <= 1'b0;\n            mac_if.dest_port <= '0;\n            mac_if.ready <= 1'b0;\n        end else begin\n            state <= next_state;\n            \n            case (state)\n                IDLE: begin\n                    mac_if.ready <= 1'b1;\n                    if (mac_if.valid) begin\n                        // Start lookup/learn process\n                    end\n                end\n                \n                LOOKUP: begin\n                    // MAC address lookup logic\n                    for (int i = 0; i < MacTableDepth; i++) begin\n                        if (valid_entries[i] && mac_addresses[i] == mac_if.dst_mac) begin\n                            mac_if.lookup_hit <= 1'b1;\n                            mac_if.dest_port <= port_numbers[i];\n                            age_counters[i] <= '0; // Reset age counter on use\n                        end\n                    end\n                end\n                \n                // Additional states...\n            endcase\n        end\n    end\n    \n    // Age counter management\n    always_ff @(posedge clock) begin\n        if (!reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (valid_entries[i]) begin\n                    if (age_counters[i] >= MacTableCyclesPerEpoch)\n                        valid_entries[i] <= 1'b0;\n                    else\n                        age_counters[i] <= age_counters[i] + 1;\n                end\n            end\n        end\n    end\nendmodule\n```\n\n4. Forwarding Decision Engine:\n```systemverilog\nmodule forwarding_decision (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dst_mac,\n    input  logic [3:0]  src_port,\n    input  logic        mac_lookup_hit,\n    input  logic [3:0]  mac_lookup_port,\n    output logic [NumPorts-1:0] dest_ports\n);\n\n    logic is_broadcast, is_multicast;\n    \n    assign is_broadcast = &dst_mac;\n    assign is_multicast = dst_mac[40];\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_ports <= '0;\n        end else begin\n            if (is_broadcast || is_multicast) begin\n                // Forward to all ports except source\n                dest_ports <= {{NumPorts{1'b1}}} & ~(1'b1 << src_port);\n            end else if (mac_lookup_hit) begin\n                // Forward to specific port\n                dest_ports <= 1'b1 << mac_lookup_port;\n            end else begin\n                // Unknown destination - flood\n                dest_ports <= {{NumPorts{1'b1}}} & ~(1'b1 << src_port);\n            end\n        end\n    end\nendmodule\n```\n\nCritical interfaces between these submodules:\n1. Input to MAC Table:\n- MAC addresses (source and destination)\n- Port information\n- Frame validity signals\n\n2. MAC Table to Forwarding:\n- Lookup results\n- Port mapping\n- Hit/miss indication\n\n3. Forwarding to Output:\n- Destination port bitmap\n- Frame control signals\n- Backpressure signals\n\nThese interfaces need careful consideration for:\n- Timing closure\n- Handshaking protocols\n- Buffer management\n- Error handling\n- Performance optimization\n\nWould you like me to continue with the remaining submodules?\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/test_l2_switch_lite_5/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule custom_tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n",
    "name": "test_l2_switch_lite_5"
  },
  {
    "index": 2,
    "dut": "module dut #(\n  parameter int          Depth = 4096,\n  parameter int          EntriesMTU = 1504,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int          FifoSizeInBytes = 4096,\n  parameter int          MaxNumberOfPackets = 32,\n  parameter int          DropIngressOnAfull = 1,\n  parameter int          DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n) (\n  input  logic                          clock,\n  input  logic                          reset,\n  \n  input  AxiStreamType                  inAxi4St,\n  output logic                          inTready,\n  input  logic                          inError,\n  input  logic [ExtraDataWidth-1:0]     inExtra,\n  \n  output AxiStreamType                  outAxi4St,\n  input  logic                          outTready,\n  output logic                          outError,\n  output logic [ExtraDataWidth-1:0]     outExtra,\n  \n  output logic                          inFifoAfull,\n  output logic                          inDropEvent,\n  output logic                          outDropEvent\n);\n\n// Zero depth bypass mode\ngenerate\nif (Depth == 0) begin : bypass_gen\n    assign outAxi4St = inAxi4St;\n    assign outError = inError;\n    assign outExtra = inExtra;\n    assign inTready = 1'b1;\n    assign inFifoAfull = 1'b0;\n    assign inDropEvent = 1'b0;\n    assign outDropEvent = 1'b0;\nend\nelse begin : fifo_gen\n\n    // Internal signals\n    logic frame_in_progress;\n    logic dropping_frame;\n    logic [15:0] fifo_count;\n    logic [7:0] packet_count;\n    logic write_enable;\n    logic can_accept_frame;\n    \n    // Frame tracking and drop control\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_in_progress <= 1'b0;\n            dropping_frame <= 1'b0;\n        end else begin\n            if (inAxi4St.tvalid && inAxi4St.tlast) begin\n                frame_in_progress <= 1'b0;\n                dropping_frame <= 1'b0;\n            end else if (inAxi4St.tvalid && !frame_in_progress) begin\n                frame_in_progress <= 1'b1;\n                dropping_frame <= !can_accept_frame;\n            end\n        end\n    end\n\n    // Packet counter\n    always_ff @(posedge clock) begin\n        if (reset)\n            packet_count <= '0;\n        else begin\n            if (inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame)\n                packet_count <= packet_count + 1'b1;\n            if (outAxi4St.tvalid && outAxi4St.tlast && outTready)\n                packet_count <= packet_count - 1'b1;\n        end\n    end\n\n    // Frame acceptance logic\n    assign can_accept_frame = (packet_count < MaxNumberOfPackets) &&\n                            ((Depth - fifo_count) >= EntriesMTU);\n    \n    // FIFO write control\n    assign write_enable = inAxi4St.tvalid && !dropping_frame;\n    \n    // Status signals\n    assign inTready = 1'b1;\n    assign inFifoAfull = !can_accept_frame;\n    assign inDropEvent = dropping_frame && inAxi4St.tvalid && inAxi4St.tlast;\n    assign outDropEvent = 1'b0;\n\n    // Main FIFO instantiation\n    local_axist_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ExtraDataWidth(ExtraDataWidth),\n        .Depth(Depth)\n    ) main_fifo (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inError(inError),\n        .inExtra(inExtra),\n        .inTready(),  // Not connected - we handle flow control\n        .outAxi4St(outAxi4St),\n        .outError(outError),\n        .outExtra(outExtra),\n        .outTready(outTready),\n        .inCount(fifo_count),\n        .outCount(),\n        .almostFull(),\n        .almostEmpty()\n    );\n\nend\nendgenerate\n\n// Parameter validation\ninitial begin\n    if (Depth != 0) begin\n        assert(Depth >= 64) else\n            $error(\"Depth must be >= 64\");\n        assert((Depth & (Depth-1)) == 0) else\n            $error(\"Depth must be a power of 2\");\n    end\nend\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module is a specialized AXI4-Stream FIFO that implements a store-and-forward mechanism with frame-aware behavior. Key features include:\n\n1. Store-and-Forward Operation:\n- Must store complete frames (packets) before forwarding\n- A frame is defined from first data until tlast=1 is detected\n- Once transmission starts, it must continue until frame completion\n\n2. Frame Drop Conditions:\n- Drops incoming frames if there isn't enough space for MTU size at frame start\n- Drops frames if maximum number of stored packets (MaxNumberOfPackets) is reached\n- Always maintains inTready=1, using dropping instead of backpressure\n\n3. Data Path Features:\n- Handles AXI4-Stream protocol signals (tdata, tkeep, tuser, tlast, tvalid)\n- Additional side-band signals (inError, inExtra) that travel with the data\n- Parameterizable data width and FIFO depth\n\nHigh-Level Block Diagram:\n```\n                   +-------------------------+\ninAxi4St --------->|                        |\ninError  --------->|     Frame Control      |\ninExtra  --------->|        Logic           |\n                   |    (Drop Decision)      |\n                   +------------|------------+\n                               |\n                   +------------|------------+\n                   |     Data FIFO          |\n                   | (local_axist_fifo)     |---------> outAxi4St\n                   +-------------------------+---------> outError\n                   |    Packet Counter      |---------> outExtra\n                   | (local_fifo for count) |\n                   +-------------------------+\n                               |\n                   +------------|------------+\n                   |    Status Outputs      |\n                   | (inFifoAfull,          |\n                   |  inDropEvent, etc)     |\n                   +-------------------------+\n```\n\nThe design consists of:\n1. Frame Control Logic: Monitors incoming frames and makes drop decisions\n2. Main FIFO: Stores the AXI4-Stream data and associated signals\n3. Packet Counter: Tracks number of stored packets\n4. Status Logic: Generates status signals like inFifoAfull and drop events\n\nThis module essentially provides frame-aware buffering with intelligent drop capabilities, ensuring complete frames are either fully stored or completely dropped based on available resources.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nCritical Parameters:\n1. FIFO Depth Related:\n```systemverilog\nparameter int Depth = 4096  // Must be \u226564 and power of 2\nparameter int FifoSizeInBytes = 4096 // Should match Depth when AxiStreamWidth=8\n```\n\n2. Data Width Related:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\nparameter int unsigned AxiStreamWidth = 8  // Must match AxiStreamType.tdata width\nparameter int unsigned ExtraDataWidth = 1  // For additional sideband data\n```\n\n3. Frame Control Related:\n```systemverilog\nparameter int EntriesMTU = 1504  // Minimum free space needed for new frame\nparameter int PacketMtuInBytes = 1500  // Maximum frame size in bytes\nparameter int MaxNumberOfPackets = 32  // Maximum stored packets allowed\n```\n\nRequired Parameters (with fixed values):\n```systemverilog\nparameter int DropIngressOnAfull = 1  // Must be 1\nparameter int DropEgressOnError = 1   // Must be 1\nparameter int IngressPrefillBytes = -1 // Must be -1\n```\n\nReasonable Default Configuration:\n```systemverilog\nmodule dut #(\n    // Core Parameters\n    parameter int          Depth = 4096,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter type        AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned ExtraDataWidth = 1,\n    \n    // Frame Control\n    parameter int         EntriesMTU = 1504,\n    parameter int         PacketMtuInBytes = 1500,\n    parameter int         MaxNumberOfPackets = 32,\n    parameter int         FifoSizeInBytes = 4096,\n    \n    // Fixed Parameters\n    parameter int         DropIngressOnAfull = 1,\n    parameter int         DropEgressOnError = 1,\n    parameter int         IngressPrefillBytes = -1\n)\n```\n\nParameter Considerations:\n1. Depth should be validated:\n   - Must be \u226564\n   - Must be a power of 2\n   - Should align with FifoSizeInBytes and AxiStreamWidth\n\n2. MTU Related:\n   - EntriesMTU should be slightly larger than PacketMtuInBytes to account for overhead\n   - PacketMtuInBytes should be standard network MTU size (1500 is common)\n\n3. MaxNumberOfPackets:\n   - Should be reasonable for the FIFO depth\n   - 32 is a good default for 4KB FIFO\n\n4. AxiStreamWidth:\n   - Must match the tdata width in AxiStreamType\n   - 8 bits is common for byte-oriented designs\n\nThese parameters allow the module to be configured for different:\n- Buffer sizes\n- Data widths\n- Frame sizes\n- Maximum packet counts\nwhile maintaining the core store-and-forward functionality.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n```\n1. Input Stage:\n   [Combinational Logic]\n   - Frame start detection\n   - Drop decision logic\n   - FIFO write control\n\n2. Storage Stage:\n   [Registers/FIFO]\n   - Main data FIFO (using local_axist_fifo)\n   - Packet counter FIFO (using local_fifo)\n\n3. Output Stage:\n   [Combinational & Sequential Logic]\n   - Frame transmission control\n   - Output valid/ready handling\n```\n\nRequired Registers:\n```systemverilog\n// Frame tracking\nreg        frame_in_progress;  // Tracks active input frame\nreg        dropping_frame;     // Indicates current frame is being dropped\nreg [15:0] packet_count;      // Tracks stored complete packets\n\n// Status tracking\nreg        last_was_dropped;   // For drop event generation\n```\n\nRequired Combinational Logic:\n```systemverilog\n// Input Stage Logic\nlogic can_accept_new_frame = \n    (packet_count < MaxNumberOfPackets) &&\n    ((Depth - fifo.inCount) >= EntriesMTU);\n\n// Drop Detection\nlogic should_drop_frame =\n    !can_accept_new_frame && \n    inAxi4St.tvalid && \n    !frame_in_progress;\n\n// FIFO Write Control\nlogic write_to_fifo = \n    inAxi4St.tvalid && \n    !dropping_frame;\n\n// Status Generation\nassign inFifoAfull = !can_accept_new_frame;\nassign inDropEvent = dropping_frame && inAxi4St.tvalid && inAxi4St.tlast;\n```\n\nData Transformations:\n1. Input Processing:\n```systemverilog\n// Package AXI stream signals with extra data\ntypedef struct packed {\n    AxiStreamType axi;\n    logic [ExtraDataWidth-1:0] extra;\n    logic error;\n} fifo_data_t;\n\n// Input transformation\nfifo_data_t fifo_in_data;\nassign fifo_in_data.axi = inAxi4St;\nassign fifo_in_data.extra = inExtra;\nassign fifo_in_data.error = inError;\n```\n\n2. Output Processing:\n```systemverilog\n// Output transformation\nassign outAxi4St = fifo_out_data.axi;\nassign outExtra = fifo_out_data.extra;\nassign outError = fifo_out_data.error;\n```\n\nKey State Machines:\n1. Input Frame Control:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_in_progress <= 0;\n        dropping_frame <= 0;\n    end else begin\n        if (inAxi4St.tvalid && inAxi4St.tlast) begin\n            frame_in_progress <= 0;\n            dropping_frame <= 0;\n        end else if (inAxi4St.tvalid && !frame_in_progress) begin\n            frame_in_progress <= 1;\n            dropping_frame <= should_drop_frame;\n        end\n    end\nend\n```\n\n2. Packet Counter:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset)\n        packet_count <= 0;\n    else begin\n        if (write_to_fifo && inAxi4St.tlast)\n            packet_count <= packet_count + 1;\n        if (outAxi4St.tvalid && outAxi4St.tlast && outTready)\n            packet_count <= packet_count - 1;\n    end\nend\n```\n\nSpecial Considerations:\n1. Zero-Depth Bypass Mode:\n```systemverilog\ngenerate\nif (Depth == 0) begin\n    // Direct connection\n    assign outAxi4St = inAxi4St;\n    assign outError = inError;\n    assign outExtra = inExtra;\nend\nendgenerate\n```\n\n2. Error Handling:\n- Must maintain frame integrity\n- Error signals must align with tlast\n- Drop decisions must be made at frame boundaries\n\nThis structure ensures:\n- Complete frame storage before forwarding\n- Proper frame dropping when necessary\n- Accurate packet counting\n- Maintenance of AXI4-Stream protocol rulesWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description and typical AXI4-Stream requirements, let's analyze the timing aspects:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock  // Single synchronous clock for entire design\n```\n- All operations are synchronous to this clock\n- No clock domain crossing required\n\nReset Requirements:\n1. Synchronous Reset:\n```systemverilog\ninput logic reset  // Synchronous reset\n```\n- The problem explicitly specifies synchronous reset\n- All registers should be reset synchronously\n\nSignals Requiring Reset:\n```systemverilog\n// Control Logic\nframe_in_progress <= 1'b0;\ndropping_frame    <= 1'b0;\npacket_count      <= '0;\nlast_was_dropped  <= 1'b0;\n\n// FIFO Resets\n// (handled internally by local_axist_fifo and local_fifo modules)\n```\n\nLatency Requirements:\nWhile not explicitly stated, the following can be inferred:\n1. Input Path:\n- Single cycle latency for drop decisions\n- FIFO write latency (determined by local_axist_fifo)\n\n2. Output Path:\n- Store-and-forward implies complete frame must be stored before transmission\n- Minimum latency = frame size + FIFO read latency\n\nThroughput Requirements:\n1. Input Side:\n- Must accept data every cycle when not dropping (inTready=1)\n- No backpressure allowed (always ready)\n\n2. Output Side:\n- Once frame transmission starts, must continue until completion\n- No gaps allowed within a frame\n\nTiming Constraints:\n```systemverilog\n// Input Timing Path\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Synchronous reset paths\n    end else begin\n        // Setup/Hold paths for frame control\n    end\nend\n\n// Critical Timing Paths:\n1. Drop decision logic -> FIFO write enable\n2. Packet counter -> New frame acceptance logic\n3. FIFO count -> Almost full detection\n```\n\nThroughput Guarantees:\n```systemverilog\n// Input Side\nassign inTready = 1'b1;  // Always ready\n\n// Output Side\n// Once started, frame must complete\nalways_ff @(posedge clock) begin\n    if (outAxi4St.tvalid)\n        assert (outAxi4St.tvalid || outTready) \n            until (outAxi4St.tlast && outTready);\nend\n```\n\nPerformance Considerations:\n1. Zero-Delay Bypass:\n```systemverilog\nif (Depth == 0) begin\n    // Direct combinational path\n    assign outAxi4St = inAxi4St;\nend\n```\n\n2. FIFO Performance:\n- Relies on local_axist_fifo performance\n- Should support full throughput (read/write every cycle)\n\n3. Critical Paths:\n- Drop decision logic should complete in one cycle\n- Packet counting logic must not create timing bottlenecks\n\nReset Strategy:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Control signals\n        frame_in_progress <= 1'b0;\n        dropping_frame    <= 1'b0;\n        packet_count      <= '0;\n        \n        // Status signals\n        inFifoAfull      <= 1'b0;\n        inDropEvent      <= 1'b0;\n        outDropEvent     <= 1'b0;\n    end else begin\n        // Normal operation\n    end\nend\n```\n\nAll these timing aspects ensure:\n- Deterministic behavior\n- No data loss (except intended drops)\n- Consistent frame handling\n- Proper store-and-forward operation\n- Reliable packet counting\n- Clean reset behaviorWhat test cases and verification methods should be used to verify the design? What are the corner cases?\n [NEW STEP]\n \nLet's outline a comprehensive verification strategy:\n\nBasic Test Cases:\n```systemverilog\n1. Basic Functionality:\n   // Single packet transfer\n   test_single_packet();\n   // Multiple back-to-back packets\n   test_consecutive_packets();\n   // Packets with gaps\n   test_packets_with_gaps();\n\n2. FIFO Operation:\n   // Empty to full transition\n   test_fill_fifo();\n   // Full to empty transition\n   test_drain_fifo();\n   // Simultaneous read/write\n   test_concurrent_operations();\n```\n\nCorner Cases:\n```systemverilog\n1. Frame Size Cases:\n   // Minimum size frame (1 beat)\n   test_minimum_frame();\n   // Maximum size frame (MTU size)\n   test_maximum_frame();\n   // Frame exactly filling FIFO\n   test_exact_fifo_fill();\n\n2. Drop Conditions:\n   // Frame start when almost full\n   test_drop_on_full();\n   // Maximum packet count reached\n   test_max_packets_drop();\n   // Drop during multi-beat frame\n   test_mid_frame_drop();\n\n3. Backpressure:\n   // outTready toggling\n   test_output_backpressure();\n   // Variable outTready patterns\n   test_random_backpressure();\n\n4. Special Conditions:\n   // Zero-depth bypass mode\n   test_zero_depth_bypass();\n   // Reset during frame transfer\n   test_reset_mid_frame();\n   // Error conditions\n   test_error_propagation();\n```\n\nProtocol Compliance Tests:\n```systemverilog\n// AXI4-Stream Protocol Checks\nproperty valid_ready_handshake;\n    @(posedge clock)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\n\n// Frame Integrity Checks\nproperty store_forward_check;\n    @(posedge clock)\n    outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid;\nendproperty\n\n// Drop Behavior Checks\nproperty drop_complete_frames;\n    @(posedge clock)\n    (inDropEvent && inAxi4St.tlast) |-> \n    (dropping_frame throughout (inAxi4St.tvalid && !inAxi4St.tlast));\nendproperty\n```\n\nRandomized Testing:\n```systemverilog\nclass random_test;\n    // Randomize frame sizes\n    rand int frame_size;\n    constraint frame_size_c {\n        frame_size inside {[1:PacketMtuInBytes]};\n    }\n\n    // Randomize gaps between frames\n    rand int inter_frame_gap;\n    constraint gap_c {\n        inter_frame_gap inside {[0:20]};\n    }\n\n    // Randomize backpressure\n    rand bit[7:0] ready_pattern;\nendclass\n```\n\nCoverage Points:\n```systemverilog\ncovergroup fifo_cov;\n    // FIFO fill levels\n    fifo_level: coverpoint fifo.inCount {\n        bins empty = {0};\n        bins almost_full = {[Depth-EntriesMTU:Depth-1]};\n        bins full = {Depth};\n        bins others[] = {[1:Depth-EntriesMTU-1]};\n    }\n\n    // Packet counts\n    packet_count: coverpoint packet_count {\n        bins low = {[0:MaxNumberOfPackets/4]};\n        bins mid = {[MaxNumberOfPackets/4+1:MaxNumberOfPackets*3/4]};\n        bins high = {[MaxNumberOfPackets*3/4+1:MaxNumberOfPackets]};\n    }\n\n    // Drop scenarios\n    drop_reason: coverpoint {inFifoAfull, packet_count >= MaxNumberOfPackets} {\n        bins full_drop = {2'b10};\n        bins count_drop = {2'b01};\n        bins both_drop = {2'b11};\n    }\nendgroup\n```\n\nAssertion Checks:\n```systemverilog\n// Protocol Assertions\nassert property (@(posedge clock)\n    outAxi4St.tvalid && outAxi4St.tlast && outTready |=>\n    !outAxi4St.tvalid || !outAxi4St.tlast);\n\n// Functional Assertions\nassert property (@(posedge clock)\n    packet_count <= MaxNumberOfPackets);\n\nassert property (@(posedge clock)\n    inTready == 1'b1);\n```\n\nSystem-Level Verification:\n1. Integration Tests:\n```systemverilog\n// Test with upstream/downstream delays\ntest_system_timing();\n// Test with multiple instances\ntest_cascaded_fifos();\n```\n\n2. Performance Tests:\n```systemverilog\n// Measure latency\ntest_frame_latency();\n// Measure throughput\ntest_sustained_throughput();\n```\n\nError Injection:\n```systemverilog\n// Test error propagation\ntest_error_handling();\n// Test reset recovery\ntest_reset_recovery();\n```\n\nThese verification methods ensure:\n- Functional correctness\n- Protocol compliance\n- Corner case handling\n- Performance requirements\n- Error handling\n- Reset behavior\n- Complete coverage of design featuresWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n1. Basic Functionality Tests:\n```systemverilog\n// Single Frame Tests\ntask test_basic_frame();\n    // Short frame\n    send_frame(4);\n    // Medium frame\n    send_frame(100);\n    // MTU size frame\n    send_frame(PacketMtuInBytes);\nendtask\n\n// Back-to-Back Frame Tests\ntask test_consecutive_frames();\n    repeat(5) begin\n        send_frame($urandom_range(1, PacketMtuInBytes));\n        check_no_gaps();\n    end\nendtask\n```\n\n2. FIFO Capacity Tests:\n```systemverilog\n// Fill Tests\ntask test_fifo_filling();\n    // Fill to almost full\n    while (!dut.inFifoAfull) begin\n        send_frame(100);\n    end\n    // Try sending one more frame\n    send_frame(100);\n    // Verify drop behavior\nendtask\n\n// Packet Count Tests\ntask test_max_packets();\n    repeat(MaxNumberOfPackets + 1) begin\n        send_frame(10);\n        verify_packet_handling();\n    end\nendtask\n```\n\n3. Corner Case Tests:\n```systemverilog\n// Minimum/Maximum Size Tests\ntask test_size_extremes();\n    // 1-beat frame\n    send_frame(1);\n    // Maximum size frame\n    send_frame(PacketMtuInBytes);\n    // Oversized frame (should be dropped)\n    send_frame(PacketMtuInBytes + 1);\nendtask\n\n// Reset Tests\ntask test_reset_scenarios();\n    // Reset during frame reception\n    fork\n        send_frame(100);\n        #10 apply_reset();\n    join\n    // Verify proper recovery\nendtask\n```\n\n4. Protocol Tests:\n```systemverilog\n// Backpressure Tests\ntask test_backpressure();\n    // Toggle outTready randomly\n    fork\n        send_frame(100);\n        apply_random_backpressure();\n    join\nendtask\n\n// Error Propagation Tests\ntask test_error_handling();\n    // Send frame with error\n    send_frame_with_error(50);\n    // Verify error propagation\nendtask\n```\n\nAssertions:\n1. Protocol Assertions:\n```systemverilog\n// Valid/Ready Handshake\nproperty valid_ready_handshake;\n    @(posedge clock)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property (valid_ready_handshake) else\n    $error(\"Valid dropped without ready\");\n\n// Frame Continuity\nproperty frame_continuity;\n    @(posedge clock)\n    outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid;\nendproperty\nassert property (frame_continuity) else\n    $error(\"Gap in frame transmission\");\n```\n\n2. Functional Assertions:\n```systemverilog\n// Packet Counter Checks\nproperty packet_counter_valid;\n    @(posedge clock)\n    packet_count <= MaxNumberOfPackets;\nendproperty\nassert property (packet_counter_valid);\n\n// Drop Logic\nproperty drop_logic_check;\n    @(posedge clock)\n    $rose(dropping_frame) |-> \n    !frame_in_progress && inAxi4St.tvalid;\nendproperty\nassert property (drop_logic_check);\n```\n\n3. FIFO Behavior Assertions:\n```systemverilog\n// Almost Full Indication\nproperty almost_full_check;\n    @(posedge clock)\n    (Depth - fifo.inCount) < EntriesMTU |-> inFifoAfull;\nendproperty\nassert property (almost_full_check);\n\n// Packet Storage\nproperty packet_storage_check;\n    @(posedge clock)\n    (inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame) |=>\n    (packet_count == $past(packet_count) + 1);\nendproperty\nassert property (packet_storage_check);\n```\n\n4. Error Condition Assertions:\n```systemverilog\n// Input Ready\nproperty input_always_ready;\n    @(posedge clock) inTready == 1'b1;\nendproperty\nassert property (input_always_ready);\n\n// Error Propagation\nproperty error_propagation;\n    @(posedge clock)\n    (inError && inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame) |=>\n    ##[0:$] (outError && outAxi4St.tvalid && outAxi4St.tlast);\nendproperty\nassert property (error_propagation);\n```\n\n5. Reset Behavior Assertions:\n```systemverilog\n// Reset State Check\nproperty reset_state;\n    @(posedge clock)\n    $rose(reset) |=> \n        !frame_in_progress && \n        !dropping_frame && \n        packet_count == 0;\nendproperty\nassert property (reset_state);\n```\n\nCoverpoints:\n```systemverilog\ncovergroup operation_cov @(posedge clock);\n    // FIFO States\n    fifo_state: coverpoint {inFifoAfull, dropping_frame} {\n        bins normal_operation = {2'b00};\n        bins dropping = {2'b01};\n        bins full = {2'b10};\n        bins full_dropping = {2'b11};\n    }\n\n    // Frame Sizes\n    frame_size: coverpoint current_frame_size {\n        bins small = {[1:10]};\n        bins medium = {[11:100]};\n        bins large = {[101:PacketMtuInBytes]};\n    }\nendgroup\n```\n\nThese comprehensive tests and assertions ensure:\n- Complete protocol compliance\n- Proper frame handling\n- Correct drop behavior\n- Error handling\n- Reset functionality\n- Corner case coverage\n- Performance requirementsWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nHere's a logical breakdown of the design into functional blocks/submodules:\n\n1. Frame Controller\n```systemverilog\nmodule frame_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic [15:0] fifo_count,\n    input  logic [7:0]  packet_count,\n    output logic        dropping_frame,\n    output logic        write_enable,\n    output logic        inDropEvent\n);\n```\nTasks:\n- Tracks frame boundaries\n- Makes drop decisions\n- Manages frame_in_progress state\n- Generates drop events\n- Ensures complete frames are dropped\n\n2. Packet Counter\n```systemverilog\nmodule packet_counter (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  AxiStreamType outAxi4St,\n    input  logic        outTready,\n    input  logic        dropping_frame,\n    output logic [7:0]  packet_count\n);\n```\nTasks:\n- Tracks number of stored packets\n- Increments on complete frame storage\n- Decrements on complete frame transmission\n- Ensures MaxNumberOfPackets limit\n\n3. FIFO Manager\n```systemverilog\nmodule fifo_manager (\n    input  logic        clock,\n    input  logic        reset,\n    input  fifo_data_t  in_data,\n    input  logic        write_enable,\n    input  logic        outTready,\n    output fifo_data_t  out_data,\n    output logic [15:0] fifo_count\n);\n```\nTasks:\n- Instantiates and manages local_axist_fifo\n- Handles data packaging/unpackaging\n- Manages FIFO counts\n- Handles store-and-forward timing\n\n4. Status Generator\n```systemverilog\nmodule status_generator (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [15:0] fifo_count,\n    input  logic [7:0]  packet_count,\n    input  logic        dropping_frame,\n    output logic        inFifoAfull,\n    output logic        inDropEvent,\n    output logic        outDropEvent\n);\n```\nTasks:\n- Generates status signals\n- Monitors FIFO fullness\n- Reports drop events\n- Handles almost full detection\n\n5. Data Packer/Unpacker\n```systemverilog\nmodule data_packer (\n    input  AxiStreamType inAxi4St,\n    input  logic        inError,\n    input  logic        inExtra,\n    output fifo_data_t  packed_data\n);\n```\nTasks:\n- Combines AXI stream with extra signals\n- Formats data for FIFO storage\n- Handles data unpacking for output\n\n6. Top-Level Controller\n```systemverilog\nmodule dut (\n    // ... main module ports ...\n);\n```\nTasks:\n- Instantiates all submodules\n- Handles zero-depth bypass mode\n- Connects all submodules\n- Manages reset distribution\n\nIntegration Example:\n```systemverilog\nmodule dut (\n    // ... ports ...\n);\n    // Instantiate submodules\n    frame_controller frame_ctrl_inst (\n        .clock(clock),\n        .reset(reset),\n        // ... other connections ...\n    );\n\n    packet_counter pkt_counter_inst (\n        .clock(clock),\n        .reset(reset),\n        // ... other connections ...\n    );\n\n    fifo_manager fifo_mgr_inst (\n        .clock(clock),\n        .reset(reset),\n        // ... other connections ...\n    );\n\n    // ... other instantiations ...\n\n    // Zero-depth bypass logic\n    generate\n        if (Depth == 0) begin\n            assign outAxi4St = inAxi4St;\n            assign outError = inError;\n            assign outExtra = inExtra;\n        end\n    endgenerate\nendmodule\n```\n\nInterconnections:\n```\nFrame Controller \u2192 FIFO Manager:\n    - write_enable signal\n    - dropping_frame status\n\nFIFO Manager \u2192 Packet Counter:\n    - frame completion signals\n    - storage status\n\nStatus Generator \u2190 All blocks:\n    - collects status from all submodules\n    - generates unified status outputs\n\nData Packer \u2192 FIFO Manager:\n    - formatted data for storage\n```\n\nBenefits of this modular approach:\n1. Clear separation of concerns\n2. Easier testing and verification\n3. Simplified maintenance\n4. Better reusability\n5. Parallel development possible\n6. Isolated debugging\n7. Clear interfaces between functions\n\nThis modular structure creates a maintainable and verifiable design while keeping the complexity manageable in each submodule.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write SystemVerilog code for each submodule and identify critical interfaces.\n\n1. Frame Controller:\n```systemverilog\nmodule frame_controller #(\n    parameter int EntriesMTU = 1504,\n    parameter int MaxNumberOfPackets = 32\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic [15:0] fifo_count,\n    input  logic [7:0]  packet_count,\n    output logic        dropping_frame,\n    output logic        write_enable,\n    output logic        inDropEvent\n);\n    logic frame_in_progress;\n    logic can_accept_frame;\n\n    // Frame acceptance logic\n    assign can_accept_frame = (packet_count < MaxNumberOfPackets) &&\n                             (fifo_count + EntriesMTU <= Depth);\n\n    // Frame tracking\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_in_progress <= 1'b0;\n            dropping_frame <= 1'b0;\n        end else begin\n            if (inAxi4St.tvalid && inAxi4St.tlast) begin\n                frame_in_progress <= 1'b0;\n                dropping_frame <= 1'b0;\n            end else if (inAxi4St.tvalid && !frame_in_progress) begin\n                frame_in_progress <= 1'b1;\n                dropping_frame <= !can_accept_frame;\n            end\n        end\n    end\n\n    // Write enable and drop event generation\n    assign write_enable = inAxi4St.tvalid && !dropping_frame;\n    assign inDropEvent = dropping_frame && inAxi4St.tvalid && inAxi4St.tlast;\n\nendmodule\n```\n\n2. Packet Counter:\n```systemverilog\nmodule packet_counter #(\n    parameter int MaxNumberOfPackets = 32\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  AxiStreamType outAxi4St,\n    input  logic        outTready,\n    input  logic        dropping_frame,\n    output logic [7:0]  packet_count\n);\n\n    logic increment_count, decrement_count;\n    \n    assign increment_count = inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame;\n    assign decrement_count = outAxi4St.tvalid && outAxi4St.tlast && outTready;\n\n    always_ff @(posedge clock) begin\n        if (reset)\n            packet_count <= '0;\n        else begin\n            case ({increment_count, decrement_count})\n                2'b10: packet_count <= packet_count + 1'b1;\n                2'b01: packet_count <= packet_count - 1'b1;\n                default: packet_count <= packet_count;\n            endcase\n        end\n    end\n\nendmodule\n```\n\n3. FIFO Manager:\n```systemverilog\nmodule fifo_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int  Depth = 4096,\n    parameter int  ExtraDataWidth = 1\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  fifo_data_t  in_data,\n    input  logic        write_enable,\n    input  logic        outTready,\n    output fifo_data_t  out_data,\n    output logic [15:0] fifo_count\n);\n\n    // Instantiate local_axist_fifo\n    local_axist_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .ExtraDataWidth(ExtraDataWidth),\n        .Depth(Depth)\n    ) fifo_inst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(in_data.axi),\n        .inError(in_data.error),\n        .inExtra(in_data.extra),\n        .inTready(),  // Not used\n        .outAxi4St(out_data.axi),\n        .outError(out_data.error),\n        .outExtra(out_data.extra),\n        .outTready(outTready),\n        .inCount(fifo_count)\n    );\n\nendmodule\n```\n\n4. Status Generator:\n```systemverilog\nmodule status_generator #(\n    parameter int EntriesMTU = 1504,\n    parameter int MaxNumberOfPackets = 32\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [15:0] fifo_count,\n    input  logic [7:0]  packet_count,\n    input  logic        dropping_frame,\n    output logic        inFifoAfull,\n    output logic        inDropEvent,\n    output logic        outDropEvent\n);\n\n    // Almost full detection\n    assign inFifoAfull = (packet_count >= MaxNumberOfPackets) ||\n                         (fifo_count + EntriesMTU > Depth);\n\n    // Register drop events\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            inDropEvent <= 1'b0;\n            outDropEvent <= 1'b0;\n        end else begin\n            inDropEvent <= dropping_frame;\n            outDropEvent <= 1'b0;  // Always 0 per specification\n        end\n    end\n\nendmodule\n```\n\n5. Data Packer:\n```systemverilog\nmodule data_packer #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int  ExtraDataWidth = 1\n) (\n    input  AxiStreamType inAxi4St,\n    input  logic        inError,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    output fifo_data_t  packed_data\n);\n\n    // Pack data into FIFO format\n    assign packed_data.axi = inAxi4St;\n    assign packed_data.error = inError;\n    assign packed_data.extra = inExtra;\n\nendmodule\n```\n\nCritical Interfaces:\n1. Frame Controller \u2194 FIFO Manager:\n```systemverilog\n// Critical signals\nlogic write_enable;    // Controls FIFO writes\nlogic dropping_frame;  // Indicates frame drop in progress\n```\n\n2. Packet Counter \u2194 Frame Controller:\n```systemverilog\n// Critical signals\nlogic [7:0] packet_count;  // Current stored packet count\n```\n\n3. FIFO Manager \u2194 Status Generator:\n```systemverilog\n// Critical signals\nlogic [15:0] fifo_count;   // FIFO occupancy\nlogic        inFifoAfull;  // Almost full status\n```\n\n4. Data Packer \u2194 FIFO Manager:\n```systemverilog\n// Critical interface type\ntypedef struct packed {\n    AxiStreamType axi;\n    logic [ExtraDataWidth-1:0] extra;\n    logic error;\n} fifo_data_t;\n```\n\nThese interfaces are critical for:\n- Flow control\n- Drop decisions\n- Status monitoring\n- Data integrity\n- Protocol compliance\n\nSpecial attention should be paid to timing and synchronization at these interfaces to ensure proper operation.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = local_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = local_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_axist_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = local_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_storefwd_fifo_4"
  },
  {
    "index": 0,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac, \n    output logic        outParsedValid\n);\n\n    // Internal signals\n    logic [7:0]  data_to_extractor;\n    logic        data_valid;\n    logic [3:0]  byte_counter;\n    logic        parsing_active;\n    logic [47:0] dest_mac;\n    logic [47:0] src_mac;\n    logic        mac_valid;\n\n    // AXI4-Stream handler instance\n    axi4_stream_handler #(\n        .AxiStreamType(AxiStreamType)\n    ) u_axi4_handler (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready),\n        .data_to_extractor(data_to_extractor),\n        .data_valid(data_valid),\n        .pipeline_ready(1'b1)\n    );\n\n    // Frame state controller instance\n    frame_state_controller u_frame_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .tvalid(inAxi4St.tvalid),\n        .tlast(inAxi4St.tlast),\n        .tready(inTready),\n        .parsing_active(parsing_active),\n        .byte_counter(byte_counter)\n    );\n\n    // MAC address extractor instance\n    mac_extractor #(\n        .AxiStreamWidth(AxiStreamWidth)\n    ) u_mac_extractor (\n        .clock(clock),\n        .reset(reset),\n        .data_in(data_to_extractor),\n        .data_valid(data_valid),\n        .byte_counter(byte_counter),\n        .parsing_active(parsing_active),\n        .dest_mac(dest_mac),\n        .src_mac(src_mac),\n        .mac_valid(mac_valid)\n    );\n\n    // Output registers\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n            outParsedValid <= '0;\n        end else begin\n            outParsedDestMac <= dest_mac;\n            outParsedSourceMac <= src_mac;\n            outParsedValid <= mac_valid;\n        end\n    end\n\nendmodule\n\nmodule axi4_stream_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic [7:0]  data_to_extractor,\n    output logic        data_valid,\n    input  logic        pipeline_ready\n);\n\n    AxiStreamType outAxi4St_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outAxi4St_reg <= '0;\n        end\n        else if (outTready) begin\n            outAxi4St_reg <= inAxi4St;\n        end\n    end\n\n    assign inTready = outTready || !outAxi4St_reg.tvalid;\n    assign outAxi4St = outAxi4St_reg;\n    assign data_to_extractor = inAxi4St.tdata;\n    assign data_valid = inAxi4St.tvalid && inTready;\n\nendmodule\n\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    input  logic [3:0]  byte_counter,\n    input  logic        parsing_active,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        mac_valid\n);\n\n    logic [47:0] dest_mac_reg, src_mac_reg;\n    logic        mac_valid_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac_reg <= '0;\n            src_mac_reg <= '0;\n            mac_valid_reg <= '0;\n        end\n        else if (data_valid && parsing_active) begin\n            if (byte_counter < 6) begin\n                dest_mac_reg <= {dest_mac_reg[39:0], data_in};\n            end\n            else if (byte_counter < 12) begin\n                src_mac_reg <= {src_mac_reg[39:0], data_in};\n            end\n            \n            mac_valid_reg <= (byte_counter == 11);\n        end\n        else begin\n            mac_valid_reg <= '0;\n        end\n    end\n\n    assign dest_mac = dest_mac_reg;\n    assign src_mac = src_mac_reg;\n    assign mac_valid = mac_valid_reg;\n\nendmodule\n\nmodule frame_state_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        tlast,\n    input  logic        tready,\n    output logic        parsing_active,\n    output logic [3:0]  byte_counter\n);\n\n    logic parsing_active_reg;\n    logic [3:0] byte_counter_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            parsing_active_reg <= '0;\n            byte_counter_reg <= '0;\n        end\n        else if (tvalid && tready) begin\n            if (!parsing_active_reg || tlast) begin\n                byte_counter_reg <= '0;\n                parsing_active_reg <= !tlast;\n            end\n            else begin\n                byte_counter_reg <= byte_counter_reg + 1'b1;\n            end\n        end\n    end\n\n    assign parsing_active = parsing_active_reg;\n    assign byte_counter = byte_counter_reg;\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output sometime after the first data phit on inAxi4St.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- outParsedValid should be 1 for a single cycle when outParsedDestMac and outParsedSourceMac are valid.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\n1. This module is a MAC address parser/extractor for Ethernet frames that:\n   - Receives Ethernet frames via AXI4-Stream interface (inAxi4St)\n   - Extracts the Destination MAC (first 6 bytes) and Source MAC (next 6 bytes) addresses\n   - Passes through the original data stream unmodified (but possibly delayed) to outAxi4St\n   - Outputs the parsed MAC addresses with a valid signal\n\nHigh-Level Block Diagram:\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502              DUT                      \u2502\n inAxi4St \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                      \u2502\n                    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n                    \u2502    \u2502  MAC Extractor   \u2502              \u2502\n inTready \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502    \u2502                  \u2502              \u2502\n                    \u2502    \u2502                  \u2502              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outParsedDestMac[47:0]\n                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n                    \u2502                                      \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outParsedSourceMac[47:0]\n outTready \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n                    \u2502    \u2502  AXI4-St         \u2502              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outParsedValid\n                    \u2502    \u2502  Pass-through    \u2502              \u2502\n                    \u2502    \u2502                  \u2502              \u2502\n                    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outAxi4St\n                    \u2502                                      \u2502\n clock \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                     \u2502\n                    \u2502                                      \u2502\n reset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                     \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThe module consists of two main functional blocks:\n1. MAC Extractor: Responsible for parsing and extracting the MAC addresses from the incoming data stream\n2. AXI4-Stream Pass-through: Handles the forwarding of the original data stream while maintaining AXI4-Stream protocol compliance\n\nThe module operates synchronously with the clock and supports synchronous reset. It processes the input stream byte-by-byte (or in wider chunks depending on AxiStreamWidth) and must handle the AXI4-Stream handshaking protocol properly.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let me outline the parameterizable aspects and their reasonable default values:\n\nKey Parameterizable Aspects:\n\n1. AXI Stream Interface Type (AxiStreamType):\n   - Default: local_pkg::axi4st_8_s\n   - This is a struct type parameter that defines the AXI Stream interface format\n   - Contains fields: tdata, tkeep, tuser, tlast, tvalid\n\n2. AXI Stream Data Width (AxiStreamWidth):\n   - Default: 8 bits\n   - Defines the width of the tdata field in the AXI Stream interface\n   - Should match the tdata width in AxiStreamType\n\nOther Potential Parameterizable Aspects (though not specified in requirements):\n\n3. MAC Address Width:\n   - Fixed at 48 bits (6 bytes) as per Ethernet standard\n   - While this could theoretically be parameterizable, it's better to keep it fixed for standard Ethernet compatibility\n\n4. Pipeline Stages:\n   - Could be parameterizable to allow trade-offs between latency and timing\n   - Default would depend on the implementation strategy\n\nReasonable Default Values:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s;\nparameter int unsigned AxiStreamWidth = 8;\n```\n\nImportant Considerations:\n1. The AxiStreamWidth parameter should always match the width of AxiStreamType.tdata\n2. The implementation should be flexible enough to work with different data widths (8, 16, 32, etc.)\n3. The default 8-bit width represents a good balance between:\n   - Simplicity of implementation\n   - Minimal resource usage\n   - Standard byte-oriented processing\n\nThese parameters allow the module to be configured for different use cases while maintaining the core MAC address extraction functionality.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n1. Input Processing:\n```systemverilog\n// Counter for tracking position in frame\nlogic [3:0] byte_counter;\n// Shift registers for MAC addresses\nlogic [47:0] dest_mac_reg;\nlogic [47:0] src_mac_reg;\n// State tracking\nlogic parsing_active;\n```\n\n2. MAC Address Extraction (for 8-bit width):\n```systemverilog\n// Sequential logic for MAC extraction\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        byte_counter <= '0;\n        dest_mac_reg <= '0;\n        src_mac_reg <= '0;\n        parsing_active <= '0;\n    end\n    else if (inAxi4St.tvalid && inTready) begin\n        if (!parsing_active || inAxi4St.tlast) begin\n            byte_counter <= '0;\n            parsing_active <= !inAxi4St.tlast;\n        end\n        else begin\n            byte_counter <= byte_counter + 1;\n            // Destination MAC (first 6 bytes)\n            if (byte_counter < 6) begin\n                dest_mac_reg <= {dest_mac_reg[39:0], inAxi4St.tdata};\n            end\n            // Source MAC (next 6 bytes)\n            else if (byte_counter < 12) begin\n                src_mac_reg <= {src_mac_reg[39:0], inAxi4St.tdata};\n            end\n        end\n    end\nend\n```\n\n3. Output Generation:\n```systemverilog\n// AXI Stream pass-through registers\nAxiStreamType outAxi4St_reg;\n// Valid signal generation\nlogic parsed_valid_reg;\n\n// Output control logic\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        outAxi4St_reg <= '0;\n        parsed_valid_reg <= '0;\n    end\n    else begin\n        // Pass-through logic\n        if (outTready) begin\n            outAxi4St_reg <= inAxi4St;\n        end\n        \n        // MAC extraction complete signal\n        parsed_valid_reg <= (byte_counter == 11) && inAxi4St.tvalid && inTready;\n    end\nend\n```\n\nRequired Components:\n\n1. Registers:\n- byte_counter: Tracks position within the frame\n- dest_mac_reg: Holds extracted destination MAC\n- src_mac_reg: Holds extracted source MAC\n- parsing_active: Indicates active frame parsing\n- outAxi4St_reg: Pipeline register for AXI stream\n- parsed_valid_reg: Indicates MAC extraction complete\n\n2. Combinational Logic:\n```systemverilog\n// AXI Stream handshaking\nassign inTready = outTready || !outAxi4St_reg.tvalid;\n\n// Output assignments\nassign outAxi4St = outAxi4St_reg;\nassign outParsedDestMac = dest_mac_reg;\nassign outParsedSourceMac = src_mac_reg;\nassign outParsedValid = parsed_valid_reg;\n```\n\n3. Control Logic:\n- Frame boundary detection\n- Byte counting\n- MAC address shifting/assembly\n- Handshaking control\n\nKey Considerations:\n1. Proper handling of AXI Stream protocol\n2. Maintaining data alignment\n3. Correct big-endian byte ordering for MAC addresses\n4. Pipeline management for timing optimization\n5. Reset handling for all registers\n6. Valid signal timing for extracted MAC addresses\n\nThis implementation provides a balance between:\n- Resource utilization\n- Latency\n- Timing closure capability\n- Protocol compliance\n\nNote: The actual implementation might need adjustment based on the specific timing requirements and the chosen AxiStreamWidth.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the timing and reset requirements from the problem description:\n\nClocking Requirements:\n1. Single clock domain design (input: clock)\n2. All logic should be synchronous to this clock\n3. No specific clock frequency mentioned, but should follow standard AXI4-Stream timing\n\nReset Requirements:\n1. Explicitly specified as synchronous reset (input: reset)\n2. Should reset all sequential elements\n\nSignals Requiring Reset:\n1. State Registers:\n```systemverilog\n// All these need synchronous reset\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        byte_counter <= '0;\n        parsing_active <= '0;\n        dest_mac_reg <= '0;\n        src_mac_reg <= '0;\n        outAxi4St_reg <= '0;\n        parsed_valid_reg <= '0;\n    end\n```\n\nLatency Requirements:\n1. Flexible latency specified:\n   - Minimum: 0 cycles (for wide data width implementations)\n   - Maximum: 11 cycles (for 8-bit data width)\n2. Latency depends on AxiStreamWidth:\n   - 8-bit: Up to 11 cycles to collect all MAC bytes\n   - 16-bit: Up to 6 cycles\n   - 32-bit: Up to 3 cycles\n   - 64-bit: Up to 2 cycles\n   - 128-bit: 0-1 cycles\n\nThroughput Requirements:\n1. Must maintain AXI4-Stream throughput\n2. No data dropping allowed\n3. Continuous streaming supported through handshaking:\n   - inTready controls input acceptance\n   - outTready controls output transmission\n\nTiming Constraints:\n1. AXI4-Stream Protocol Timing:\n```systemverilog\n// Valid-Ready Handshaking\nassign inTready = outTready || !outAxi4St_reg.tvalid;\n```\n\n2. MAC Extraction Timing:\n```systemverilog\n// Valid assertion timing\nassign outParsedValid = parsed_valid_reg;\n// Must be asserted for exactly one clock cycle when MACs are valid\n```\n\n3. Frame Boundary Handling:\n```systemverilog\n// Must properly handle frame boundaries marked by tlast\n// Cannot start new frame until current frame completes\nif (!parsing_active || inAxi4St.tlast) begin\n    byte_counter <= '0;\n    parsing_active <= !inAxi4St.tlast;\nend\n```\n\nKey Timing Considerations:\n1. Register-to-Register Paths:\n   - All combinational logic should meet timing between registers\n   - Critical paths include MAC address assembly logic\n\n2. Handshaking Protocol:\n   - Valid-Ready timing must be maintained\n   - No combinational loops in handshaking logic\n\n3. Output Timing:\n   - MAC addresses must be stable when outParsedValid is high\n   - AXI4-Stream output must maintain protocol timing\n\n4. Reset Timing:\n   - Synchronous reset implementation\n   - All registers reset to known states\n   - Reset must be held for at least one clock cycle\n\nSummary:\n- Synchronous design with single clock domain\n- Synchronous reset implementation\n- Flexible latency based on data width\n- Full AXI4-Stream throughput maintenance\n- Clean handshaking timing\n- Proper frame boundary handling\n- Register-based design for timing closure\n\nThese requirements ensure robust operation while maintaining protocol compliance and proper data extraction.What test scenarios should be considered? How should the module be verified?\n [NEW STEP]\n \nLet me outline a comprehensive verification strategy for this MAC address extractor module:\n\nTest Scenarios:\n\n1. Basic Functionality:\n```systemverilog\n// Single frame with known MAC addresses\ntask test_basic_frame();\n    bit [47:0] test_dest_mac = 48'h112233445566;\n    bit [47:0] test_src_mac = 48'hAABBCCDDEEFF;\n    \n    // Send frame\n    send_frame(test_dest_mac, test_src_mac);\n    \n    // Verify outputs\n    check_mac_addresses(test_dest_mac, test_src_mac);\nendtask\n```\n\n2. Protocol Corner Cases:\n```systemverilog\n// Back-to-back frames\ntask test_back_to_back();\n    // Send multiple frames without gaps\n    repeat(5) begin\n        send_frame(random_mac(), random_mac());\n    end\nendtask\n\n// Ready backpressure\ntask test_backpressure();\n    fork\n        send_frame(random_mac(), random_mac());\n        random_ready_toggle();\n    join\nendtask\n```\n\n3. Error Conditions:\n```systemverilog\n// Incomplete frames\ntask test_incomplete();\n    send_partial_frame();\n    check_no_valid_output();\nendtask\n\n// Reset during frame\ntask test_reset_during_frame();\n    fork\n        send_frame(random_mac(), random_mac());\n        #10 apply_reset();\n    join\n    check_reset_recovery();\nendtask\n```\n\n4. Performance Tests:\n```systemverilog\n// Maximum throughput\ntask test_max_throughput();\n    // Send continuous frames with no gaps\n    fork\n        generate_continuous_frames();\n        measure_throughput();\n    join\nendtask\n\n// Minimum latency\ntask test_latency();\n    time start_time, end_time;\n    start_time = $time;\n    send_frame(random_mac(), random_mac());\n    @(posedge outParsedValid);\n    end_time = $time;\n    check_latency(start_time, end_time);\nendtask\n```\n\nTestbench Components:\n\n1. Interface Definition:\n```systemverilog\ninterface axi4_stream_if #(type T = local_pkg::axi4st_8_s) (input logic clock);\n    T axi4st;\n    logic tready;\n    // Interface methods\n    clocking cb @(posedge clock);\n        // Define sampling points\n    endclocking\nendinterface\n```\n\n2. Stimulus Generator:\n```systemverilog\nclass stimulus_generator;\n    // Generate random frames\n    function automatic logic [47:0] random_mac();\n        return $random();\n    endfunction\n    \n    // Generate various traffic patterns\n    task generate_traffic(int num_frames);\n        // Implementation\n    endtask\nendclass\n```\n\n3. Scoreboard:\n```systemverilog\nclass scoreboard;\n    // Store expected results\n    queue<mac_pair_t> expected_macs;\n    \n    // Compare results\n    function void check_results(\n        logic [47:0] dest_mac,\n        logic [47:0] src_mac\n    );\n        mac_pair_t expected = expected_macs.pop_front();\n        assert(dest_mac == expected.dest_mac);\n        assert(src_mac == expected.src_mac);\n    endfunction\nendclass\n```\n\n4. Coverage:\n```systemverilog\ncovergroup mac_cov;\n    // Cover MAC address ranges\n    dest_mac_cp: coverpoint outParsedDestMac {\n        bins multicast = {48'h01_00_00_00_00_00};\n        bins broadcast = {48'hFF_FF_FF_FF_FF_FF};\n        bins others = default;\n    }\n    \n    // Cover protocol scenarios\n    handshake_cp: coverpoint {inTready, outTready, inAxi4St.tvalid} {\n        bins active = {3'b111};\n        bins stall = {3'b110};\n        bins idle = {3'b000};\n    }\nendgroup\n```\n\n5. Assertions:\n```systemverilog\n// Protocol checks\nproperty valid_ready_handshake;\n    @(posedge clock) disable iff(reset)\n    inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\nendproperty\n\n// Data integrity\nproperty mac_valid_stable;\n    @(posedge clock) disable iff(reset)\n    outParsedValid |-> \n        $stable(outParsedDestMac) && $stable(outParsedSourceMac);\nendproperty\n\nassert property(valid_ready_handshake);\nassert property(mac_valid_stable);\n```\n\nTest Execution Strategy:\n1. Run basic functionality tests first\n2. Follow with corner cases and error conditions\n3. Run performance tests\n4. Execute long random tests\n5. Check coverage and add directed tests as needed\n\nSuccess Criteria:\n1. All assertions pass\n2. 100% functional coverage\n3. No protocol violations\n4. Correct MAC extraction verified\n5. Performance requirements met\n6. Reset behavior confirmed\n7. Error handling verified\n\nThis verification plan ensures thorough testing of both functionality and protocol compliance while covering corner cases and performance requirements.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me break down the necessary test scenarios and assertions for comprehensive verification:\n\nTest Scenarios:\n\n1. Basic Protocol Tests:\n```systemverilog\n// Normal frame transmission\ntask test_basic_protocol();\n    // Single frame with valid handshaking\n    drive_frame(valid_frame);\n    check_handshaking();\n    check_mac_extraction();\nendtask\n\n// Backpressure testing\ntask test_backpressure();\n    // Toggle outTready randomly\n    fork\n        drive_frame(valid_frame);\n        random_backpressure();\n    join\nendtask\n```\n\n2. MAC Address Pattern Tests:\n```systemverilog\n// Special MAC patterns\ntask test_mac_patterns();\n    // Broadcast address\n    test_frame(48'hFFFFFFFFFFFF, random_mac());\n    \n    // Multicast address\n    test_frame(48'h010000000000, random_mac());\n    \n    // Zero address\n    test_frame(48'h000000000000, random_mac());\n    \n    // Incrementing pattern\n    test_frame(48'h010203040506, 48'h0708090A0B0C);\nendtask\n```\n\n3. Frame Size and Timing Tests:\n```systemverilog\n// Back-to-back frames\ntask test_consecutive_frames();\n    repeat(10) begin\n        drive_frame(random_frame());\n        // No gaps between frames\n    end\nendtask\n\n// Variable frame sizes\ntask test_frame_sizes();\n    // Minimum size frame\n    drive_frame(min_frame);\n    \n    // Maximum size frame\n    drive_frame(max_frame);\n    \n    // Random size frames\n    repeat(5) drive_frame(random_size_frame());\nendtask\n```\n\n4. Error and Reset Tests:\n```systemverilog\n// Reset during frame\ntask test_reset_scenarios();\n    fork\n        drive_frame(valid_frame);\n        begin\n            #5 apply_reset();\n        end\n    join\n    check_reset_recovery();\nendtask\n\n// Invalid frame scenarios\ntask test_error_conditions();\n    // Truncated frame\n    drive_partial_frame();\n    \n    // Invalid tkeep patterns\n    drive_frame_invalid_tkeep();\nendtask\n```\n\nAssertions:\n\n1. Protocol Compliance:\n```systemverilog\n// Valid-Ready Handshake\nproperty axi_handshake_p;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\nendproperty\nassert property(axi_handshake_p);\n\n// TLAST must be accompanied by TVALID\nproperty tlast_valid_p;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tlast |-> inAxi4St.tvalid;\nendproperty\nassert property(tlast_valid_p);\n```\n\n2. MAC Extraction Correctness:\n```systemverilog\n// Valid signal timing\nproperty mac_valid_timing_p;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |-> \n        $stable(outParsedDestMac) && $stable(outParsedSourceMac);\nendproperty\nassert property(mac_valid_timing_p);\n\n// Single cycle valid assertion\nproperty single_cycle_valid_p;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |=> !outParsedValid;\nendproperty\nassert property(single_cycle_valid_p);\n```\n\n3. Data Integrity:\n```systemverilog\n// Data stability during stalls\nproperty data_stable_during_stall_p;\n    @(posedge clock) disable iff (reset)\n    (inAxi4St.tvalid && !inTready) |=> $stable(inAxi4St.tdata);\nendproperty\nassert property(data_stable_during_stall_p);\n\n// Output data integrity\nproperty output_data_integrity_p;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid |-> outAxi4St.tdata === $past(inAxi4St.tdata);\nendproperty\nassert property(output_data_integrity_p);\n```\n\n4. Reset Behavior:\n```systemverilog\n// Reset clears all outputs\nproperty reset_outputs_p;\n    @(posedge clock)\n    reset |=> !outParsedValid && !outAxi4St.tvalid;\nendproperty\nassert property(reset_outputs_p);\n\n// Reset state recovery\nproperty reset_recovery_p;\n    @(posedge clock)\n    $rose(reset) |=> ##[1:$] inTready;\nendproperty\nassert property(reset_recovery_p);\n```\n\nCoverage Points:\n\n```systemverilog\ncovergroup protocol_cg;\n    // Handshaking scenarios\n    handshake_cp: coverpoint {inAxi4St.tvalid, inTready, outTready} {\n        bins active = {3'b111};\n        bins input_stall = {3'b110};\n        bins output_stall = {3'b101};\n    }\n    \n    // Frame characteristics\n    frame_cp: coverpoint frame_size {\n        bins small = {[64:100]};\n        bins medium = {[101:1000]};\n        bins large = {[1001:1518]};\n    }\n    \n    // MAC address patterns\n    mac_cp: coverpoint outParsedDestMac {\n        bins broadcast = {48'hFFFFFFFFFFFF};\n        bins multicast = {48'h010000000000};\n        bins unicast = default;\n    }\nendgroup\n```\n\nTest Environment Features:\n1. Random stimulus generation\n2. Protocol checker\n3. Reference model for MAC extraction\n4. Scoreboard for result comparison\n5. Coverage collection\n6. Performance monitoring\n\nSuccess Criteria:\n1. All assertions pass\n2. 100% functional coverage achieved\n3. All test scenarios complete successfully\n4. No protocol violations detected\n5. Correct MAC extraction verified\n6. Reset behavior confirmed\n7. Performance requirements met\n\nThis comprehensive verification approach ensures thorough testing of functionality, protocol compliance, and error handling while maintaining high confidence in the design's correctness.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. AXI4-Stream Protocol Handler:\n```systemverilog\nmodule axi4_stream_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    // Handles AXI4-Stream protocol compliance\n    // Manages handshaking\n    // Implements backpressure logic\n    // Ensures data pipeline flow\nendmodule\n```\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        mac_valid\n);\n    // Tracks byte position in frame\n    // Assembles MAC addresses\n    // Handles big-endian byte ordering\n    // Generates valid signal\nendmodule\n```\n\n3. Frame State Controller:\n```systemverilog\nmodule frame_state_controller (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic tlast,\n    output logic parsing_active,\n    output logic [3:0] byte_counter\n);\n    // Tracks frame boundaries\n    // Maintains byte counter\n    // Controls parsing state\n    // Handles reset conditions\nendmodule\n```\n\n4. Pipeline Controller:\n```systemverilog\nmodule pipeline_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType data_in,\n    input  logic        in_ready,\n    output AxiStreamType data_out,\n    input  logic        out_ready,\n    output logic        pipeline_valid\n);\n    // Manages data pipeline stages\n    // Handles stall conditions\n    // Ensures data alignment\n    // Controls timing\nendmodule\n```\n\nIntegration of Submodules:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // AXI4-Stream interfaces\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    // Extracted MAC addresses\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac,\n    output logic        outParsedValid\n);\n\n    // Internal signals\n    logic parsing_active;\n    logic [3:0] byte_counter;\n    logic pipeline_valid;\n    \n    // Instantiate submodules\n    axi4_stream_handler u_axi4_handler (\n        .clock(clock),\n        .reset(reset),\n        // ... ports\n    );\n    \n    mac_extractor u_mac_extractor (\n        .clock(clock),\n        .reset(reset),\n        // ... ports\n    );\n    \n    frame_state_controller u_frame_ctrl (\n        .clock(clock),\n        .reset(reset),\n        // ... ports\n    );\n    \n    pipeline_controller u_pipeline_ctrl (\n        .clock(clock),\n        .reset(reset),\n        // ... ports\n    );\n\nendmodule\n```\n\nSpecific Tasks per Submodule:\n\n1. AXI4-Stream Protocol Handler:\n- Manages valid/ready handshaking\n- Controls backpressure\n- Ensures protocol compliance\n- Maintains data flow\n\n2. MAC Address Extractor:\n- Processes incoming bytes\n- Assembles destination MAC\n- Assembles source MAC\n- Generates extraction complete signal\n- Handles byte ordering\n\n3. Frame State Controller:\n- Tracks frame boundaries\n- Maintains byte position counter\n- Controls parsing state machine\n- Handles reset conditions\n- Manages frame synchronization\n\n4. Pipeline Controller:\n- Manages data pipeline stages\n- Handles stall conditions\n- Ensures proper timing\n- Controls data alignment\n- Manages pipeline latency\n\nBenefits of This Modular Approach:\n1. Better maintainability\n2. Easier testing of individual components\n3. Clear separation of concerns\n4. Simplified debugging\n5. Reusable components\n6. Better timing closure\n7. Easier to modify individual functions\n\nEach submodule has a specific, well-defined task that contributes to the overall functionality while maintaining clean interfaces and clear responsibilities.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write the SystemVerilog code for each submodule and identify critical interfaces:\n\n1. AXI4-Stream Protocol Handler:\n```systemverilog\nmodule axi4_stream_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // Input AXI4-Stream interface\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    // Output AXI4-Stream interface\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    // Interface to MAC extractor\n    output logic [7:0]  data_to_extractor,\n    output logic        data_valid,\n    // Pipeline control\n    input  logic        pipeline_ready\n);\n\n    // Register stage for output\n    AxiStreamType outAxi4St_reg;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outAxi4St_reg <= '0;\n        end\n        else if (outTready) begin\n            outAxi4St_reg <= inAxi4St;\n        end\n    end\n    \n    // Handshaking logic\n    assign inTready = outTready || !outAxi4St_reg.tvalid;\n    assign outAxi4St = outAxi4St_reg;\n    \n    // Data to MAC extractor\n    assign data_to_extractor = inAxi4St.tdata;\n    assign data_valid = inAxi4St.tvalid && inTready;\n\nendmodule\n```\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // Data input interface\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    // Control interface\n    input  logic [3:0]  byte_counter,\n    input  logic        parsing_active,\n    // Output interface\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        mac_valid\n);\n\n    // MAC address registers\n    logic [47:0] dest_mac_reg, src_mac_reg;\n    logic        mac_valid_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac_reg <= '0;\n            src_mac_reg <= '0;\n            mac_valid_reg <= '0;\n        end\n        else if (data_valid && parsing_active) begin\n            // Destination MAC assembly\n            if (byte_counter < 6) begin\n                dest_mac_reg <= {dest_mac_reg[39:0], data_in};\n            end\n            // Source MAC assembly\n            else if (byte_counter < 12) begin\n                src_mac_reg <= {src_mac_reg[39:0], data_in};\n            end\n            \n            // Set valid when complete\n            mac_valid_reg <= (byte_counter == 11);\n        end\n        else begin\n            mac_valid_reg <= '0;\n        end\n    end\n\n    // Output assignments\n    assign dest_mac = dest_mac_reg;\n    assign src_mac = src_mac_reg;\n    assign mac_valid = mac_valid_reg;\n\nendmodule\n```\n\n3. Frame State Controller:\n```systemverilog\nmodule frame_state_controller (\n    input  logic        clock,\n    input  logic        reset,\n    // AXI4-Stream control signals\n    input  logic        tvalid,\n    input  logic        tlast,\n    input  logic        tready,\n    // State outputs\n    output logic        parsing_active,\n    output logic [3:0]  byte_counter\n);\n\n    logic parsing_active_reg;\n    logic [3:0] byte_counter_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            parsing_active_reg <= '0;\n            byte_counter_reg <= '0;\n        end\n        else if (tvalid && tready) begin\n            if (!parsing_active_reg || tlast) begin\n                byte_counter_reg <= '0;\n                parsing_active_reg <= !tlast;\n            end\n            else begin\n                byte_counter_reg <= byte_counter_reg + 1'b1;\n            end\n        end\n    end\n\n    // Output assignments\n    assign parsing_active = parsing_active_reg;\n    assign byte_counter = byte_counter_reg;\n\nendmodule\n```\n\n4. Pipeline Controller:\n```systemverilog\nmodule pipeline_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // Pipeline control\n    input  AxiStreamType data_in,\n    input  logic        in_ready,\n    output AxiStreamType data_out,\n    input  logic        out_ready,\n    // MAC extraction interface\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] src_mac,\n    input  logic        mac_valid,\n    // Output interface\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac,\n    output logic        outParsedValid\n);\n\n    // Pipeline registers\n    AxiStreamType data_pipe;\n    logic [47:0] dest_mac_pipe, src_mac_pipe;\n    logic        mac_valid_pipe;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            data_pipe <= '0;\n            dest_mac_pipe <= '0;\n            src_mac_pipe <= '0;\n            mac_valid_pipe <= '0;\n        end\n        else if (out_ready) begin\n            data_pipe <= data_in;\n            dest_mac_pipe <= dest_mac;\n            src_mac_pipe <= src_mac;\n            mac_valid_pipe <= mac_valid;\n        end\n    end\n\n    // Output assignments\n    assign data_out = data_pipe;\n    assign outParsedDestMac = dest_mac_pipe;\n    assign outParsedSourceMac = src_mac_pipe;\n    assign outParsedValid = mac_valid_pipe;\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between AXI4-Stream Handler and MAC Extractor:\n```systemverilog\n// Data path\nlogic [7:0] data_to_extractor;\nlogic       data_valid;\n```\n\n2. Between Frame State Controller and MAC Extractor:\n```systemverilog\n// Control signals\nlogic [3:0] byte_counter;\nlogic       parsing_active;\n```\n\n3. Between MAC Extractor and Pipeline Controller:\n```systemverilog\n// Extracted MAC addresses\nlogic [47:0] dest_mac;\nlogic [47:0] src_mac;\nlogic        mac_valid;\n```\n\n4. Common Control Signals:\n```systemverilog\n// Global control\nlogic clock;\nlogic reset;\n```\n\nInterface Considerations:\n1. Timing alignment between modules\n2. Handshaking synchronization\n3. Data validity maintenance\n4. Pipeline stall propagation\n5. Reset synchronization\n6. Frame boundary handling\n\nThese interfaces need careful timing consideration and proper handshaking to ensure reliable operation of the complete system.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output sometime after the first data phit on inAxi4St.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- outParsedValid should be 1 for a single cycle when outParsedDestMac and outParsedSourceMac are valid.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_eth_parser_lite_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_eth_parser_lite_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// -- Custom testbench for ./dut.sv\n// -- Only checks outParsedValid, and that outAxi4St is correct.\n// -- Does not check that outParsedValid=1 on first data phit of outAxi4St.\n// -- Uses ./dut.sv.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  // TODO(drew): This check is removed for this test.\n  ////`OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  logic                 prev_outParsedValid;\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    prev_outParsedValid <= outParsedValid; // add this hook so we only look at this once per frame.\n    if (!reset && outParsedValid && !prev_outParsedValid) begin\n      // In this tb, we skip the outTready=1 qualifier.\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: observed outParsedDestMac=0x%0x outParsedSourceMac=0x%0x\",\n                 $realtime, outParsedDestMac, outParsedSourceMac);\n      end\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_lite_2"
  },
  {
    "index": 4,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic         clock,\n    input  logic         reset,\n    input  AxiStreamType inAxi4St,\n    output logic         inTready,\n    output AxiStreamType outAxi4St, \n    input  logic         outTready,\n    output logic         outParsedValid,\n    output logic [47:0]  outParsedDestMac,\n    output logic [47:0]  outParsedSourceMac\n);\n\n    // Local parameters\n    localparam int unsigned BYTES_PER_MAC = 6;\n    localparam int unsigned TOTAL_MAC_BYTES = 2 * BYTES_PER_MAC;\n    localparam int unsigned COUNTER_WIDTH = $clog2(TOTAL_MAC_BYTES + 1);\n    localparam int unsigned REQUIRED_STAGES = (TOTAL_MAC_BYTES/AxiStreamWidth) - 1;\n\n    // Internal signals\n    logic frame_start, in_packet;\n    logic [COUNTER_WIDTH-1:0] byte_counter;\n    logic parsing_active;\n    logic extraction_done;\n    logic [47:0] dest_mac_reg;\n    logic [47:0] src_mac_reg;\n\n    // Frame start detection\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .tfirst(frame_start),\n        .in_packet(in_packet)\n    );\n\n    // MAC address extraction\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac_reg <= '0;\n            src_mac_reg <= '0;\n            byte_counter <= '0;\n            parsing_active <= '0;\n            extraction_done <= '0;\n        end else if (inAxi4St.tvalid && inTready) begin\n            if (frame_start) begin\n                parsing_active <= 1'b1;\n                byte_counter <= '0;\n                dest_mac_reg[47:40] <= inAxi4St.tdata;\n                extraction_done <= 1'b0;\n            end else if (parsing_active && byte_counter < TOTAL_MAC_BYTES-1) begin\n                byte_counter <= byte_counter + 1'b1;\n                case (byte_counter)\n                    0: dest_mac_reg[39:32] <= inAxi4St.tdata;\n                    1: dest_mac_reg[31:24] <= inAxi4St.tdata;\n                    2: dest_mac_reg[23:16] <= inAxi4St.tdata;\n                    3: dest_mac_reg[15:8]  <= inAxi4St.tdata;\n                    4: dest_mac_reg[7:0]   <= inAxi4St.tdata;\n                    5: src_mac_reg[47:40]  <= inAxi4St.tdata;\n                    6: src_mac_reg[39:32]  <= inAxi4St.tdata;\n                    7: src_mac_reg[31:24]  <= inAxi4St.tdata;\n                    8: src_mac_reg[23:16]  <= inAxi4St.tdata;\n                    9: src_mac_reg[15:8]   <= inAxi4St.tdata;\n                    10: begin\n                        src_mac_reg[7:0]   <= inAxi4St.tdata;\n                        extraction_done <= 1'b1;\n                        parsing_active <= 1'b0;\n                    end\n                endcase\n            end\n        end\n    end\n\n    // Pipeline for aligning output data\n    AxiStreamType [REQUIRED_STAGES:0] pipeAxi4St;\n    logic [REQUIRED_STAGES:0] pipeTready;\n\n    local_axist_pipe #(\n        .NumStages(REQUIRED_STAGES),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .pipeAxi4St(pipeAxi4St),\n        .pipeTready(pipeTready),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\n\n    // Output control logic\n    logic tfirst_out, in_packet_out;\n\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst_out (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(outAxi4St),\n        .inTready(outTready),\n        .tfirst(tfirst_out),\n        .in_packet(in_packet_out)\n    );\n\n    // Output valid control and MAC assignment\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end else begin\n            if (tfirst_out && outAxi4St.tvalid) begin\n                outParsedValid <= 1'b1;\n                outParsedDestMac <= dest_mac_reg;\n                outParsedSourceMac <= src_mac_reg;\n            end else begin\n                outParsedValid <= 1'b0;\n            end\n        end\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\nAdditionally, you are required to use the folowing module (internal contents not shown) to determine when a packet or frame starts.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining when to start parsing or extracting contents from a frame. For example:\n\nlogic first_byte_of_dest_mac_valid; // if 1, indicates dest mac [47:40] present on inAxi4St.tdata.\nassign first_byte_of_dest_mac_valid = tfirst && in_packet;\n\n\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\n1. The module is designed to parse/extract MAC addresses from Ethernet frames that are being transmitted over an AXI4-Stream interface\n2. Specifically, it needs to:\n   - Extract the 6-byte Destination MAC address\n   - Extract the 6-byte Source MAC address\n   - Output these MAC addresses aligned with the first data beat of the output stream\n   - Pass through the original data stream (delayed as needed)\n\nHigh-Level Block Diagram:\n```\n                                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                           \u2502  MAC Address    \u2502\n                                           \u2502   Registers     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502  outParsedDestMac\n                                                   \u2502              \u2502  outParsedSourceMac\n                                                   \u2502              \u2502  outParsedValid\n                                                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          \u2502    \u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 Input    \u251c\u2500\u2500\u2500\u25ba\u2502 Frame Start    \u251c\u2500\u2500\u2500\u25ba\u2502 MAC Address    \u251c\u2500\u2500\u2500\u25ba\u2502 AXI4-Stream    \u251c\u2500\u2500\u2500\u2500\u25baOutput\n\u2502 AXI4-    \u2502    \u2502 Detection      \u2502    \u2502 Extraction     \u2502    \u2502 Delay Pipeline \u2502    AXI4-\n\u2502 Stream   \u2502    \u2502 (tfirst)       \u2502    \u2502 Logic         \u2502    \u2502                \u2502    Stream\n\u2502          \u2502    \u2502                 \u2502    \u2502               \u2502    \u2502                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nKey Components:\n1. Frame Start Detection: Uses local_axist_tfirst to identify the start of new frames\n2. MAC Address Extraction: Logic to capture and store the MAC addresses\n3. AXI4-Stream Delay Pipeline: Uses local_axist_pipe to delay the output stream as needed\n4. Output Logic: Aligns the extracted MAC addresses with the first beat of the output stream\n\nThe complexity of the implementation depends on the AXI4-Stream data width (parameter AxiStreamWidth). For 8-bit width, it needs to collect 12 consecutive bytes, while for wider buses (e.g., 128-bit), it might be able to extract both MAC addresses in a single cycle.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nKey Parameters:\n1. AXI Stream Type (AxiStreamType)\n- Default: local_pkg::axi4st_8_s\n- This defines the structure of the AXI Stream interface\n- Includes tdata, tkeep, tuser, tlast, and tvalid signals\n\n2. AXI Stream Width (AxiStreamWidth)\n- Default: 8 bits\n- Should match the tdata width in AxiStreamType\n- Common values: 8, 16, 32, 64, 128 bits\n- Affects how many cycles needed to extract MAC addresses\n\n3. Pipeline Stages (for local_axist_pipe)\n- Needed to align MAC extraction with output stream\n- For 8-bit width: minimum 11 stages needed\n- For wider buses: fewer stages required\n- Should be calculated based on AxiStreamWidth:\n```systemverilog\nlocalparam int unsigned RequiredStages = (96/AxiStreamWidth) - 1;\n```\n\nOther Important Parameters to Consider:\n1. MAC Address Width\n- Fixed at 48 bits (6 bytes) as per Ethernet standard\n- Could be defined as a localparam:\n```systemverilog\nlocalparam int unsigned MacAddrWidth = 48;\n```\n\n2. Extraction Counter Width\n- Width depends on AxiStreamWidth\n- For counting bytes received:\n```systemverilog\nlocalparam int unsigned CounterWidth = $clog2(96/AxiStreamWidth);\n```\n\nExample Parameter Configuration:\n```systemverilog\nmodule dut #(\n    // Primary parameters\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8,\n    \n    // Derived parameters\n    localparam int unsigned MacAddrWidth = 48,\n    localparam int unsigned RequiredStages = (96/AxiStreamWidth) - 1,\n    localparam int unsigned CounterWidth = $clog2(96/AxiStreamWidth)\n) (\n    // ports...\n);\n```\n\nThe parameterization should:\n1. Support different AXI Stream widths\n2. Automatically adjust pipeline depths\n3. Maintain correct MAC address extraction regardless of bus width\n4. Keep Ethernet standard compliance\n5. Allow for efficient resource utilizationHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n1. MAC Address Extraction Logic:\n```systemverilog\n// Registers for MAC addresses\nlogic [47:0] dest_mac_reg;   // Destination MAC storage\nlogic [47:0] src_mac_reg;    // Source MAC storage\nlogic [3:0]  byte_counter;   // Track bytes received\nlogic        parsing_active;  // Indicates active parsing state\n\n// For 8-bit implementation example:\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        dest_mac_reg <= '0;\n        src_mac_reg <= '0;\n        byte_counter <= '0;\n        parsing_active <= '0;\n    end else if (inAxi4St.tvalid && inTready) begin\n        if (tfirst) begin\n            parsing_active <= 1'b1;\n            byte_counter <= '0;\n            dest_mac_reg[47:40] <= inAxi4St.tdata;\n        end else if (parsing_active && byte_counter < 11) begin\n            byte_counter <= byte_counter + 1'b1;\n            case (byte_counter)\n                // Destination MAC\n                0: dest_mac_reg[39:32] <= inAxi4St.tdata;\n                1: dest_mac_reg[31:24] <= inAxi4St.tdata;\n                2: dest_mac_reg[23:16] <= inAxi4St.tdata;\n                3: dest_mac_reg[15:8]  <= inAxi4St.tdata;\n                4: dest_mac_reg[7:0]   <= inAxi4St.tdata;\n                // Source MAC\n                5: src_mac_reg[47:40]  <= inAxi4St.tdata;\n                6: src_mac_reg[39:32]  <= inAxi4St.tdata;\n                7: src_mac_reg[31:24]  <= inAxi4St.tdata;\n                8: src_mac_reg[23:16]  <= inAxi4St.tdata;\n                9: src_mac_reg[15:8]   <= inAxi4St.tdata;\n                10: src_mac_reg[7:0]   <= inAxi4St.tdata;\n            endcase\n        end\n    end\nend\n```\n\n2. Output Alignment Logic:\n```systemverilog\n// Pipeline control\nAxiStreamType [RequiredStages:0] pipeAxi4St;\nlogic [RequiredStages:0] pipeTready;\n\n// Instance of delay pipeline\nlocal_axist_pipe #(\n    .NumStages(RequiredStages),\n    .AxiStreamType(AxiStreamType)\n) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .pipeAxi4St(pipeAxi4St),\n    .pipeTready(pipeTready),\n    .outAxi4St(outAxi4St),\n    .outTready(outTready)\n);\n```\n\n3. Output Control Logic:\n```systemverilog\n// Frame start detection\nlogic tfirst, in_packet;\nlocal_axist_tfirst #(\n    .AxiStreamType(AxiStreamType)\n) u_tfirst (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(outAxi4St),\n    .inTready(outTready),\n    .tfirst(tfirst),\n    .in_packet(in_packet)\n);\n\n// Output valid control\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        outParsedValid <= 1'b0;\n    end else begin\n        outParsedValid <= tfirst && outAxi4St.tvalid;\n    end\nend\n\n// Output MAC assignments\nassign outParsedDestMac = dest_mac_reg;\nassign outParsedSourceMac = src_mac_reg;\n```\n\nRequired Registers:\n1. MAC Address Storage:\n- dest_mac_reg[47:0]\n- src_mac_reg[47:0]\n\n2. Control Registers:\n- byte_counter\n- parsing_active\n- outParsedValid\n\nRequired Combinational Logic:\n1. Counter Control:\n- Increment logic for byte_counter\n- Reset conditions\n\n2. MAC Assembly Logic:\n- Byte positioning based on counter\n- Big-endian assembly logic\n\n3. Pipeline Control:\n- Ready/valid handshaking\n- Frame alignment logic\n\n4. Output Alignment:\n- First beat detection\n- MAC address output timing\n\nThe design must handle:\n1. Proper byte ordering (Big Endian)\n2. Pipeline delays for alignment\n3. AXI4-Stream protocol compliance\n4. Reset conditions\n5. Valid/ready handshakingWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me break down the timing and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain\n- All logic is synchronous to the input 'clock'\n- No clock domain crossing needed\n- Single positive edge triggered design\n\nReset Requirements:\n1. Synchronous Reset (explicitly specified)\n- Active high reset signal\n- All sequential elements should reset synchronously\n- Reset must initialize:\n  * MAC address registers (dest_mac_reg, src_mac_reg)\n  * Control counters (byte_counter)\n  * State flags (parsing_active)\n  * Output valid signals (outParsedValid)\n  * Pipeline stages (through local_axist_pipe)\n\nLatency Requirements:\n1. Minimum Latency:\n- Depends on AxiStreamWidth\n- For 8-bit: 11 cycles minimum (to capture 12 bytes)\n- For wider buses: Proportionally less\n```systemverilog\nlocalparam int unsigned MinLatency = (96/AxiStreamWidth) - 1;\n```\n\n2. Maximum Latency:\n- Not explicitly specified\n- Should be minimized for efficient operation\n- Determined by pipeline depth (RequiredStages)\n\nThroughput Requirements:\n1. AXI4-Stream Protocol:\n- Must maintain full throughput (1 transfer per cycle)\n- No artificial stalling allowed\n- Ready/Valid handshaking must be preserved\n\nExample Timing Implementation:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic         clock,\n    input  logic         reset,\n    // ... other ports ...\n);\n\n    // Reset all registers synchronously\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac_reg <= '0;\n            src_mac_reg <= '0;\n            byte_counter <= '0;\n            parsing_active <= '0;\n            outParsedValid <= '0;\n        end else begin\n            // Normal operation logic\n        end\n    end\n\n    // Maintain throughput with ready/valid handshaking\n    assign inTready = pipeTready[0];  // Backpressure from pipeline\n```\n\nCritical Timing Paths:\n1. MAC Address Assembly:\n```systemverilog\n    // Register MAC bytes with minimal logic between stages\n    always_ff @(posedge clock) begin\n        if (inAxi4St.tvalid && inTready) begin\n            if (tfirst) begin\n                dest_mac_reg[47:40] <= inAxi4St.tdata;\n            end else if (parsing_active) begin\n                // ... sequential byte assembly ...\n            end\n        end\n    end\n```\n\n2. Pipeline Staging:\n- Handled by local_axist_pipe module\n- Ensures proper timing margins\n- Maintains AXI4-Stream protocol timing\n\nPerformance Considerations:\n1. Zero-bubble Operation:\n- No artificial stalls\n- Continuous streaming when ready\n- Full throughput during packet transfer\n\n2. Back-pressure Handling:\n- Must respond to outTready\n- Propagate through pipeline\n- Maintain data integrity\n\nReset Strategy:\n1. Synchronous Reset Elements:\n- All state registers\n- Pipeline stages\n- Control flags\n- Counter values\n\n2. No Reset Required:\n- Combinational logic\n- Pure wire assignments\n- Constant values\n\nThe design should:\n1. Meet timing with reasonable clock frequencies\n2. Maintain protocol compliance\n3. Handle back-pressure properly\n4. Reset to a known good state\n5. Provide consistent latency based on bus widthWhat verification and debug features should be added? How would you verify and test this design?\n [NEW STEP]\n \nLet me outline a comprehensive verification and debug strategy:\n\n1. Design Assertions:\n```systemverilog\n// Protocol Checks\nproperty p_valid_ready_handshake;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\nendproperty\nassert property(p_valid_ready_handshake);\n\n// MAC Extraction Checks\nproperty p_mac_valid_timing;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |-> outAxi4St.tvalid && tfirst;\nendproperty\nassert property(p_mac_valid_timing);\n\n// Byte Counter Checks\nassert property(@(posedge clock)\n    (byte_counter <= (96/AxiStreamWidth)));\n```\n\n2. Debug Counters and Flags:\n```systemverilog\n// Debug interface\ninterface debug_if;\n    logic [31:0] packets_processed;\n    logic [31:0] current_byte_count;\n    logic        parsing_error;\n    logic [7:0]  state;\nendinterface\n\n// Implementation\nlogic [31:0] dbg_packet_counter;\nalways_ff @(posedge clock) begin\n    if (reset)\n        dbg_packet_counter <= '0;\n    else if (outAxi4St.tvalid && outAxi4St.tlast)\n        dbg_packet_counter <= dbg_packet_counter + 1'b1;\nend\n```\n\n3. Testbench Structure:\n```systemverilog\nmodule tb_dut;\n    // Test stimulus generation\n    class ethernet_packet;\n        rand bit [47:0] dest_mac;\n        rand bit [47:0] src_mac;\n        rand bit [7:0]  payload[$];\n        \n        constraint valid_payload_size {\n            payload.size() inside {[46:1500]};\n        }\n    endclass\n\n    // Scoreboard\n    class scoreboard;\n        ethernet_packet exp_queue[$];\n        \n        function void check_mac(\n            logic [47:0] exp_dest, logic [47:0] exp_src,\n            logic [47:0] act_dest, logic [47:0] act_src);\n            \n            assert(exp_dest == act_dest) else\n                $error(\"Destination MAC mismatch\");\n            assert(exp_src == act_src) else\n                $error(\"Source MAC mismatch\");\n        endfunction\n    endclass\nendmodule\n```\n\n4. Test Scenarios:\n```systemverilog\n// Test cases\ninitial begin\n    // Basic functionality\n    test_single_packet();\n    \n    // Corner cases\n    test_minimum_size_packet();\n    test_maximum_size_packet();\n    \n    // Error conditions\n    test_backpressure();\n    test_invalid_packet();\n    \n    // Performance\n    test_back_to_back_packets();\n    test_random_delays();\nend\n\ntask test_backpressure();\n    // Randomly assert/deassert outTready\n    fork\n        drive_packet();\n        random_backpressure();\n    join\nendtask\n```\n\n5. Coverage Plan:\n```systemverilog\ncovergroup cg_mac_parser @(posedge clock);\n    // Input coverage\n    cp_tdata: coverpoint inAxi4St.tdata {\n        bins first_byte = {[0:255]};\n        bins other_bytes = {[0:255]};\n    }\n    \n    // State coverage\n    cp_state: coverpoint byte_counter {\n        bins all_states[] = {[0:11]};\n        bins transitions = (0 => 1 => 2);\n    }\n    \n    // Cross coverage\n    cross cp_tdata, cp_state;\nendgroup\n```\n\n6. Bus Functional Model:\n```systemverilog\nclass axi4_stream_bfm;\n    virtual axi4_stream_if vif;\n    \n    task send_packet(input byte data[]);\n        foreach(data[i]) begin\n            @(posedge vif.clock);\n            vif.tdata <= data[i];\n            vif.tvalid <= 1'b1;\n            vif.tlast <= (i == data.size()-1);\n            wait(vif.tready);\n        end\n    endtask\nendclass\n```\n\n7. Error Injection:\n```systemverilog\ntask inject_errors();\n    // Corrupt MAC addresses\n    force dut.dest_mac_reg = 48'hDEADBEEF;\n    \n    // Create protocol violations\n    force dut.inAxi4St.tvalid = 0;\n    #10;\n    release dut.inAxi4St.tvalid;\nendtask\n```\n\nVerification Strategy:\n1. Unit Level Testing:\n- Basic functionality verification\n- Protocol compliance checking\n- Corner case testing\n\n2. Integration Testing:\n- System-level interaction\n- Back-pressure handling\n- Timing verification\n\n3. Performance Testing:\n- Throughput measurement\n- Latency verification\n- Resource utilization\n\n4. Regression Testing:\n- Random packet generation\n- Extended runs\n- Stress testing\n\nDebug Features:\n1. Status Registers\n2. Performance Counters\n3. State Machine Monitoring\n4. Protocol Violation Detection\n5. Error Flags and Counters\n\nThe verification environment should:\n1. Provide comprehensive coverage\n2. Detect protocol violations\n3. Verify timing requirements\n4. Test corner cases\n5. Measure performanceAre there any potential problems or issues that need to be addressed? What are the main design challenges and risks?\n [NEW STEP]\n \nLet me outline the potential problems, design challenges, and risks:\n\n1. Protocol Compliance Challenges:\n```systemverilog\n// Issue: AXI4-Stream Protocol Violations\n// Risk: Dropping valid data or creating bubbles\nalways_ff @(posedge clock) begin\n    if (inAxi4St.tvalid && !inTready) begin\n        // Must maintain tdata, tvalid until accepted\n        // Could lose data if not handled properly\n    end\nend\n\n// Solution: Proper handshaking implementation\nassign inTready = pipeTready[0] && !parsing_error;\n```\n\n2. Timing and Latency Issues:\n```systemverilog\n// Issue: Variable Latency with Different Bus Widths\nlocalparam int unsigned REQUIRED_BYTES = 12;\nlocalparam int unsigned CYCLES_NEEDED = (REQUIRED_BYTES + AxiStreamWidth - 1) / AxiStreamWidth;\n\n// Risk: Improper pipeline depth calculation\nlogic [CYCLES_NEEDED-1:0] valid_bytes;\nalways_ff @(posedge clock) begin\n    // Must account for all possible bus widths\n    // Could miss data if pipeline depth is wrong\nend\n```\n\n3. Data Alignment Problems:\n```systemverilog\n// Issue: Big Endian to Little Endian Conversion\n// Risk: Byte ordering mistakes\nalways_comb begin\n    // For 32-bit bus example\n    case (byte_counter)\n        0: begin\n            dest_mac_reg[47:16] <= inAxi4St.tdata;\n            alignment_error <= 0;\n        end\n        1: begin\n            dest_mac_reg[15:0] <= inAxi4St.tdata[31:16];\n            src_mac_reg[47:32] <= inAxi4St.tdata[15:0];\n        end\n        default: alignment_error <= 1;\n    endcase\nend\n```\n\n4. Reset and Recovery Issues:\n```systemverilog\n// Issue: Incomplete Reset State\n// Risk: Stuck states or invalid data\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        dest_mac_reg <= '0;\n        src_mac_reg <= '0;\n        byte_counter <= '0;\n        parsing_active <= '0;\n        // Need to reset ALL state elements\n    end\nend\n```\n\n5. Back-Pressure Handling:\n```systemverilog\n// Issue: Back-pressure propagation\n// Risk: Data corruption or loss\nmodule dut #(/*parameters*/) (\n    // Need proper backpressure handling\n    output logic inTready,\n    input  logic outTready\n);\n\n// Solution: Pipeline ready signals\nassign inTready = outTready && !pipeline_full && !parsing_error;\n```\n\n6. Corner Cases and Edge Conditions:\n```systemverilog\n// Issue: Handling partial transfers\n// Risk: Incomplete MAC address extraction\nlogic packet_error;\nalways_ff @(posedge clock) begin\n    if (inAxi4St.tvalid && inAxi4St.tlast) begin\n        if (byte_counter < (REQUIRED_BYTES-1)) begin\n            packet_error <= 1'b1;\n            // Need error handling for short packets\n        end\n    end\nend\n```\n\nMain Design Challenges:\n\n1. Bus Width Handling:\n- Supporting multiple bus widths\n- Proper alignment for different widths\n- Efficient resource utilization\n```systemverilog\n// Parameterized implementation\ngenerate\n    if (AxiStreamWidth == 8) begin : g_8bit\n        // 8-bit specific logic\n    end else if (AxiStreamWidth == 32) begin : g_32bit\n        // 32-bit specific logic\n    end\nendgenerate\n```\n\n2. Performance Optimization:\n- Minimizing latency\n- Maintaining throughput\n- Resource efficiency\n```systemverilog\n// Performance monitoring\nlogic [31:0] cycle_counter;\nlogic [31:0] valid_transfers;\nalways_ff @(posedge clock) begin\n    if (inAxi4St.tvalid && inTready)\n        valid_transfers <= valid_transfers + 1;\nend\n```\n\n3. Error Recovery:\n- Handling protocol violations\n- Recovering from invalid states\n- Maintaining data integrity\n```systemverilog\n// Error detection and recovery\ntypedef enum logic [2:0] {\n    ERROR_NONE,\n    ERROR_SHORT_PACKET,\n    ERROR_PROTOCOL_VIOLATION,\n    ERROR_ALIGNMENT\n} error_t;\n\nerror_t current_error;\nlogic need_recovery;\n```\n\nRisk Mitigation Strategies:\n\n1. Robust Error Handling:\n```systemverilog\n// Comprehensive error detection\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        error_status <= '0;\n    end else begin\n        if (protocol_error) error_status.protocol <= 1'b1;\n        if (alignment_error) error_status.alignment <= 1'b1;\n        if (timing_error) error_status.timing <= 1'b1;\n    end\nend\n```\n\n2. Design for Debug:\n```systemverilog\n// Debug interface\ninterface debug_if;\n    logic [31:0] error_counter;\n    logic [31:0] packet_counter;\n    logic [7:0]  current_state;\n    logic        pipeline_full;\nendinterface\n```\n\n3. Parameterization Checks:\n```systemverilog\n// Parameter validation\ninitial begin\n    assert(AxiStreamWidth inside {8, 16, 32, 64, 128})\n    else $error(\"Invalid AxiStreamWidth\");\n    \n    assert(AxiStreamWidth <= 128)\n    else $error(\"AxiStreamWidth too large\");\nend\n```\n\nThe design must address:\n1. Protocol compliance\n2. Timing constraints\n3. Data alignment\n4. Error handling\n5. Performance requirements\n6. Debug capability\n7. Parameterization support\n8. Resource utilizationWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline comprehensive test scenarios and assertions needed for verification:\n\n1. Basic Protocol Assertions:\n```systemverilog\n// AXI4-Stream Protocol Assertions\nmodule dut_assertions (\n    input clock, reset,\n    input AxiStreamType inAxi4St, outAxi4St,\n    input logic inTready, outTready\n);\n\n    // Valid/Ready Handshaking\n    property p_valid_stable;\n        @(posedge clock) disable iff (reset)\n        inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\n    endproperty\n    assert property(p_valid_stable) else\n        $error(\"Valid dropped before ready\");\n\n    // TLAST must be with valid\n    property p_tlast_valid;\n        @(posedge clock) disable iff (reset)\n        inAxi4St.tlast |-> inAxi4St.tvalid;\n    endproperty\n    assert property(p_tlast_valid);\n\n    // No gaps in packet\n    property p_no_gaps;\n        @(posedge clock) disable iff (reset)\n        (inAxi4St.tvalid && inTready && !inAxi4St.tlast) |=>\n        inAxi4St.tvalid;\n    endproperty\n    assert property(p_no_gaps);\n```\n\n2. Functional Test Scenarios:\n```systemverilog\nclass mac_parser_tests;\n    // Basic packet test\n    task test_single_packet;\n        ethernet_packet pkt;\n        pkt = new();\n        pkt.randomize() with {\n            payload.size() == 64;\n        };\n        drive_packet(pkt);\n        check_mac_output(pkt.dest_mac, pkt.src_mac);\n    endtask\n\n    // Back-to-back packets\n    task test_consecutive_packets;\n        repeat(100) begin\n            test_single_packet();\n            #1; // No gap between packets\n        end\n    endtask\n\n    // Minimum size packet\n    task test_min_packet;\n        ethernet_packet pkt;\n        pkt = new();\n        pkt.randomize() with {\n            payload.size() == 46; // Minimum Ethernet payload\n        };\n        drive_packet(pkt);\n    endtask\n```\n\n3. Corner Case Tests:\n```systemverilog\n    // Backpressure testing\n    task test_backpressure;\n        fork\n            begin\n                test_single_packet();\n            end\n            begin\n                repeat(10) begin\n                    outTready <= 0;\n                    #5;\n                    outTready <= 1;\n                    #3;\n                end\n            end\n        join\n    endtask\n\n    // Error injection\n    task test_error_conditions;\n        // Incomplete packet\n        drive_partial_packet();\n        \n        // Invalid timing\n        drive_invalid_timing();\n        \n        // Protocol violations\n        drive_protocol_violations();\n    endtask\n```\n\n4. Functional Coverage:\n```systemverilog\ncovergroup cg_mac_parser @(posedge clock);\n    // MAC address coverage\n    cp_dest_mac: coverpoint outParsedDestMac {\n        bins broadcast = {48'hFFFFFFFFFFFF};\n        bins unicast = {[0:48'hFFFFFFFFFFFE]};\n    }\n\n    // Packet size coverage\n    cp_packet_size: coverpoint packet_size {\n        bins min_size = {64};\n        bins typical = {[65:1500]};\n        bins max_size = {1518};\n    }\n\n    // Backpressure coverage\n    cp_backpressure: coverpoint outTready {\n        bins ready_deassert = (1 => 0);\n        bins ready_assert = (0 => 1);\n    }\nendgroup\n```\n\n5. Data Integrity Assertions:\n```systemverilog\n    // MAC alignment check\n    property p_mac_alignment;\n        @(posedge clock) disable iff (reset)\n        outParsedValid |-> \n            (outParsedDestMac == stored_dest_mac) &&\n            (outParsedSourceMac == stored_src_mac);\n    endproperty\n    assert property(p_mac_alignment);\n\n    // First beat alignment\n    property p_first_beat_alignment;\n        @(posedge clock) disable iff (reset)\n        outParsedValid |-> tfirst;\n    endproperty\n    assert property(p_first_beat_alignment);\n```\n\n6. Performance Tests:\n```systemverilog\n    // Throughput test\n    task test_max_throughput;\n        int packets_sent = 0;\n        time start_time, end_time;\n        \n        start_time = $time;\n        repeat(1000) begin\n            test_single_packet();\n            packets_sent++;\n        end\n        end_time = $time;\n        \n        calculate_throughput(packets_sent, end_time - start_time);\n    endtask\n\n    // Latency measurement\n    task measure_latency;\n        time start_time, end_time;\n        start_time = $time;\n        @(posedge clock iff outParsedValid);\n        end_time = $time;\n        $display(\"Latency: %0d cycles\", (end_time - start_time)/clock_period);\n    endtask\n```\n\n7. Reset and Recovery Tests:\n```systemverilog\n    // Reset during transfer\n    task test_reset_during_transfer;\n        fork\n            begin\n                test_single_packet();\n            end\n            begin\n                #10;\n                reset <= 1;\n                #2;\n                reset <= 0;\n            end\n        join\n        \n        // Verify recovery\n        check_reset_state();\n        test_single_packet(); // Should work after reset\n    endtask\n```\n\n8. System-Level Tests:\n```systemverilog\n    // Integration test scenarios\n    task test_system_integration;\n        // Multiple consecutive packets\n        fork\n            drive_input_stream();\n            monitor_output_stream();\n            inject_backpressure();\n            check_mac_extraction();\n        join\n    endtask\n```\n\nTest Environment Requirements:\n1. Self-checking testbench\n2. Random stimulus generation\n3. Coverage collection\n4. Error injection capability\n5. Performance measurement\n6. Protocol checking\n7. Reset verification\n8. Corner case testing\n\nThe verification plan should:\n1. Verify all functional requirements\n2. Test error conditions\n3. Measure performance metrics\n4. Ensure protocol compliance\n5. Validate corner cases\n6. Verify reset behavior\n7. Check data integrity\n8. Measure latency and throughputWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and describe their specific tasks:\n\n1. Frame Start Detector:\n```systemverilog\nmodule mac_frame_detector #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        frame_start,\n    output logic        in_frame\n);\n    // Uses provided local_axist_tfirst\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .tfirst(frame_start),\n        .in_packet(in_frame)\n    );\nendmodule\n```\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    input  logic        frame_start,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        extraction_done\n);\n    // MAC address assembly logic\n    logic [$clog2(96/AxiStreamWidth)-1:0] byte_counter;\n    logic parsing_active;\n    \n    // Extraction state machine and logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac <= '0;\n            src_mac <= '0;\n            byte_counter <= '0;\n        end else if (inAxi4St.tvalid && inTready) begin\n            // MAC extraction logic\n        end\n    end\nendmodule\n```\n\n3. Pipeline Manager:\n```systemverilog\nmodule pipeline_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned RequiredStages = 11\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    // Uses provided local_axist_pipe\n    local_axist_pipe #(\n        .NumStages(RequiredStages),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\nendmodule\n```\n\n4. Output Aligner:\n```systemverilog\nmodule output_aligner #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] src_mac,\n    input  logic        extraction_done,\n    input  logic        frame_start,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n    // Output alignment and timing logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end else begin\n            if (frame_start && extraction_done) begin\n                outParsedValid <= 1'b1;\n                outParsedDestMac <= dest_mac;\n                outParsedSourceMac <= src_mac;\n            end else begin\n                outParsedValid <= 1'b0;\n            end\n        end\n    end\nendmodule\n```\n\n5. Error Handler:\n```systemverilog\nmodule error_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic        extraction_done,\n    input  AxiStreamType inAxi4St,\n    output logic        error_detected,\n    output logic [7:0]  error_status\n);\n    // Error detection and handling\n    typedef enum logic [2:0] {\n        ERR_NONE,\n        ERR_SHORT_PACKET,\n        ERR_PROTOCOL,\n        ERR_ALIGNMENT\n    } error_type_t;\n    \n    // Error detection logic\n    always_ff @(posedge clock) begin\n        if (reset)\n            error_status <= '0;\n        else begin\n            // Error checking logic\n        end\n    end\nendmodule\n```\n\nTop-level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    // ... ports ...\n);\n    // Internal signals\n    logic frame_start, in_frame;\n    logic extraction_done;\n    logic [47:0] parsed_dest_mac, parsed_src_mac;\n    logic error_detected;\n    logic [7:0] error_status;\n\n    // Instantiate submodules\n    mac_frame_detector u_detector (/*...*/);\n    mac_extractor u_extractor (/*...*/);\n    pipeline_manager u_pipeline (/*...*/);\n    output_aligner u_aligner (/*...*/);\n    error_handler u_error (/*...*/);\n\nendmodule\n```\n\nSubmodule Tasks Summary:\n1. Frame Start Detector:\n- Detects start of new frames\n- Maintains frame state\n- Provides timing reference\n\n2. MAC Address Extractor:\n- Captures MAC addresses\n- Handles byte ordering\n- Tracks extraction progress\n\n3. Pipeline Manager:\n- Manages data flow\n- Handles backpressure\n- Maintains packet alignment\n\n4. Output Aligner:\n- Aligns extracted MACs\n- Generates output timing\n- Manages valid signals\n\n5. Error Handler:\n- Detects protocol violations\n- Manages error conditions\n- Provides error status\n\nEach submodule:\n- Has clear boundaries\n- Performs specific tasks\n- Maintains modularity\n- Simplifies testing\n- Improves maintainabilityWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide the SystemVerilog code for each submodule and highlight their critical interfaces.\n\n1. Frame Start Detector:\n```systemverilog\nmodule mac_frame_detector #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        frame_start,\n    output logic        in_frame\n);\n    // Instance of provided frame start detector\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .tfirst(frame_start),\n        .in_packet(in_frame)\n    );\n\n    // Optional debug/status signals\n    logic [31:0] frame_counter;\n    always_ff @(posedge clock) begin\n        if (reset)\n            frame_counter <= '0;\n        else if (frame_start && inAxi4St.tvalid && inTready)\n            frame_counter <= frame_counter + 1'b1;\n    end\n\nendmodule\n```\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    input  logic        frame_start,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        extraction_done,\n    output logic        parsing_error\n);\n    localparam int unsigned BYTES_PER_MAC = 6;\n    localparam int unsigned TOTAL_BYTES = 2 * BYTES_PER_MAC;\n    localparam int unsigned COUNTER_WIDTH = $clog2(TOTAL_BYTES + 1);\n    \n    logic [COUNTER_WIDTH-1:0] byte_counter;\n    logic parsing_active;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dest_mac <= '0;\n            src_mac <= '0;\n            byte_counter <= '0;\n            parsing_active <= '0;\n            extraction_done <= '0;\n            parsing_error <= '0;\n        end else if (inAxi4St.tvalid && inTready) begin\n            if (frame_start) begin\n                parsing_active <= 1'b1;\n                byte_counter <= '0;\n                dest_mac[47:40] <= inAxi4St.tdata;\n            end else if (parsing_active && byte_counter < TOTAL_BYTES-1) begin\n                byte_counter <= byte_counter + 1'b1;\n                case (byte_counter)\n                    0: dest_mac[39:32] <= inAxi4St.tdata;\n                    1: dest_mac[31:24] <= inAxi4St.tdata;\n                    2: dest_mac[23:16] <= inAxi4St.tdata;\n                    3: dest_mac[15:8]  <= inAxi4St.tdata;\n                    4: dest_mac[7:0]   <= inAxi4St.tdata;\n                    5: src_mac[47:40]  <= inAxi4St.tdata;\n                    6: src_mac[39:32]  <= inAxi4St.tdata;\n                    7: src_mac[31:24]  <= inAxi4St.tdata;\n                    8: src_mac[23:16]  <= inAxi4St.tdata;\n                    9: src_mac[15:8]   <= inAxi4St.tdata;\n                    10: begin\n                        src_mac[7:0]   <= inAxi4St.tdata;\n                        extraction_done <= 1'b1;\n                        parsing_active <= 1'b0;\n                    end\n                endcase\n            end\n        end\n    end\nendmodule\n```\n\n3. Pipeline Manager:\n```systemverilog\nmodule pipeline_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    localparam int unsigned RequiredStages = (96/AxiStreamWidth) - 1;\n    \n    AxiStreamType [RequiredStages:0] pipeAxi4St;\n    logic [RequiredStages:0] pipeTready;\n    \n    local_axist_pipe #(\n        .NumStages(RequiredStages),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .pipeAxi4St(pipeAxi4St),\n        .pipeTready(pipeTready),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\nendmodule\n```\n\n4. Output Aligner:\n```systemverilog\nmodule output_aligner #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] src_mac,\n    input  logic        extraction_done,\n    input  logic        frame_start,\n    input  AxiStreamType pipeline_out,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n    logic mac_valid_ff;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n            mac_valid_ff <= 1'b0;\n        end else begin\n            // Align with first output data beat\n            if (frame_start && pipeline_out.tvalid && extraction_done) begin\n                outParsedValid <= 1'b1;\n                outParsedDestMac <= dest_mac;\n                outParsedSourceMac <= src_mac;\n            end else begin\n                outParsedValid <= 1'b0;\n            end\n        end\n    end\nendmodule\n```\n\n5. Error Handler:\n```systemverilog\nmodule error_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic        extraction_done,\n    input  logic        parsing_error,\n    input  AxiStreamType inAxi4St,\n    output logic        error_detected,\n    output logic [7:0]  error_status\n);\n    localparam logic [7:0] ERR_NONE          = 8'h00;\n    localparam logic [7:0] ERR_SHORT_PACKET  = 8'h01;\n    localparam logic [7:0] ERR_PROTOCOL      = 8'h02;\n    localparam logic [7:0] ERR_ALIGNMENT     = 8'h04;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            error_detected <= 1'b0;\n            error_status <= ERR_NONE;\n        end else begin\n            // Protocol error detection\n            if (inAxi4St.tvalid && inAxi4St.tlast && !extraction_done)\n                error_status <= error_status | ERR_SHORT_PACKET;\n            \n            if (parsing_error)\n                error_status <= error_status | ERR_PROTOCOL;\n                \n            error_detected <= |error_status;\n        end\n    end\nendmodule\n```\n\nCritical Interfaces:\n1. Between Frame Detector and MAC Extractor:\n- frame_start signal\n- in_frame status\n\n2. Between MAC Extractor and Pipeline Manager:\n- Extracted MAC addresses\n- extraction_done signal\n\n3. Between Pipeline Manager and Output Aligner:\n- Delayed AXI Stream\n- Pipeline status\n\n4. Between All Modules and Error Handler:\n- Error status signals\n- Protocol violation detection\n\nInterface Considerations:\n1. Timing Dependencies:\n- Proper alignment of frame_start\n- MAC extraction completion\n- Output alignment\n\n2. Data Validity:\n- MAC address validity\n- Error condition propagation\n- Pipeline synchronization\n\n3. Handshaking:\n- AXI Stream ready/valid\n- Error acknowledgment\n- Pipeline flow control\n\nThe interfaces must ensure:\n1. Proper data synchronization\n2. Error propagation\n3. Timing alignment\n4. Protocol compliance\n5. Status reporting\n\nWould you like me to provide the top-level module that connects these submodules together?\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\nAdditionally, you are required to use the folowing module (internal contents not shown) to determine when a packet or frame starts.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining when to start parsing or extracting contents from a frame. For example:\n\nlogic first_byte_of_dest_mac_valid; // if 1, indicates dest mac [47:40] present on inAxi4St.tdata.\nassign first_byte_of_dest_mac_valid = tfirst && in_packet;\n\n\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_4"
  },
  {
    "index": 5,
    "dut": "module dut #(\n    parameter int Depth = 4096,\n    parameter int EntriesMTU = 1504,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1,\n    parameter int unsigned PacketMtuInBytes = 1500,\n    parameter int FifoSizeInBytes = 4096,\n    parameter int MaxNumberOfPackets = 32,\n    parameter int DropIngressOnAfull = 1,\n    parameter int DropEgressOnError = 1,\n    parameter int IngressPrefillBytes = -1\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    output logic inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready,\n    input  logic inError,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    output logic outError,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic inFifoAfull,\n    output logic inDropEvent,\n    output logic outDropEvent\n);\n\n// Bypass mode when Depth=0\ngenerate\nif (Depth == 0) begin: bypass_gen\n    always_comb begin\n        outAxi4St = inAxi4St;\n        outError = inError;\n        outExtra = inExtra;\n        inTready = 1'b1;\n        inFifoAfull = 1'b0;\n        inDropEvent = 1'b0;\n        outDropEvent = 1'b0;\n    end\nend\nelse begin: fifo_gen\n\n    // Internal signals\n    logic write_enable, frame_start, frame_end;\n    logic [$clog2(Depth)-1:0] write_pointer, read_pointer;\n    logic [$clog2(Depth):0] fifo_count;\n    logic empty, almost_full, dropping_frame;\n    logic [31:0] current_frame_size;\n    logic [31:0] current_packet_count;\n    logic max_packets_reached;\n    logic output_valid;\n    logic read_enable;\n\n    // Storage arrays\n    AxiStreamType data_array [Depth-1:0];\n    logic [ExtraDataWidth-1:0] extra_array [Depth-1:0];\n    logic error_array [Depth-1:0];\n\n    // Input Controller\n    logic in_frame;\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_frame <= 1'b0;\n            dropping_frame <= 1'b0;\n            current_frame_size <= '0;\n        end else if (inAxi4St.tvalid) begin\n            if (!in_frame) begin\n                in_frame <= 1'b1;\n                dropping_frame <= (almost_full || max_packets_reached);\n                current_frame_size <= 32'd1;\n            end else if (!dropping_frame) begin\n                current_frame_size <= current_frame_size + 1;\n            end\n            \n            if (inAxi4St.tlast) begin\n                in_frame <= 1'b0;\n                dropping_frame <= 1'b0;\n            end\n        end\n    end\n\n    // Packet Counter\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            current_packet_count <= '0;\n        end else begin\n            if (inAxi4St.tvalid && inAxi4St.tlast && !dropping_frame) begin\n                current_packet_count <= current_packet_count + 1;\n            end\n            if (outAxi4St.tvalid && outAxi4St.tlast && outTready) begin\n                current_packet_count <= current_packet_count - 1;\n            end\n        end\n    end\n\n    // FIFO Control\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            write_pointer <= '0;\n            read_pointer <= '0;\n            fifo_count <= '0;\n        end else begin\n            if (write_enable && inAxi4St.tvalid && !dropping_frame) begin\n                write_pointer <= write_pointer + 1;\n            end\n            if (read_enable) begin\n                read_pointer <= read_pointer + 1;\n            end\n\n            case ({write_enable && inAxi4St.tvalid && !dropping_frame, read_enable})\n                2'b10: fifo_count <= fifo_count + 1;\n                2'b01: fifo_count <= fifo_count - 1;\n                default: fifo_count <= fifo_count;\n            endcase\n        end\n    end\n\n    // Storage Write\n    always_ff @(posedge clock) begin\n        if (write_enable && inAxi4St.tvalid && !dropping_frame) begin\n            data_array[write_pointer] <= inAxi4St;\n            extra_array[write_pointer] <= inExtra;\n            error_array[write_pointer] <= inError && inAxi4St.tlast;\n        end\n    end\n\n    // Output Control\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            output_valid <= 1'b0;\n        end else begin\n            output_valid <= !empty && outTready;\n        end\n    end\n\n    // Status and Control Signals\n    assign write_enable = inAxi4St.tvalid && !dropping_frame;\n    assign read_enable = output_valid && outTready && !empty;\n    assign empty = (fifo_count == 0);\n    assign almost_full = (fifo_count >= (Depth - PacketMtuInBytes));\n    assign max_packets_reached = (current_packet_count >= MaxNumberOfPackets);\n    \n    // Output Assignments\n    assign outAxi4St = data_array[read_pointer];\n    assign outExtra = extra_array[read_pointer];\n    assign outError = error_array[read_pointer] && outAxi4St.tlast;\n    \n    // Status Outputs\n    assign inTready = 1'b1;\n    assign inFifoAfull = almost_full || max_packets_reached;\n    assign inDropEvent = inAxi4St.tvalid && inAxi4St.tlast && dropping_frame;\n    assign outDropEvent = 1'b0;\n\nend\nendgenerate\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module is a specialized FIFO (First-In-First-Out) buffer designed for AXI4-Stream protocol with the following key features:\n\n1. Store-and-forward capability: It stores complete packets before forwarding them\n2. Frame dropping capability: If there isn't enough space for a complete frame (based on MTU size), the entire frame is dropped\n3. Parameterizable depth and data width\n4. Bypass mode when Depth=0\n5. Packet management: Tracks number of stored packets and drops new packets if maximum limit reached\n\nHigh-Level Block Diagram:\n```\n                                    +------------------------+\n                                    |      Control Logic     |\n                                    | (Frame drop decision)  |\n                                    +------------------------+\n                                             |\ninAxi4St ----+                              |\ninExtra  ----+                    +------------------+\ninError  ----+------------------>|                  |\n             |    Write          |                  |         outAxi4St\n             |    Logic          |      FIFO        |-------> outExtra\n             |                   |                  |         outError\n             |                   |                  |\n             |                   +------------------+\n             |                          ^\ninTready <---+                          |\n                                       clk\n                                      reset\n```\n\nKey Components:\n1. Control Logic:\n   - Monitors FIFO occupancy\n   - Makes frame drop decisions\n   - Tracks number of stored packets\n   - Generates control signals (inFifoAfull, inDropEvent)\n\n2. FIFO Storage:\n   - Stores packet data (tdata)\n   - Stores associated signals (tuser, tkeep, tlast)\n   - Stores extra data and error flags\n\n3. Write Logic:\n   - Handles input interface\n   - Implements dropping mechanism\n   - Always keeps inTready high\n\n4. Read Logic:\n   - Handles output interface\n   - Responds to outTready signal\n   - Forwards complete packets\n\nThe module essentially acts as a buffer with packet awareness, protecting against overflow by dropping entire packets when necessary, rather than individual data words.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nKey Parameterizable Aspects:\n\n1. FIFO Depth Related:\n```systemverilog\nparameter int Depth = 4096              // Must be \u226564 and power of 2\nparameter int FifoSizeInBytes = 4096    // Should match Depth when using 8-bit data\n```\n\n2. Data Width Related:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s  // Default 8-bit data\nparameter int unsigned AxiStreamWidth = 8             // Must match AxiStreamType\nparameter int unsigned ExtraDataWidth = 1             // Additional data width\n```\n\n3. Packet Management:\n```systemverilog\nparameter int EntriesMTU = 1504           // Minimum free space needed for new frame\nparameter int PacketMtuInBytes = 1500     // Maximum frame size in bytes\nparameter int MaxNumberOfPackets = 32      // Maximum stored packets\n```\n\n4. Control Parameters:\n```systemverilog\nparameter int DropIngressOnAfull = 1      // Must be 1\nparameter int DropEgressOnError = 1       // Must be 1\nparameter int IngressPrefillBytes = -1    // Must be -1\n```\n\nReasonable Default Values Analysis:\n\n1. Depth Related:\n- 4096 is a good default as it:\n  * Is a power of 2 (efficient implementation)\n  * Provides enough storage for multiple maximum-sized frames\n  * Common in networking applications\n\n2. Data Width:\n- 8 bits is standard for byte-oriented protocols\n- ExtraDataWidth=1 allows for minimal additional signaling\n\n3. Packet Management:\n- MTU of 1500 bytes is standard for Ethernet\n- 32 packets is reasonable for buffering\n- EntriesMTU slightly larger than MTU (1504) provides headroom\n\nConsiderations for Parameter Relationships:\n1. Depth must be \u2265 PacketMtuInBytes to store at least one full packet\n2. FifoSizeInBytes should = Depth * (AxiStreamWidth/8)\n3. EntriesMTU should be \u2265 PacketMtuInBytes\n4. MaxNumberOfPackets should be reasonable compared to Depth/PacketMtuInBytes\n\nThese parameters allow the module to be configured for different:\n- Bus widths\n- Memory constraints\n- Protocol requirements\n- System performance requirements\n\nThe default values are oriented towards standard Ethernet-like protocols while maintaining flexibility for other applications.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n```\n1. Input Stage --> 2. FIFO Storage --> 3. Output Stage\n```\n\nRequired Registers and Logic:\n\n1. Input Stage Registers & Logic:\n```systemverilog\n// Packet Tracking\nreg  [31:0] current_packet_count;     // Track stored packets\nreg  [31:0] current_frame_size;       // Track current frame size\nreg         in_frame;                 // Indicates active frame reception\n\n// Drop Logic\nwire        can_accept_frame;         // Combinational: check if enough space\nreg         dropping_frame;           // Current frame being dropped state\n\n// FIFO Control\nreg  [$clog2(Depth):0] write_pointer;\nreg  [$clog2(Depth):0] fifo_count;\n```\n\n2. FIFO Storage Elements:\n```systemverilog\n// Main Storage\nreg [AxiStreamWidth-1:0] data_fifo [Depth-1:0];    // Data storage\nreg                      last_fifo [Depth-1:0];     // Frame boundary markers\nreg                      user_fifo [Depth-1:0];     // User signals\nreg                      keep_fifo [Depth-1:0];     // Keep signals\nreg [ExtraDataWidth-1:0] extra_fifo [Depth-1:0];   // Extra data storage\nreg                      error_fifo [Depth-1:0];    // Error flags\n```\n\n3. Output Stage Registers & Logic:\n```systemverilog\n// Read Control\nreg  [$clog2(Depth):0] read_pointer;\nreg                    output_valid;\nreg                    frame_complete;  // Last word of frame being output\n```\n\nKey Combinational Logic:\n\n1. FIFO Status Logic:\n```systemverilog\n// Space Available Calculation\nwire [$clog2(Depth):0] available_space = Depth - fifo_count;\nwire almost_full = available_space < PacketMtuInBytes;\n\n// Drop Decision Logic\nassign can_accept_frame = \n    !in_frame && \n    !almost_full && \n    (current_packet_count < MaxNumberOfPackets);\n```\n\n2. Input Processing Logic:\n```systemverilog\n// Frame Processing\nalways_comb begin\n    inTready = 1'b1;  // Always ready\n    inDropEvent = inAxi4St.tvalid && inAxi4St.tlast && dropping_frame;\n    inFifoAfull = almost_full || (current_packet_count >= MaxNumberOfPackets);\nend\n```\n\n3. Output Processing Logic:\n```systemverilog\n// Output Formation\nalways_comb begin\n    outAxi4St.tdata  = data_fifo[read_pointer];\n    outAxi4St.tkeep  = keep_fifo[read_pointer];\n    outAxi4St.tuser  = user_fifo[read_pointer];\n    outAxi4St.tlast  = last_fifo[read_pointer];\n    outAxi4St.tvalid = output_valid;\n    outExtra = extra_fifo[read_pointer];\n    outError = error_fifo[read_pointer] && outAxi4St.tlast;\nend\n```\n\nData Transformation Process:\n1. Input Processing:\n   - Incoming data is evaluated for storage or dropping\n   - Frame boundaries are tracked\n   - Packet count is maintained\n\n2. Storage:\n   - Valid data is written to multiple parallel FIFOs\n   - All signals (tdata, tkeep, tuser, tlast, extra, error) stored together\n\n3. Output Processing:\n   - Data is read when downstream is ready\n   - Complete frames are transmitted\n   - Signals are reconstructed from storage\n\nControl Logic Requirements:\n1. Frame Tracking:\n   - Start of frame detection\n   - End of frame detection\n   - Frame size counting\n\n2. FIFO Management:\n   - Write pointer advancement\n   - Read pointer advancement\n   - Count maintenance\n   - Almost full detection\n\n3. Drop Control:\n   - Frame drop decision at start of frame\n   - Continued dropping until frame complete\n\nThis structure ensures proper packet handling while maintaining AXI4-Stream protocol requirements and implementing the specified dropping behavior.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description and typical FIFO requirements, let's analyze the timing aspects:\n\nClocking Requirements:\n1. Single Clock Domain\n```systemverilog\ninput logic clock    // Single system clock\ninput logic reset   // Synchronous reset (explicitly specified)\n```\n\nReset Requirements:\n1. Synchronous Reset (explicitly specified)\n2. Signals that need reset:\n```systemverilog\n// Control Registers\nreg  [31:0] current_packet_count <= '0;\nreg  [31:0] current_frame_size  <= '0;\nreg         in_frame           <= 1'b0;\nreg         dropping_frame     <= 1'b0;\n\n// FIFO Control\nreg  [$clog2(Depth):0] write_pointer <= '0;\nreg  [$clog2(Depth):0] read_pointer  <= '0;\nreg  [$clog2(Depth):0] fifo_count    <= '0;\n\n// Output Control\nreg         output_valid      <= 1'b0;\nreg         frame_complete    <= 1'b0;\n```\n\nLatency Characteristics:\n1. Store-and-Forward Mode:\n   - Minimum latency: Full frame must be received before forwarding\n   - Best case: Depth=0 (bypass mode) -> 0 clock cycles\n   - Normal case: At least PacketMtuInBytes cycles for a full frame\n\n2. Critical Paths:\n```\nInput Path:\ninAxi4St -> drop decision -> FIFO write: 1 cycle\n\nOutput Path:\nFIFO read -> outAxi4St: 1 cycle\n```\n\nThroughput Requirements:\n1. Input Side:\n   - Can accept new data every cycle (inTready always 1)\n   - Must handle back-to-back packets\n\n2. Output Side:\n   - Can transfer data every cycle when outTready=1\n   - Full throughput when not empty and outTready=1\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n```systemverilog\n// Input Registration\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Synchronous reset\n    end else if (inAxi4St.tvalid && !dropping_frame) begin\n        // Input data capture\n    end\nend\n```\n\n2. Output Timing:\n```systemverilog\n// Output Registration\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        output_valid <= 1'b0;\n    end else begin\n        output_valid <= !empty && outTready;\n    end\nend\n```\n\nKey Timing Considerations:\n1. Single-cycle Response:\n   - Drop decisions must be made in one cycle\n   - FIFO status must be immediately available\n\n2. Protocol Timing:\n   - AXI4-Stream handshaking must be maintained\n   - No bubbles in packet transmission\n\nExample Timing Diagram:\n```\nclock      _|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e|_\nreset      \u203e\u203e\u203e|_________________________\n           \ninAxi4St   ___[D0][D1][D2]_____________\ntvalid     ___|\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e|_____________\ntlast      ___________|\u203e|_______________\n           \noutAxi4St  _____________[D0][D1][D2]___\noutvalid   _____________|\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e|___\noutlast    ___________________|\u203e|_____\n```\n\nPerformance Implications:\n1. Zero-cycle bypass when Depth=0\n2. Store-and-forward adds latency but ensures:\n   - Complete frame integrity\n   - Proper drop decisions\n   - No partial frame transmission\n\nReset Strategy:\n1. Synchronous reset (as specified)\n2. Reset sequence:\n   - Clear all counters\n   - Reset pointers\n   - Clear control flags\n   - Reset output signals\n3. No need to reset FIFO memory contents (will be overwritten)\n\nThis timing structure ensures reliable operation while maintaining the AXI4-Stream protocol requirements and implementing the specified packet handling behavior.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline comprehensive test scenarios and assertions needed for this FIFO design:\n\nTest Scenarios:\n\n1. Basic Functionality Tests:\n```systemverilog\n// Basic packet handling\ntest_single_packet();           // Single packet transfer\ntest_multiple_packets();        // Multiple back-to-back packets\ntest_minimum_packet();          // Single-byte packet\ntest_maximum_packet();          // MTU-sized packet\ntest_bypass_mode();            // Test when Depth=0\n```\n\n2. Corner Cases:\n```systemverilog\n// Edge conditions\ntest_almost_full_conditions();  // Behavior near full threshold\ntest_max_packets_reached();     // When MaxNumberOfPackets reached\ntest_back_to_back_packets();    // No gaps between packets\ntest_variable_packet_sizes();   // Mix of different sized packets\n```\n\n3. Error Conditions:\n```systemverilog\n// Error handling\ntest_packet_drop_scenarios();   // Various drop conditions\ntest_error_propagation();       // inError to outError propagation\ntest_extra_data_handling();     // inExtra to outExtra propagation\n```\n\n4. Flow Control Tests:\n```systemverilog\ntest_outTready_throttling();    // Varying outTready patterns\ntest_fifo_full_behavior();      // Full FIFO handling\ntest_concurrent_io();           // Simultaneous read/write\n```\n\nAssertions:\n\n1. Protocol Compliance:\n```systemverilog\n// AXI Stream Protocol Checks\nproperty axi_valid_ready_p;\n    @(posedge clock) disable iff (reset)\n    inTready == 1'b1;  // Must always be ready\nendproperty\nassert property(axi_valid_ready_p);\n\n// Frame integrity\nproperty frame_complete_p;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && inAxi4St.tlast |-> ##[1:$] \n    (outAxi4St.tvalid && outAxi4St.tlast);\nendproperty\n```\n\n2. FIFO Functionality:\n```systemverilog\n// Count tracking\nproperty fifo_count_valid_p;\n    @(posedge clock) disable iff (reset)\n    fifo_count <= Depth;\nendproperty\n\n// Packet count tracking\nproperty packet_count_valid_p;\n    @(posedge clock) disable iff (reset)\n    current_packet_count <= MaxNumberOfPackets;\nendproperty\n\n// No data loss when not dropping\nproperty no_data_loss_p;\n    @(posedge clock) disable iff (reset)\n    !dropping_frame && inAxi4St.tvalid |-> \n    ##[1:$] outAxi4St.tvalid;\nendproperty\n```\n\n3. Drop Behavior:\n```systemverilog\n// Drop indication\nproperty drop_indication_p;\n    @(posedge clock) disable iff (reset)\n    dropping_frame && inAxi4St.tvalid && inAxi4St.tlast |->\n    inDropEvent;\nendproperty\n\n// Drop conditions\nproperty drop_condition_p;\n    @(posedge clock) disable iff (reset)\n    (fifo_count > (Depth - PacketMtuInBytes) ||\n     current_packet_count >= MaxNumberOfPackets) |->\n    inFifoAfull;\nendproperty\n```\n\n4. Reset Behavior:\n```systemverilog\n// Reset values\nproperty reset_values_p;\n    @(posedge clock)\n    reset |-> ##1 (\n        !output_valid &&\n        !in_frame &&\n        !dropping_frame &&\n        fifo_count == 0 &&\n        current_packet_count == 0\n    );\nendproperty\n```\n\n5. Timing Checks:\n```systemverilog\n// Output timing\nproperty output_timing_p;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |-> \n    ##1 outAxi4St.tvalid;\nendproperty\n\n// No bubbles in packet\nproperty no_bubbles_p;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outAxi4St.tlast && outTready |->\n    ##1 outAxi4St.tvalid;\nendproperty\n```\n\nCoverage Points:\n\n1. Functional Coverage:\n```systemverilog\ncovergroup fifo_cg;\n    packet_size_cp: coverpoint current_frame_size {\n        bins small  = {[1:64]};\n        bins medium = {[65:1000]};\n        bins large  = {[1001:PacketMtuInBytes]};\n    }\n    \n    fifo_state_cp: coverpoint fifo_count {\n        bins empty     = {0};\n        bins almost_full = {[Depth-PacketMtuInBytes:Depth-1]};\n        bins full      = {Depth};\n    }\n    \n    packet_count_cp: coverpoint current_packet_count {\n        bins low    = {[0:MaxNumberOfPackets/4]};\n        bins high   = {[MaxNumberOfPackets-4:MaxNumberOfPackets]};\n    }\nendgroup\n```\n\n2. Corner Cases Coverage:\n```systemverilog\ncovergroup corner_cases_cg;\n    drop_scenarios_cp: coverpoint {inFifoAfull, dropping_frame};\n    back_to_back_cp: coverpoint consecutive_packets;\n    ready_patterns_cp: coverpoint outTready_pattern;\nendgroup\n```\n\nThese test scenarios, assertions, and coverage points ensure:\n1. Protocol compliance\n2. Correct packet handling\n3. Proper drop behavior\n4. Error and extra data propagation\n5. Reset functionality\n6. Corner case handling\n7. Performance requirements\n\nThe comprehensive verification approach helps catch issues early and ensures reliable operation.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and their specific tasks:\n\n1. Input Controller Module:\n```systemverilog\nmodule input_controller (\n    // Handles input interface and frame tracking\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    output logic dropping_frame,\n    output logic write_enable,\n    output logic frame_start,\n    output logic frame_end\n);\n```\nTasks:\n- Frame boundary detection\n- Drop decision logic\n- Input handshaking\n- Frame size tracking\n\n2. Packet Counter Module:\n```systemverilog\nmodule packet_counter (\n    // Tracks number of stored packets\n    input  logic clock,\n    input  logic reset,\n    input  logic packet_write_complete,\n    input  logic packet_read_complete,\n    output logic [31:0] current_packet_count,\n    output logic max_packets_reached\n);\n```\nTasks:\n- Maintain packet count\n- Generate almost full conditions\n- Track packet boundaries\n\n3. FIFO Memory Controller:\n```systemverilog\nmodule fifo_memory_controller #(\n    parameter int Depth = 4096\n) (\n    // Manages FIFO storage\n    input  logic clock,\n    input  logic reset,\n    input  logic write_enable,\n    input  logic read_enable,\n    output logic [$clog2(Depth):0] fifo_count,\n    output logic almost_full,\n    output logic empty\n);\n```\nTasks:\n- Pointer management\n- Memory write/read control\n- FIFO status generation\n\n4. Storage Elements:\n```systemverilog\nmodule storage_elements #(\n    parameter int Depth = 4096,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    // Actual storage arrays\n    input  logic clock,\n    input  AxiStreamType data_in,\n    input  logic [ExtraDataWidth-1:0] extra_in,\n    input  logic error_in,\n    output AxiStreamType data_out,\n    output logic [ExtraDataWidth-1:0] extra_out,\n    output logic error_out\n);\n```\nTasks:\n- Data storage\n- Multi-signal storage management\n- Data alignment\n\n5. Output Controller:\n```systemverilog\nmodule output_controller (\n    // Manages output interface\n    input  logic clock,\n    input  logic reset,\n    input  logic empty,\n    input  logic outTready,\n    output logic read_enable,\n    output logic output_valid\n);\n```\nTasks:\n- Output handshaking\n- Read timing control\n- Output valid generation\n\n6. Drop Logic Controller:\n```systemverilog\nmodule drop_controller (\n    // Manages frame dropping\n    input  logic clock,\n    input  logic reset,\n    input  logic frame_start,\n    input  logic almost_full,\n    input  logic max_packets_reached,\n    output logic dropping_frame,\n    output logic inDropEvent\n);\n```\nTasks:\n- Drop decision logic\n- Drop event generation\n- Frame tracking during drops\n\n7. Status Generator:\n```systemverilog\nmodule status_generator (\n    // Generates status signals\n    input  logic almost_full,\n    input  logic max_packets_reached,\n    input  logic dropping_frame,\n    input  logic frame_complete,\n    output logic inFifoAfull,\n    output logic inDropEvent,\n    output logic outDropEvent\n);\n```\nTasks:\n- Status signal generation\n- Error condition monitoring\n- Event reporting\n\nTop-Level Integration:\n```systemverilog\nmodule dut (\n    // Main module\n    input  logic clock,\n    input  logic reset,\n    // ... other ports ...\n);\n    // Instantiate submodules\n    input_controller u_input_ctrl (/*...*/);\n    packet_counter u_pkt_counter (/*...*/);\n    fifo_memory_controller u_fifo_ctrl (/*...*/);\n    storage_elements u_storage (/*...*/);\n    output_controller u_output_ctrl (/*...*/);\n    drop_controller u_drop_ctrl (/*...*/);\n    status_generator u_status_gen (/*...*/);\nendmodule\n```\n\nInterconnections:\n1. Control Flow:\n```\nInput Controller \u2192 Drop Controller \u2192 FIFO Memory Controller\n     \u2193                   \u2193                  \u2193\nPacket Counter \u2192 Status Generator \u2190 Output Controller\n```\n\n2. Data Flow:\n```\nInput Controller \u2192 Storage Elements \u2192 Output Controller\n```\n\nBenefits of This Modular Structure:\n1. Separation of Concerns:\n   - Each module has a specific responsibility\n   - Easier to maintain and debug\n   - Simplified testing\n\n2. Reusability:\n   - Modules can be reused in other designs\n   - Standard interfaces between modules\n\n3. Scalability:\n   - Easy to modify individual modules\n   - Simple to add new features\n\n4. Verifiability:\n   - Each module can be tested independently\n   - Clear boundaries for assertions\n   - Simplified debugging\n\nThis modular approach creates a maintainable and scalable design while keeping the complexity manageable.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nLet me write the SystemVerilog code for each submodule and highlight their critical interfaces. I'll break this down into parts for clarity.\n\n1. Input Controller:\n```systemverilog\nmodule input_controller (\n    input  logic                   clock,\n    input  logic                   reset,\n    input  AxiStreamType          inAxi4St,\n    input  logic                   almost_full,\n    input  logic                   max_packets_reached,\n    output logic                   dropping_frame,\n    output logic                   write_enable,\n    output logic                   frame_start,\n    output logic                   frame_end,\n    output logic [31:0]           current_frame_size\n);\n\n    logic in_frame;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_frame <= 1'b0;\n            dropping_frame <= 1'b0;\n            current_frame_size <= '0;\n        end else if (inAxi4St.tvalid) begin\n            // Start of new frame\n            if (!in_frame) begin\n                in_frame <= 1'b1;\n                dropping_frame <= (almost_full || max_packets_reached);\n                current_frame_size <= 32'd1;\n            end else if (!dropping_frame) begin\n                current_frame_size <= current_frame_size + 1;\n            end\n            \n            // End of frame\n            if (inAxi4St.tlast) begin\n                in_frame <= 1'b0;\n                dropping_frame <= 1'b0;\n            end\n        end\n    end\n\n    assign write_enable = inAxi4St.tvalid && !dropping_frame;\n    assign frame_start = inAxi4St.tvalid && !in_frame;\n    assign frame_end = inAxi4St.tvalid && inAxi4St.tlast;\n\nendmodule\n```\n\n2. Packet Counter:\n```systemverilog\nmodule packet_counter #(\n    parameter int MaxNumberOfPackets = 32\n) (\n    input  logic         clock,\n    input  logic         reset,\n    input  logic         packet_write_complete,\n    input  logic         packet_read_complete,\n    output logic [31:0]  current_packet_count,\n    output logic         max_packets_reached\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            current_packet_count <= '0;\n        end else begin\n            case ({packet_write_complete, packet_read_complete})\n                2'b10: current_packet_count <= current_packet_count + 1;\n                2'b01: current_packet_count <= current_packet_count - 1;\n                default: current_packet_count <= current_packet_count;\n            endcase\n        end\n    end\n\n    assign max_packets_reached = (current_packet_count >= MaxNumberOfPackets);\n\nendmodule\n```\n\n3. FIFO Memory Controller:\n```systemverilog\nmodule fifo_memory_controller #(\n    parameter int Depth = 4096\n) (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  logic                    write_enable,\n    input  logic                    read_enable,\n    output logic [$clog2(Depth):0]  fifo_count,\n    output logic [$clog2(Depth)-1:0] write_pointer,\n    output logic [$clog2(Depth)-1:0] read_pointer,\n    output logic                    almost_full,\n    output logic                    empty\n);\n\n    logic [$clog2(Depth):0] next_write_ptr, next_read_ptr;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            write_pointer <= '0;\n            read_pointer <= '0;\n            fifo_count <= '0;\n        end else begin\n            if (write_enable && !almost_full) begin\n                write_pointer <= write_pointer + 1;\n            end\n            if (read_enable && !empty) begin\n                read_pointer <= read_pointer + 1;\n            end\n\n            case ({write_enable, read_enable})\n                2'b10: fifo_count <= fifo_count + 1;\n                2'b01: fifo_count <= fifo_count - 1;\n                default: fifo_count <= fifo_count;\n            endcase\n        end\n    end\n\n    assign almost_full = (fifo_count >= (Depth - PacketMtuInBytes));\n    assign empty = (fifo_count == 0);\n\nendmodule\n```\n\n4. Storage Elements:\n```systemverilog\nmodule storage_elements #(\n    parameter int Depth = 4096,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic                    clock,\n    input  logic                    write_enable,\n    input  logic [$clog2(Depth)-1:0] write_pointer,\n    input  logic [$clog2(Depth)-1:0] read_pointer,\n    input  AxiStreamType            data_in,\n    input  logic [ExtraDataWidth-1:0] extra_in,\n    input  logic                    error_in,\n    output AxiStreamType            data_out,\n    output logic [ExtraDataWidth-1:0] extra_out,\n    output logic                    error_out\n);\n\n    // Memory arrays\n    AxiStreamType            data_mem [Depth-1:0];\n    logic [ExtraDataWidth-1:0] extra_mem[Depth-1:0];\n    logic                    error_mem[Depth-1:0];\n\n    always_ff @(posedge clock) begin\n        if (write_enable) begin\n            data_mem[write_pointer]  <= data_in;\n            extra_mem[write_pointer] <= extra_in;\n            error_mem[write_pointer] <= error_in;\n        end\n    end\n\n    assign data_out  = data_mem[read_pointer];\n    assign extra_out = extra_mem[read_pointer];\n    assign error_out = error_mem[read_pointer];\n\nendmodule\n```\n\n5. Output Controller:\n```systemverilog\nmodule output_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        empty,\n    input  logic        outTready,\n    output logic        read_enable,\n    output logic        output_valid\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            output_valid <= 1'b0;\n        end else begin\n            output_valid <= !empty;\n        end\n    end\n\n    assign read_enable = output_valid && outTready;\n\nendmodule\n```\n\nCritical Interfaces Between Submodules:\n\n1. Input Controller \u2194 FIFO Memory Controller:\n```systemverilog\n// Control signals\nlogic write_enable;\nlogic frame_start;\nlogic frame_end;\n```\n\n2. FIFO Memory Controller \u2194 Storage Elements:\n```systemverilog\n// Memory access\nlogic [$clog2(Depth)-1:0] write_pointer;\nlogic [$clog2(Depth)-1:0] read_pointer;\n```\n\n3. FIFO Memory Controller \u2194 Output Controller:\n```systemverilog\n// Status signals\nlogic empty;\nlogic read_enable;\n```\n\n4. Input Controller \u2194 Packet Counter:\n```systemverilog\n// Packet tracking\nlogic packet_write_complete;\nlogic max_packets_reached;\n```\n\nThe integration of these modules requires careful attention to these interfaces and proper timing of control signals. Each interface represents a critical handoff point where data or control information must be properly synchronized and managed.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_storefwd_fifo_3"
  },
  {
    "index": 9,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  input  logic clock,\n  input  logic reset,\n  \n  input  AxiStreamType inAxi4St,\n  output logic inTready,\n  input  logic [ExtraDataWidth-1:0] inExtra,\n  \n  output AxiStreamType outAxi4St,\n  input  logic outTready,\n  output logic [ExtraDataWidth-1:0] outExtra,\n  \n  input  logic [7:0] i_rate_numerator,\n  input  logic [7:0] i_rate_denominator,\n  input  logic i_rate_by_frame\n);\n\n  // Rate control signals\n  logic rate_allow;\n  logic [7:0] rate_counter;\n\n  // Pipeline signals\n  AxiStreamType [1:0] pipeAxi4St;\n  logic [1:0] pipeTready;\n  \n  // Extra data storage\n  logic [ExtraDataWidth-1:0] extra_data_reg;\n  logic valid_transfer;\n\n  // Rate control logic\n  always_ff @(posedge clock) begin\n    if (reset)\n      rate_counter <= 8'd0;\n    else if (rate_counter >= i_rate_denominator)\n      rate_counter <= rate_counter - i_rate_denominator + i_rate_numerator;\n    else\n      rate_counter <= rate_counter + i_rate_numerator;\n  end\n\n  assign rate_allow = (rate_counter >= i_rate_denominator);\n\n  // Pipeline instance\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .pipeAxi4St(pipeAxi4St),\n    .pipeTready(pipeTready),\n    .outAxi4St(outAxi4St),\n    .outTready(outTready & rate_allow)\n  );\n\n  // Extra data handling\n  assign valid_transfer = inAxi4St.tvalid && inTready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      extra_data_reg <= '0;\n    else if (valid_transfer)\n      extra_data_reg <= inExtra;\n  end\n\n  assign outExtra = extra_data_reg;\n\n  // AXI Stream control logic\n  always_comb begin\n    outAxi4St = pipeAxi4St[1];\n    outAxi4St.tvalid = pipeAxi4St[1].tvalid && rate_allow;\n  end\n\n  assign inTready = pipeTready[0] && rate_allow;\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- For this design, this input can be ignored and assumed the value is tied to 0.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module is an AXI4-Stream Rate Limiter that:\n1. Takes an AXI4-Stream input and produces a rate-limited AXI4-Stream output\n2. Controls the data flow rate using a fraction (i_rate_numerator/i_rate_denominator)\n3. Implements ready/valid handshaking protocol\n4. Passes additional data (inExtra) alongside the main AXI stream\n5. Uses an existing pipe module (local_axist_pipe) for sequential storage\n\nHigh-Level Block Diagram:\n```\n                     Rate Control Logic\n                    (numerator/denominator)\n                            \u2502\n                            \u25bc\ninAxi4St \u2500\u2500\u2500\u2500\u2500\u25ba[ Input ] \u2500\u2500\u25ba[ local_axist_pipe ]\u2500\u2500\u25ba[ Output ]\u2500\u2500\u2500\u25ba outAxi4St\ninExtra  \u2500\u2500\u2500\u2500\u2500\u25ba  Stage         (Storage)             Stage    \u2500\u2500\u2500\u25ba outExtra\n              \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\ninTready \u25c4\u2500\u2500\u2500\u2500                                        outTready\n```\n\nKey Components:\n1. Input Stage: Handles input handshaking and flow control\n2. Storage (local_axist_pipe): Provides buffering and pipelining\n3. Rate Control Logic: Implements the rate limiting based on numerator/denominator\n4. Output Stage: Manages output handshaking and rate-limited data transmission\n\nThe module essentially acts as a \"traffic shaper\" for AXI4-Stream data, controlling the flow rate while maintaining proper AXI4-Stream protocol compliance.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nRequired Parameters:\n1. `AxiStreamType` (Type parameter)\n   - Default = local_pkg::axi4st_8_s\n   - Defines the structure of AXI4-Stream signals\n   - Contains: {tdata[7:0], tkeep, tuser, tlast, tvalid}\n\n2. `AxiStreamWidth` (Integer parameter)\n   - Default = 8\n   - Represents width of tdata field\n   - Must be included but not necessarily used in implementation\n\n3. `ExtraDataWidth` (Integer parameter)\n   - Default = 1\n   - Defines width of additional data (inExtra/outExtra)\n   - Should be \u2265 1\n\nAdditional Considerations for Parameterization:\n1. Pipeline Depth\n   - When using local_axist_pipe, its NumStages parameter should be configurable\n   - Reasonable default might be 1 or 2 stages\n\n2. Rate Control Parameters (Not parameters but inputs)\n   - i_rate_numerator[7:0]\n   - i_rate_denominator[7:0]\n   - Together they form a fraction between 0 and 1\n   - Example defaults: numerator=1, denominator=1 (full rate)\n\nReasonable Constraints:\n1. ExtraDataWidth \u2265 1\n2. AxiStreamWidth must match tdata width in AxiStreamType\n3. Rate denominator must not be zero\n4. Rate numerator must not exceed denominator\n\nThe parameterization allows the module to be flexible for different:\n- Data widths\n- Extra data requirements\n- Buffer depths\n- While maintaining protocol complianceHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n1. Input Processing\n```systemverilog\n// Input stage logic\nreg rate_allow;  // Rate control signal\nreg [7:0] rate_counter;  // Counter for rate control\n\n// Rate control logic\nalways_ff @(posedge clock) begin\n  if (reset)\n    rate_counter <= 8'd0;\n  else if (rate_counter >= i_rate_denominator)\n    rate_counter <= rate_counter - i_rate_denominator + i_rate_numerator;\n  else\n    rate_counter <= rate_counter + i_rate_numerator;\nend\n\nassign rate_allow = (rate_counter >= i_rate_denominator);\n```\n\n2. Storage Elements\n- Use local_axist_pipe for main data path storage\n- Additional register for extra data\n```systemverilog\nlogic [ExtraDataWidth-1:0] extra_data_reg;\nlocal_axist_pipe #(\n  .NumStages(1),\n  .AxiStreamType(AxiStreamType)\n) u_pipe (\n  // ... ports ...\n);\n```\n\n3. Required Registers:\n- Rate control counter\n- Extra data storage\n- State tracking (if needed for packet boundaries)\n\n4. Combinational Logic:\n- Rate calculation logic\n- Ready/valid handshaking logic\n```systemverilog\n// Ready/Valid control\nassign inTready = rate_allow && pipeTready[0];\nassign outAxi4St.tvalid = rate_allow && pipeAxi4St[1].tvalid;\n```\n\n5. Signal Transformations:\n```systemverilog\n// Data path\nalways_ff @(posedge clock) begin\n  if (inAxi4St.tvalid && inTready)\n    extra_data_reg <= inExtra;\nend\n\nassign outExtra = extra_data_reg;\nassign outAxi4St.tdata = pipeAxi4St[1].tdata;\nassign outAxi4St.tkeep = pipeAxi4St[1].tkeep;\nassign outAxi4St.tlast = pipeAxi4St[1].tlast;\nassign outAxi4St.tuser = pipeAxi4St[1].tuser;\n```\n\nThe key aspects are:\n1. Rate control mechanism\n2. Data path through local_axist_pipe\n3. Extra data handling\n4. Ready/valid flow control\n5. State tracking if needed\n\nAll synchronous logic should be reset-sensitive and clock-synchronized.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description, let me analyze the timing and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain\n- All logic operates on positive edge of 'clock' input\n- No clock crossing required\n- Synchronous design principles should be followed\n\nReset Requirements:\n1. Synchronous Reset\n- Problem explicitly states \"reset is a synchronous reset\"\n- Reset should be applied on positive clock edge\n- Active-high reset signal\n\nSignals Requiring Reset:\n1. Control Logic:\n```systemverilog\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    rate_counter <= '0;\n    // Any other control registers\n  end\nend\n```\n\n2. Data Path:\n- local_axist_pipe handles its own internal resets\n- Extra data register should be reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n  if (reset)\n    extra_data_reg <= '0;\n  else if (valid_transfer)\n    extra_data_reg <= inExtra;\nend\n```\n\nLatency:\n1. Minimum latency:\n- At least 1 clock cycle due to the local_axist_pipe\n- Additional cycle might be needed for rate control logic\n\nThroughput:\n1. Maximum throughput:\n- Limited by rate_numerator/rate_denominator ratio\n- One transfer possible per clock when rate allows\n- Must maintain AXI4-Stream protocol timing\n\nTiming Constraints:\n1. AXI4-Stream Protocol:\n- tvalid must not depend on tready\n- No combinational loops in ready/valid logic\n- Maintain proper handshaking timing\n\n2. Rate Control:\n- Rate calculation must complete within one clock cycle\n- Rate control decisions must be available for next cycle\n\nThe design should prioritize:\n1. Protocol compliance\n2. Deterministic latency\n3. Clean synchronous reset behavior\n4. Meeting timing for rate control calculationsWhat testbench and verification approach would you recommend? What corner cases need to be tested?\n [NEW STEP]\n \nHere's a comprehensive verification approach and test cases to consider:\n\nTestbench Structure:\n```systemverilog\nmodule tb_dut;\n  // Clock and reset generation\n  logic clock;\n  logic reset;\n  \n  // AXI4-Stream interfaces\n  AxiStreamType inAxi4St, outAxi4St;\n  logic inTready, outTready;\n  \n  // Rate control signals\n  logic [7:0] i_rate_numerator;\n  logic [7:0] i_rate_denominator;\n  \n  // DUT instantiation\n  dut #(\n    .AxiStreamType(AxiStreamType),\n    .ExtraDataWidth(1)\n  ) u_dut (/* ports */);\n```\n\nTest Cases:\n1. Basic Functionality:\n- Simple data transfer at full rate\n- Single packet transfers\n- Back-to-back packet transfers\n\n2. Rate Control Testing:\n```systemverilog\n// Test different rates\ntask test_rate(input [7:0] num, input [7:0] den);\n  i_rate_numerator = num;\n  i_rate_denominator = den;\n  // Send test pattern and verify rate\nendtask\n\ninitial begin\n  test_rate(8'd1, 8'd1);  // Full rate\n  test_rate(8'd1, 8'd2);  // Half rate\n  test_rate(8'd1, 8'd4);  // Quarter rate\nend\n```\n\n3. Corner Cases:\n- Edge rate values:\n  * Minimum rate (1/255)\n  * Maximum rate (1/1)\n  * Various fractions\n- Backpressure scenarios:\n  * Downstream not ready (outTready=0)\n  * Variable outTready patterns\n- Protocol corner cases:\n  * Zero-length packets\n  * Maximum length packets\n  * Back-to-back tlast\n- Reset conditions:\n  * Reset during transfer\n  * Reset between packets\n  * Reset with backpressure\n\n4. Coverage Points:\n```systemverilog\ncovergroup rate_cg;\n  cp_numerator: coverpoint i_rate_numerator;\n  cp_denominator: coverpoint i_rate_denominator;\n  cp_tready: coverpoint outTready;\n  cp_packet_size: coverpoint packet_size;\nendgroup\n```\n\n5. Assertions:\n```systemverilog\n// Protocol checks\nproperty valid_stable;\n  @(posedge clock) outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\n\n// Rate checking\nproperty rate_check;\n  @(posedge clock) transfer_count <= (total_cycles * i_rate_numerator / i_rate_denominator);\nendproperty\n```\n\n6. Performance Verification:\n- Measure actual throughput vs expected rate\n- Verify latency requirements\n- Check for protocol timing compliance\n\nVerification Environment:\n1. Self-checking testbench\n2. Scoreboarding for data integrity\n3. Coverage-driven verification\n4. Protocol checkers\n5. Performance monitors\n\nThis comprehensive approach ensures:\n- Functional correctness\n- Protocol compliance\n- Performance requirements\n- Corner case handling\n- Rate control accuracyWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me detail the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n\n1. Basic Protocol Testing:\n```systemverilog\n// Basic transfer scenarios\ntask test_basic_transfers;\n  // Single transfer\n  send_packet(1);\n  // Multiple transfers\n  send_packet(4);\n  // Back-to-back packets\n  repeat(5) send_packet(1);\nendtask\n```\n\n2. Rate Control Testing:\n```systemverilog\ntask test_rate_scenarios;\n  // Full rate\n  test_rate(8'h01, 8'h01);\n  // Half rate\n  test_rate(8'h01, 8'h02);\n  // Odd ratios\n  test_rate(8'h03, 8'h07);\nendtask\n```\n\n3. Backpressure Testing:\n```systemverilog\ntask test_backpressure;\n  // Random outTready\n  fork\n    drive_random_tready();\n    send_continuous_data();\n  join\nendtask\n```\n\n4. Reset Testing:\n```systemverilog\ntask test_reset_scenarios;\n  // Reset during transfer\n  fork\n    send_packet(16);\n    #10 reset = 1;\n    #11 reset = 0;\n  join\nendtask\n```\n\nAssertions:\n\n1. Protocol Assertions:\n```systemverilog\n// Valid stability\nproperty valid_stable;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property (valid_stable);\n\n// Data stability\nproperty data_stable;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> $stable(outAxi4St.tdata);\nendproperty\nassert property (data_stable);\n\n// TLAST consistency\nproperty tlast_valid;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tlast |-> outAxi4St.tvalid;\nendproperty\nassert property (tlast_valid);\n```\n\n2. Rate Control Assertions:\n```systemverilog\n// Rate compliance\nproperty rate_compliance;\n  @(posedge clock) disable iff (reset)\n    transfer_count <= (total_cycles * i_rate_numerator / i_rate_denominator);\nendproperty\nassert property (rate_compliance);\n\n// Valid denominator\nproperty valid_denominator;\n  @(posedge clock) i_rate_denominator != 0;\nendproperty\nassert property (valid_denominator);\n```\n\n3. Functional Assertions:\n```systemverilog\n// Extra data alignment\nproperty extra_data_aligned;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid |-> $stable(outExtra);\nendproperty\nassert property (extra_data_aligned);\n\n// Pipeline consistency\nproperty pipeline_consistency;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && outTready |-> ##1 !outAxi4St.tvalid || $changed(outAxi4St.tdata);\nendproperty\nassert property (pipeline_consistency);\n```\n\n4. Reset Assertions:\n```systemverilog\n// Reset behavior\nproperty reset_clear;\n  @(posedge clock)\n    reset |=> !outAxi4St.tvalid;\nendproperty\nassert property (reset_clear);\n```\n\nCoverage Points:\n\n```systemverilog\ncovergroup rate_coverage;\n  // Rate combinations\n  cp_rate: coverpoint {i_rate_numerator, i_rate_denominator} {\n    bins full_rate = {8'h01, 8'h01};\n    bins half_rate = {8'h01, 8'h02};\n    bins other_rates[] = default;\n  }\n  \n  // Transfer scenarios\n  cp_transfers: coverpoint transfer_length {\n    bins single = {1};\n    bins small[] = {[2:4]};\n    bins medium[] = {[5:16]};\n    bins large[] = {[17:$]};\n  }\n  \n  // Backpressure\n  cp_backpressure: coverpoint outTready {\n    bins no_backpressure = {1};\n    bins with_backpressure = {0};\n    bins transitions = (0 => 1), (1 => 0);\n  }\nendgroup\n```\n\nKey Test Aspects to Cover:\n1. Protocol compliance\n2. Rate control accuracy\n3. Backpressure handling\n4. Reset behavior\n5. Corner cases\n6. Performance metrics\n7. Data integrity\n8. Pipeline behavior\n\nThis comprehensive verification approach ensures thorough testing of all functional aspects and corner cases of the design.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. Rate Control Module:\n```systemverilog\nmodule rate_controller (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic [7:0]  i_rate_numerator,\n  input  logic [7:0]  i_rate_denominator,\n  output logic        rate_allow\n);\n  // Handles rate calculation and generates rate_allow signal\n  // Controls when transfers are permitted\n```\n\n2. Pipeline Interface Module:\n```systemverilog\nmodule pipeline_interface (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic        rate_allow,\n  // AXI Stream interfaces\n  local_axist_pipe instance\n  // Manages interface with local_axist_pipe module\n);\n  // Manages the local_axist_pipe instance\n  // Handles pipeline stage control\n```\n\n3. Extra Data Handler:\n```systemverilog\nmodule extra_data_handler #(\n  parameter int ExtraDataWidth = 1\n) (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic [ExtraDataWidth-1:0] inExtra,\n  output logic [ExtraDataWidth-1:0] outExtra\n  // Control signals\n);\n  // Manages extra data synchronization\n  // Ensures alignment with main data path\n```\n\n4. AXI Stream Protocol Manager:\n```systemverilog\nmodule axi_protocol_manager (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic        rate_allow,\n  // AXI Stream interfaces\n  input  AxiStreamType inAxi4St,\n  output logic        inTready,\n  output AxiStreamType outAxi4St,\n  input  logic        outTready\n);\n  // Manages AXI Stream protocol compliance\n  // Handles ready/valid handshaking\n```\n\nFunctional Responsibilities:\n\n1. Rate Control Module:\n- Implements rate limiting algorithm\n- Maintains rate counter\n- Generates rate_allow signal\n- Ensures compliance with numerator/denominator ratio\n\n2. Pipeline Interface Module:\n- Interfaces with local_axist_pipe\n- Manages pipeline stages\n- Controls data flow through pipeline\n- Handles pipeline backpressure\n\n3. Extra Data Handler:\n- Stores and forwards extra data\n- Maintains synchronization with main data\n- Handles extra data reset\n- Ensures proper alignment\n\n4. AXI Stream Protocol Manager:\n- Manages AXI Stream handshaking\n- Ensures protocol compliance\n- Controls tvalid/tready signals\n- Maintains packet boundaries\n\nIntegration:\n```systemverilog\nmodule dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  // ... ports ...\n);\n  \n  logic rate_allow;\n  \n  rate_controller u_rate_ctrl (\n    // ... ports ...\n  );\n  \n  pipeline_interface u_pipe_if (\n    // ... ports ...\n  );\n  \n  extra_data_handler u_extra_handler (\n    // ... ports ...\n  );\n  \n  axi_protocol_manager u_protocol_mgr (\n    // ... ports ...\n  );\n  \nendmodule\n```\n\nKey Interactions:\n1. Rate Controller \u2192 Protocol Manager\n   - Controls when transfers are allowed\n\n2. Protocol Manager \u2192 Pipeline Interface\n   - Manages data flow through pipeline\n\n3. Pipeline Interface \u2192 Extra Data Handler\n   - Synchronizes extra data with main data path\n\n4. All modules \u2192 Reset handling\n   - Coordinated reset response\n\nBenefits of this modular approach:\n1. Clear separation of concerns\n2. Easier testing and verification\n3. Better maintainability\n4. Simplified debugging\n5. Reusable components\n6. Cleaner code organization\n\nEach module can be developed and tested independently before integration.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide SystemVerilog code for each submodule and detail their critical interfaces:\n\n1. Rate Controller:\n```systemverilog\nmodule rate_controller (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic [7:0]  i_rate_numerator,\n  input  logic [7:0]  i_rate_denominator,\n  output logic        rate_allow\n);\n\n  logic [7:0] rate_counter;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      rate_counter <= 8'd0;\n    else if (rate_counter >= i_rate_denominator)\n      rate_counter <= rate_counter - i_rate_denominator + i_rate_numerator;\n    else\n      rate_counter <= rate_counter + i_rate_numerator;\n  end\n\n  assign rate_allow = (rate_counter >= i_rate_denominator);\n\nendmodule\n```\n\n2. Pipeline Interface:\n```systemverilog\nmodule pipeline_interface #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic        rate_allow,\n  \n  // AXI Stream interfaces\n  input  AxiStreamType inAxi4St,\n  output logic        inTready,\n  output AxiStreamType outAxi4St,\n  input  logic        outTready\n);\n\n  AxiStreamType [1:0] pipeAxi4St;\n  logic [1:0]         pipeTready;\n\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock      (clock),\n    .reset      (reset),\n    .inAxi4St   (inAxi4St),\n    .inTready   (inTready),\n    .pipeAxi4St (pipeAxi4St),\n    .pipeTready (pipeTready),\n    .outAxi4St  (outAxi4St),\n    .outTready  (outTready & rate_allow)\n  );\n\nendmodule\n```\n\n3. Extra Data Handler:\n```systemverilog\nmodule extra_data_handler #(\n  parameter int ExtraDataWidth = 1\n) (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic        valid_transfer,\n  input  logic [ExtraDataWidth-1:0] inExtra,\n  output logic [ExtraDataWidth-1:0] outExtra\n);\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      outExtra <= '0;\n    else if (valid_transfer)\n      outExtra <= inExtra;\n  end\n\nendmodule\n```\n\n4. AXI Protocol Manager:\n```systemverilog\nmodule axi_protocol_manager #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n  input  logic        clock,\n  input  logic        reset,\n  input  logic        rate_allow,\n  \n  // Pipeline interface signals\n  input  AxiStreamType pipe_in_data,\n  output logic        pipe_in_ready,\n  output AxiStreamType pipe_out_data,\n  input  logic        pipe_out_ready,\n  \n  // External AXI interfaces\n  input  AxiStreamType inAxi4St,\n  output logic        inTready,\n  output AxiStreamType outAxi4St,\n  input  logic        outTready\n);\n\n  // Input side control\n  assign inTready = rate_allow && pipe_in_ready;\n  \n  // Output side control\n  always_comb begin\n    outAxi4St = pipe_out_data;\n    outAxi4St.tvalid = pipe_out_data.tvalid && rate_allow;\n  end\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Rate Controller \u2194 Other Modules:\n```systemverilog\ninterface rate_if;\n  logic rate_allow;\n  logic [7:0] rate_numerator;\n  logic [7:0] rate_denominator;\nendinterface\n```\n\n2. Pipeline \u2194 Protocol Manager:\n```systemverilog\ninterface pipe_protocol_if #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n);\n  AxiStreamType data;\n  logic ready;\n  logic valid;\nendinterface\n```\n\n3. Main Data Path Integration:\n```systemverilog\nmodule dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  // ... standard ports ...\n);\n\n  logic rate_allow;\n  logic valid_transfer;\n\n  // Instantiate submodules\n  rate_controller u_rate_ctrl (\n    .clock            (clock),\n    .reset            (reset),\n    .i_rate_numerator (i_rate_numerator),\n    .i_rate_denominator(i_rate_denominator),\n    .rate_allow       (rate_allow)\n  );\n\n  // ... other module instantiations ...\n\n  // Transfer detection\n  assign valid_transfer = inAxi4St.tvalid && inTready;\n\nendmodule\n```\n\nCritical Interface Considerations:\n1. Timing Coordination\n   - All modules must respect rate_allow signal\n   - Synchronous handshaking between stages\n\n2. Protocol Compliance\n   - AXI Stream rules maintained across interfaces\n   - Valid/ready handshaking preserved\n\n3. Data Synchronization\n   - Extra data aligned with main data path\n   - Pipeline stages properly coordinated\n\n4. Reset Handling\n   - Coordinated reset across all modules\n   - Proper initialization of interfaces\n\nThis modular design allows for:\n- Independent testing of components\n- Clear interface boundaries\n- Easy maintenance and modifications\n- Reusable components\n- Clean separation of functionality\n\nEach interface is designed to maintain AXI4-Stream protocol compliance while supporting the rate limiting functionality.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- For this design, this input can be ignored and assumed the value is tied to 0.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_lite_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_lite_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/test_axist_rate_limit_lite_3/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// custom_tb.sv -- refactored from oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n// Does not check i_rate_by_frame=1\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule custom_tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b0;    // NOTE this custom_tb.sv has it tied to 0.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_lite_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv -- refactored from oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n// Does not check i_rate_by_frame=1\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b0;    // NOTE this tb.sv has it tied to 0.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_lite_3"
  },
  {
    "index": 6,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1,\n    parameter int unsigned NumPorts = 1\n)(\n    input  logic                        clock,\n    input  logic                        reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0]         inTready,\n    input  logic [ExtraDataWidth-1:0]   inExtra,\n    output AxiStreamType                outAxi4St,\n    input  logic                        outTready, \n    output logic [ExtraDataWidth-1:0]   outExtra,\n    input  logic [7:0]                  i_rate_numerator,\n    input  logic [7:0]                  i_rate_denominator,\n    input  logic                        i_rate_by_frame\n);\n\n    // Internal signals for rate control\n    logic [31:0] rate_counter;\n    logic [31:0] frame_counter;\n    logic frame_active;\n    logic transfer_allowed;\n    logic waiting_for_rate;\n\n    // Transfer valid when handshake completes\n    logic transfer_valid;\n    assign transfer_valid = inAxi4St[0].tvalid && inTready[0] && outTready;\n\n    // Mode 0 rate control logic\n    logic mode0_allow;\n    always_comb begin\n        if (rate_counter >= i_rate_denominator) begin\n            mode0_allow = 1'b0;\n        end else begin\n            mode0_allow = 1'b1;\n        end\n    end\n\n    // Mode 1 rate control logic  \n    logic mode1_allow;\n    always_comb begin\n        if (frame_active) begin\n            mode1_allow = 1'b1;\n        end else if (waiting_for_rate) begin\n            mode1_allow = 1'b0;\n        end else begin\n            mode1_allow = (frame_counter < i_rate_numerator);\n        end\n    end\n\n    // Combined rate control\n    assign transfer_allowed = i_rate_by_frame ? mode1_allow : mode0_allow;\n\n    // Rate counter for Mode 0\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            rate_counter <= '0;\n        end else if (!i_rate_by_frame) begin\n            if (transfer_valid) begin\n                if (rate_counter >= i_rate_denominator - i_rate_numerator) begin\n                    rate_counter <= rate_counter + i_rate_numerator - i_rate_denominator;\n                end else begin\n                    rate_counter <= rate_counter + i_rate_numerator;\n                end\n            end\n        end\n    end\n\n    // Frame tracking and Mode 1 control\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_active <= 1'b0;\n            frame_counter <= '0;\n            waiting_for_rate <= 1'b0;\n        end else if (i_rate_by_frame) begin\n            if (transfer_valid) begin\n                frame_active <= 1'b1;\n                frame_counter <= frame_counter + i_rate_denominator;\n                \n                if (inAxi4St[0].tlast) begin\n                    frame_active <= 1'b0;\n                    waiting_for_rate <= 1'b1;\n                end\n            end else if (waiting_for_rate) begin\n                if (frame_counter >= i_rate_numerator) begin\n                    frame_counter <= frame_counter - i_rate_numerator;\n                end else begin\n                    waiting_for_rate <= 1'b0;\n                    frame_counter <= '0;\n                end\n            end\n        end\n    end\n\n    // Output assignments\n    always_comb begin\n        // Default output assignments\n        outAxi4St = inAxi4St[0];\n        outAxi4St.tvalid = inAxi4St[0].tvalid && transfer_allowed;\n        inTready = '0;\n        inTready[0] = outTready && transfer_allowed;\n        outExtra = transfer_valid ? inExtra : '0;\n    end\n\n    // Assertions\n    property axi_valid_stable;\n        @(posedge clock) disable iff (reset)\n            outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\n    endproperty\n    assert property(axi_valid_stable);\n\n    property frame_mode_integrity;\n        @(posedge clock) disable iff (reset)\n            i_rate_by_frame && frame_active |-> !waiting_for_rate;\n    endproperty\n    assert property(frame_mode_integrity);\n\n    // Parameter checks\n    initial begin\n        assert (ExtraDataWidth > 0) else \n            $error(\"ExtraDataWidth must be greater than 0\");\n        assert (AxiStreamWidth == 8) else\n            $error(\"AxiStreamWidth must be 8 for this implementation\");\n        assert (NumPorts > 0) else\n            $error(\"NumPorts must be greater than 0\");\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output. This has two modes of rate limiting and both must be implemented.\nMode 0:\n  When input i_rate_by_frame=0, this is a rate limiter where outputs inTready and outAxi4St.tvalid are set to 0 at any point in the frame.\nMode 1:\n  When input i_rate_by_frame=1, this is a rate limiter where outputs inTready and outAxi4St.tvalid can only be 0 on the first data phit of a frame. They must be\n  held at 0 for enough cycles to satisfy the overal rate limiting.\n  For example, if i_rate_by_frame=1, i_rate_numerator=10, i_rate_demoninator=40, this is a 25% rate limiter. If we send a 100 data phit frame, it must be sent with\n  outAxi4St.tvalid=1 for all 100 data phits consecutively. But we need at least 400 cycles of inactively to satisfy the overall rate limiter for the next frame. In this mode\n  i_rate_by_frame=1, you need a larger internal counter than 8-bits, and you may consider it needs to consume/increment by one i_rate_demonitor per sent data phit, and then release/decrement one i_rate_numerator when no data phit is sent (inAxi4St.tvalid=0, outTready=0 during the frame), or after the frame is sent.\n  prior to being able to send again.\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis is an AXI4-Stream Rate Limiter module that controls the data flow rate between an input AXI4-Stream interface and an output AXI4-Stream interface. It has two operating modes:\n\n1. Mode 0 (i_rate_by_frame=0):\n- Can throttle data transfer at any point during transmission\n- Controls rate by toggling inTready and outAxi4St.tvalid signals\n- Rate limiting can occur on any data phit\n\n2. Mode 1 (i_rate_by_frame=1):\n- Can only throttle data at frame boundaries\n- Must transmit entire frames consecutively once started\n- Rate limiting occurs between frames\n- Uses a larger counter to track rate across frame boundaries\n\nThe rate limiting is controlled by:\n- i_rate_numerator/i_rate_denominator ratio (determines the target rate)\n- Extra data (inExtra) needs to be preserved alongside the main data path\n\nHigh-Level Block Diagram:\n```\n                     Rate Control Logic\n                            |\n                            v\ninAxi4St ---->[Rate Limiter Logic]----> outAxi4St\ninExtra  ---->                    ----> outExtra\n                     ^      ^\n                     |      |\n              i_rate_numerator\n              i_rate_denominator\n              i_rate_by_frame\n```\n\nKey Components:\n1. Rate Control Logic\n   - Counter mechanism\n   - Mode selection logic\n   - Rate calculation logic\n\n2. AXI4-Stream Interface Logic\n   - Input handshaking (inTready)\n   - Output handshaking (tvalid)\n   - Data path control\n\n3. Frame Tracking Logic\n   - tlast signal monitoring\n   - Frame boundary detection\n   - Mode-specific behavior controlWhat aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\n1. Explicitly Required Parameters:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n// Default structure contains:\n// - 8-bit tdata\n// - 1-bit tkeep\n// - 1-bit tuser\n// - 1-bit tlast\n// - 1-bit tvalid\n\nparameter int AxiStreamWidth = 8\n// Default width matching the default AxiStreamType\n\nparameter int unsigned ExtraDataWidth = 1\n// Default minimum width for extra data path\n```\n\n2. Additional Parameters that would be useful:\n\n```systemverilog\n// Counter width for Mode 1 rate limiting\nparameter int unsigned RATE_COUNTER_WIDTH = 32\n// Default: 32 bits to handle large frame accumulations\n\n// FIFO depth for buffering\nparameter int unsigned FIFO_DEPTH = 16\n// Default: 16 entries for reasonable buffering\n\n// Number of input ports\nparameter int unsigned NumPorts = 1\n// Default: Single input port configuration\n```\n\nRationale for Parameter Choices:\n\n1. AxiStreamType/AxiStreamWidth:\n- Default 8-bit width is good for basic data transfer\n- Allows expansion to wider data paths if needed\n- Includes all necessary AXI4-Stream signals\n\n2. ExtraDataWidth:\n- Default of 1 bit is minimum useful size\n- Can be increased based on application needs\n\n3. RATE_COUNTER_WIDTH:\n- 32 bits allows for large frame counting\n- Necessary for Mode 1 operation with large frames\n- Prevents counter overflow in most practical scenarios\n\n4. FIFO_DEPTH:\n- 16 entries provides reasonable buffering\n- Balance between resource usage and performance\n- Can be adjusted based on latency requirements\n\n5. NumPorts:\n- Default single port for simplest configuration\n- Can be increased for multi-input scenarios\n\nThese parameters provide flexibility while maintaining reasonable default values for basic operation. The values can be modified at instantiation time to meet specific requirements for:\n- Data width requirements\n- Buffering needs\n- Counter range requirements\n- Port configurationsHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n```\nInput Stage -> Rate Control -> Output Stage\n```\n\n1. Required Registers:\n```systemverilog\n// Frame tracking\nreg frame_active;        // Indicates if we're in an active frame\nreg [31:0] rate_counter; // Tracks rate accumulation\n\n// Rate control\nreg rate_allow_transfer; // Indicates if transfer is allowed based on rate\nreg [7:0] rate_num_reg; // Registered rate numerator\nreg [7:0] rate_den_reg; // Registered rate denominator\n\n// Mode 1 specific\nreg [31:0] frame_size_counter; // Tracks frame size for Mode 1\nreg waiting_period;      // Indicates if in waiting period after frame\n```\n\n2. Combinational Logic:\n\na. Rate Control Logic:\n```systemverilog\n// Rate calculation\nwire rate_exceeded = (rate_counter >= rate_den_reg);\n\n// Transfer enable logic\nwire transfer_allowed = !rate_exceeded && \n                       (i_rate_by_frame ? !waiting_period : 1'b1);\n\n// Transfer conditions\nwire valid_transfer = inAxi4St.tvalid && outTready && \n                     transfer_allowed;\n```\n\nb. AXI Handshaking Logic:\n```systemverilog\n// Input ready generation\nassign inTready = outTready && transfer_allowed;\n\n// Output valid generation\nassign outAxi4St.tvalid = inAxi4St.tvalid && transfer_allowed;\n```\n\n3. Data Path Logic:\n```systemverilog\n// Direct connection for data path\nassign outAxi4St.tdata = inAxi4St.tdata;\nassign outAxi4St.tkeep = inAxi4St.tkeep;\nassign outAxi4St.tuser = inAxi4St.tuser;\nassign outAxi4St.tlast = inAxi4St.tlast;\nassign outExtra = inExtra;\n```\n\n4. Rate Counter Update Logic:\n```systemverilog\n// Mode 0: Increment/decrement per cycle\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        rate_counter <= '0;\n    end else if (!i_rate_by_frame) begin\n        if (valid_transfer)\n            rate_counter <= rate_counter + rate_den_reg - rate_num_reg;\n        else if (rate_counter >= rate_num_reg)\n            rate_counter <= rate_counter - rate_num_reg;\n    end\nend\n\n// Mode 1: Frame-based counting\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_size_counter <= '0;\n        waiting_period <= 1'b0;\n    end else if (i_rate_by_frame) begin\n        if (valid_transfer) begin\n            if (inAxi4St.tlast) begin\n                waiting_period <= 1'b1;\n                frame_size_counter <= frame_size_counter * \n                                    (rate_den_reg/rate_num_reg);\n            end\n        end else if (waiting_period && frame_size_counter > 0) begin\n            frame_size_counter <= frame_size_counter - 1;\n        end else begin\n            waiting_period <= 1'b0;\n        end\n    end\nend\n```\n\n5. Frame Tracking Logic:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_active <= 1'b0;\n    end else if (valid_transfer) begin\n        if (inAxi4St.tlast)\n            frame_active <= 1'b0;\n        else if (inAxi4St.tvalid)\n            frame_active <= 1'b1;\n    end\nend\n```\n\nThis logic structure:\n1. Maintains rate limiting according to both modes\n2. Preserves AXI4-Stream protocol requirements\n3. Handles frame boundaries correctly\n4. Provides proper data flow control\n5. Manages rate counting and enforcement\n\nThe design uses a combination of sequential and combinational logic to:\n- Track frame boundaries\n- Calculate and enforce rate limits\n- Manage data transfer timing\n- Maintain protocol complianceWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description and typical AXI4-Stream requirements, let's analyze the timing aspects:\n\nClocking Requirements:\n1. Single Clock Domain\n- All logic is synchronized to the input 'clock'\n- No clock crossing required\n- Standard AXI4-Stream timing relationships must be maintained\n\nReset Requirements:\n1. Synchronous Reset (explicitly specified)\n- Reset signal name: 'reset'\n- Active-high reset\n- All state elements should be reset to known values\n\nSignals Requiring Reset:\n```systemverilog\n// Essential State Elements\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        rate_counter <= '0;\n        frame_active <= 1'b0;\n        waiting_period <= 1'b0;\n        frame_size_counter <= '0;\n        rate_num_reg <= '0;\n        rate_den_reg <= '0;\n    end\nend\n\n// Output Interface\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        outAxi4St.tvalid <= 1'b0;\n        inTready <= 1'b0;\n    end\nend\n```\n\nLatency Requirements:\n1. Minimum Latency:\n- Single cycle latency for data path\n- No additional buffering required for basic operation\n- Rate limiting logic should not add unnecessary delays\n\n2. Maximum Latency:\n- Not explicitly specified\n- Should be deterministic based on rate limiting calculations\n- Frame mode (Mode 1) may introduce longer delays between frames\n\nThroughput Requirements:\n1. Mode 0 (i_rate_by_frame = 0):\n- Throughput = (i_rate_numerator/i_rate_denominator) * max_throughput\n- Can throttle at any time\n- Must maintain specified rate across all transfers\n\n2. Mode 1 (i_rate_by_frame = 1):\n- Same average throughput as Mode 0\n- Must transmit full frames at line rate\n- Throttling only between frames\n- Larger gaps between frames to maintain average rate\n\nTiming Constraints:\n1. AXI4-Stream Protocol Timing:\n```systemverilog\n// No combinational loops between:\ntvalid -> tready\ntready -> tvalid\n\n// Valid/Ready Handshake:\ntransfer = tvalid && tready\n```\n\n2. Critical Paths:\n```systemverilog\n// Rate calculation path\nrate_counter -> rate_exceeded -> transfer_allowed -> \n                inTready/outAxi4St.tvalid\n\n// Frame tracking path\nframe_active -> waiting_period -> transfer_allowed -> \n                inTready/outAxi4St.tvalid\n```\n\n3. Setup/Hold Requirements:\n- All inputs must meet setup/hold times relative to clock\n- All outputs must be registered to maintain clean timing\n- Rate limiting calculations must complete within one clock cycle\n\nPerformance Considerations:\n1. Zero-Bubble Operation:\n- Back-to-back transfers should be possible when rate allows\n- No unnecessary bubbles in data stream\n\n2. Backpressure Handling:\n- Must respond immediately to outTready\n- Should not lose data when backpressured\n\n3. Rate Accuracy:\n- Must maintain precise rate limiting\n- Counter calculations must complete within clock period\n- No accumulation of rate errors over time\n\nThis timing structure ensures:\n- Deterministic operation\n- Protocol compliance\n- Accurate rate limiting\n- Clean timing boundaries\n- Proper reset behavior\n- Predictable latencyWhat verification considerations and test cases should be considered? What are the corner cases and potential issues to verify?\n [NEW STEP]\n \nLet's break down the verification considerations into different categories:\n\n1. Basic Functionality Test Cases:\n```systemverilog\n// Mode 0 Testing\n- Basic rate limiting at various rates\n- Single cycle transfers\n- Back-to-back transfers\n- Mid-frame throttling\n\n// Mode 1 Testing\n- Frame-based rate limiting\n- Various frame sizes\n- Back-to-back frames\n- Inter-frame gaps\n```\n\n2. Rate Limiting Corner Cases:\n\na. Extreme Rates:\n```systemverilog\n// Minimum Rate\ni_rate_numerator = 1;\ni_rate_denominator = 255;\n\n// Maximum Rate\ni_rate_numerator = 255;\ni_rate_denominator = 255;\n\n// Equal Values\ni_rate_numerator = i_rate_denominator;\n\n// Zero Rate\ni_rate_numerator = 0;\n```\n\nb. Frame Sizes (Mode 1):\n```systemverilog\n// Single-cycle frames\n- tlast on first cycle\n- Minimum frame size\n\n// Maximum length frames\n- Test counter overflow scenarios\n- Large frame accumulation\n\n// Variable length frames\n- Mix of short and long frames\n- Random frame sizes\n```\n\n3. Protocol Compliance Tests:\n\na. AXI4-Stream Rules:\n```systemverilog\n// Valid/Ready Handshaking\n- tvalid must not depend on tready\n- data must remain stable when tvalid high\n- all signals must be stable until handshake\n\n// Frame Integrity\n- tlast properly marked\n- no drops within frame\n- tuser and tkeep maintained\n```\n\nb. Extra Data Path:\n```systemverilog\n// Extra Data Verification\n- Extra data aligned with main data\n- Maintained through rate limiting\n- Properly handled during throttling\n```\n\n4. Edge Cases:\n\na. Reset Behavior:\n```systemverilog\n// Reset Scenarios\n- Reset during active transfer\n- Reset during frame\n- Reset during throttling\n- Multiple reset pulses\n```\n\nb. Backpressure:\n```systemverilog\n// Downstream Backpressure\n- Random outTready patterns\n- Long periods of outTready=0\n- Single cycle outTready pulses\n```\n\n5. Performance Verification:\n\na. Rate Accuracy:\n```systemverilog\n// Long-term Rate Monitoring\n- Measure actual vs. target rate\n- Accumulation of rate errors\n- Rate stability over time\n```\n\nb. Latency:\n```systemverilog\n// Latency Measurements\n- Minimum latency path\n- Maximum latency scenarios\n- Frame mode waiting periods\n```\n\n6. Potential Issues to Verify:\n\na. Counter Management:\n```systemverilog\n// Counter Issues\n- Overflow conditions\n- Underflow conditions\n- Counter reset behavior\n- Precision loss in calculations\n```\n\nb. Mode Switching:\n```systemverilog\n// Mode Transition\n- Changing modes during operation\n- Rate changes during operation\n- Parameter updates during operation\n```\n\n7. System-Level Considerations:\n\na. Integration Tests:\n```systemverilog\n// System Context\n- Multiple instances\n- Different parameter configurations\n- Clock domain interactions\n```\n\nb. Performance Monitoring:\n```systemverilog\n// Performance Metrics\n- Throughput measurements\n- Latency statistics\n- Resource utilization\n```\n\n8. Verification Environment:\n\na. Testbench Components:\n```systemverilog\n// Required Components\n- AXI4-Stream driver\n- Protocol checker\n- Rate monitor\n- Coverage collector\n- Scoreboard\n```\n\nb. Coverage Points:\n```systemverilog\n// Coverage Areas\n- Rate combinations\n- Frame sizes\n- Throttling patterns\n- Mode transitions\n- Reset scenarios\n```\n\n9. Stress Testing:\n\na. Load Conditions:\n```systemverilog\n// Stress Scenarios\n- Maximum data rate\n- Minimum data rate\n- Rapid rate changes\n- Continuous operation\n```\n\nb. Error Injection:\n```systemverilog\n// Error Scenarios\n- Protocol violations\n- Invalid rate parameters\n- Timing violations\n```\n\nThese verification considerations ensure:\n- Functional correctness\n- Protocol compliance\n- Performance requirements\n- Corner case handling\n- Robustness\n- System integration\n- Long-term stability\n- Error-free operationWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed for comprehensive verification:\n\n1. Basic Functional Assertions:\n```systemverilog\n// Protocol Compliance\nproperty axi_valid_stable;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property(axi_valid_stable);\n\n// Data Stability\nproperty axi_data_stable;\n  @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> \n    $stable(outAxi4St.tdata) && $stable(outAxi4St.tuser) && \n    $stable(outAxi4St.tkeep) && $stable(outAxi4St.tlast);\nendproperty\nassert property(axi_data_stable);\n```\n\n2. Rate Limiting Assertions:\n```systemverilog\n// Mode 0 Rate Checking\nproperty rate_limit_mode0;\n  @(posedge clock) disable iff (reset)\n    !i_rate_by_frame |-> \n    $countones(transfer_valid[*256]) <= i_rate_numerator;\nendproperty\nassert property(rate_limit_mode0);\n\n// Mode 1 Frame Integrity\nproperty frame_atomic_transfer;\n  @(posedge clock) disable iff (reset)\n    i_rate_by_frame && frame_active |-> \n    !waiting_period && inTready == outTready;\nendproperty\nassert property(frame_atomic_transfer);\n```\n\n3. Test Scenarios:\n\na. Basic Transfer Tests:\n```systemverilog\ntask test_basic_transfers;\n  // Single transfer\n  send_single_data(8'hAA);\n  \n  // Burst transfer\n  send_burst(10, 8'h55);\n  \n  // Random data transfer\n  send_random_data(100);\nendtask\n```\n\nb. Rate Limiting Tests:\n```systemverilog\ntask test_rate_limiting;\n  // Test various rates\n  static logic [7:0] rates[][] = '{\n    '{8'd1,   8'd4},   // 25%\n    '{8'd1,   8'd2},   // 50%\n    '{8'd3,   8'd4},   // 75%\n    '{8'd1,   8'd1},   // 100%\n    '{8'd1,   8'd255}, // Minimum\n    '{8'd255, 8'd255}  // Maximum\n  };\n  \n  foreach (rates[i]) begin\n    set_rate(rates[i][0], rates[i][1]);\n    verify_rate_compliance(1000); // Check over 1000 cycles\n  end\nendtask\n```\n\nc. Frame Mode Tests:\n```systemverilog\ntask test_frame_mode;\n  // Various frame sizes\n  static int frame_sizes[] = '{1, 2, 10, 100, 255};\n  \n  foreach (frame_sizes[i]) begin\n    send_frame(frame_sizes[i]);\n    check_inter_frame_gap();\n  end\n  \n  // Back-to-back frames\n  repeat(10) send_frame(10);\n  \n  // Mixed frame sizes\n  send_random_frames(100);\nendtask\n```\n\n4. Corner Case Assertions:\n```systemverilog\n// No data drops\nproperty no_data_drops;\n  @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && frame_active |-> \n    ##[1:$] (outAxi4St.tvalid && outTready);\nendproperty\nassert property(no_data_drops);\n\n// Rate counter overflow check\nproperty rate_counter_valid;\n  @(posedge clock) disable iff (reset)\n    rate_counter <= {32{1'b1}};\nendproperty\nassert property(rate_counter_valid);\n```\n\n5. Performance Monitoring:\n```systemverilog\n// Latency tracking\nproperty max_latency_check;\n  @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid |-> ##[1:MAX_LATENCY] outAxi4St.tvalid;\nendproperty\nassert property(max_latency_check);\n\n// Throughput monitoring\nsequence check_throughput;\n  int transfer_count;\n  @(posedge clock) (\n    transfer_count = $countones(transfer_valid[*1000]) &&\n    transfer_count >= min_expected_transfers\n  );\nendsequence\n```\n\n6. System-Level Tests:\n```systemverilog\ntask test_system_stress;\n  fork\n    // Randomized backpressure\n    apply_random_backpressure();\n    \n    // Continuous data streaming\n    stream_data_continuous();\n    \n    // Rate changes\n    random_rate_changes();\n  join\nendtask\n```\n\n7. Error Injection:\n```systemverilog\ntask test_error_handling;\n  // Invalid rates\n  set_rate(0, 0);\n  set_rate(255, 1);\n  \n  // Protocol violations\n  force_tvalid_drop();\n  force_tdata_change();\n  \n  // Reset during transfer\n  async_reset_during_transfer();\nendtask\n```\n\n8. Coverage Points:\n```systemverilog\ncovergroup rate_cg;\n  rate_num: coverpoint i_rate_numerator {\n    bins low = {[1:64]};\n    bins med = {[65:192]};\n    bins high = {[193:255]};\n  }\n  \n  rate_den: coverpoint i_rate_denominator {\n    bins low = {[1:64]};\n    bins med = {[65:192]};\n    bins high = {[193:255]};\n  }\n  \n  rate_cross: cross rate_num, rate_den;\nendgroup\n```\n\nThese test scenarios and assertions:\n- Verify protocol compliance\n- Ensure rate limiting accuracy\n- Check corner cases\n- Monitor performance\n- Detect timing violations\n- Verify error handling\n- Measure coverage\n- Stress test the design\n\nThe combination provides comprehensive verification of the rate limiter functionality.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules and their specific tasks:\n\n1. Rate Controller Module:\n```systemverilog\nmodule rate_controller (\n    // Calculates and enforces rate limiting\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        i_rate_by_frame,\n    input  logic        transfer_valid,\n    input  logic        frame_end,\n    output logic        transfer_allowed\n);\n```\nTasks:\n- Maintains rate counting logic\n- Implements both mode algorithms\n- Calculates when transfers are allowed\n- Tracks frame boundaries for Mode 1\n- Manages rate accumulation\n\n2. Frame Tracker:\n```systemverilog\nmodule frame_tracker (\n    // Tracks frame boundaries and status\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        tlast,\n    input  logic        transfer_valid,\n    output logic        frame_active,\n    output logic [31:0] frame_size,\n    output logic        frame_complete\n);\n```\nTasks:\n- Detects frame boundaries\n- Counts frame size\n- Maintains frame state\n- Signals frame completion\n- Tracks active frames\n\n3. AXI4-Stream Interface Controller:\n```systemverilog\nmodule axi4_interface_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n)(\n    // Manages AXI4-Stream handshaking\n    input  logic         clock,\n    input  logic         reset,\n    input  AxiStreamType inAxi4St,\n    input  logic         outTready,\n    input  logic         transfer_allowed,\n    output logic         inTready,\n    output AxiStreamType outAxi4St\n);\n```\nTasks:\n- Implements handshaking logic\n- Manages tvalid/tready signals\n- Ensures protocol compliance\n- Controls data flow\n- Maintains signal stability\n\n4. Extra Data Path Handler:\n```systemverilog\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n)(\n    // Manages extra data path\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic                      transfer_valid,\n    output logic [ExtraDataWidth-1:0] outExtra\n);\n```\nTasks:\n- Preserves extra data alignment\n- Ensures data consistency\n- Manages extra data timing\n- Maintains data correlation\n\n5. Mode Controller:\n```systemverilog\nmodule mode_controller (\n    // Manages operating mode logic\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        i_rate_by_frame,\n    input  logic        frame_active,\n    input  logic        rate_exceeded,\n    output logic        throttle_allowed,\n    output logic        waiting_period\n);\n```\nTasks:\n- Implements mode-specific behavior\n- Controls throttling permissions\n- Manages mode transitions\n- Coordinates rate limiting strategy\n\n6. Top-Level Integration (dut):\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n)(\n    // Top-level module integration\n    ...\n);\n```\nTasks:\n- Instantiates all submodules\n- Connects control signals\n- Manages parameter propagation\n- Coordinates overall operation\n- Provides external interface\n\nInternal Connections:\n```\n                        Mode Controller\n                             |\n                             v\nInput Interface --> Rate Controller --> Output Interface\n        |                   ^                |\n        v                   |                v\n  Frame Tracker ------------)          Extra Data Handler\n```\n\nBenefits of This Modular Structure:\n1. Separation of Concerns:\n- Each module has a specific responsibility\n- Easier to maintain and debug\n- Clear interfaces between components\n\n2. Reusability:\n- Modules can be used in other designs\n- Easy to modify individual components\n- Clean parameter passing\n\n3. Testability:\n- Each module can be tested independently\n- Clear verification boundaries\n- Simplified debugging\n\n4. Scalability:\n- Easy to add new features\n- Simple to modify existing functionality\n- Clean upgrade path\n\n5. Maintainability:\n- Localized changes\n- Clear documentation\n- Reduced complexity in each module\n\nThis modular approach provides:\n- Clear functional separation\n- Efficient testing strategy\n- Simple maintenance\n- Easy modifications\n- Clean interfaces\n- Logical organizationWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide the SystemVerilog code for each submodule and highlight their critical interfaces:\n\n1. Rate Controller:\n```systemverilog\nmodule rate_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        i_rate_by_frame,\n    input  logic        transfer_valid,\n    input  logic        frame_end,\n    output logic        transfer_allowed\n);\n\n    reg [31:0] rate_counter;\n    reg [31:0] frame_accumulation;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            rate_counter <= '0;\n            frame_accumulation <= '0;\n        end\n        else if (!i_rate_by_frame) begin\n            // Mode 0: Continuous rate limiting\n            if (transfer_valid)\n                rate_counter <= rate_counter + i_rate_denominator - i_rate_numerator;\n            else if (rate_counter >= i_rate_numerator)\n                rate_counter <= rate_counter - i_rate_numerator;\n        end\n        else begin\n            // Mode 1: Frame-based rate limiting\n            if (transfer_valid)\n                frame_accumulation <= frame_accumulation + i_rate_denominator;\n            else if (frame_end) begin\n                rate_counter <= frame_accumulation;\n                frame_accumulation <= '0;\n            end\n            else if (rate_counter > i_rate_numerator)\n                rate_counter <= rate_counter - i_rate_numerator;\n        end\n    end\n\n    assign transfer_allowed = i_rate_by_frame ? \n           (frame_accumulation == 0 && rate_counter < i_rate_denominator) :\n           (rate_counter < i_rate_denominator);\n\nendmodule\n```\n\n2. Frame Tracker:\n```systemverilog\nmodule frame_tracker (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        tlast,\n    input  logic        transfer_valid,\n    output logic        frame_active,\n    output logic [31:0] frame_size,\n    output logic        frame_complete\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_active <= 1'b0;\n            frame_size <= '0;\n            frame_complete <= 1'b0;\n        end\n        else begin\n            frame_complete <= 1'b0;\n            \n            if (transfer_valid) begin\n                if (tlast) begin\n                    frame_active <= 1'b0;\n                    frame_complete <= 1'b1;\n                    frame_size <= '0;\n                end\n                else if (tvalid) begin\n                    frame_active <= 1'b1;\n                    frame_size <= frame_size + 1;\n                end\n            end\n        end\n    end\n\nendmodule\n```\n\n3. AXI4-Stream Interface Controller:\n```systemverilog\nmodule axi4_interface_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n)(\n    input  logic         clock,\n    input  logic         reset,\n    input  AxiStreamType inAxi4St,\n    input  logic         outTready,\n    input  logic         transfer_allowed,\n    output logic         inTready,\n    output AxiStreamType outAxi4St\n);\n\n    // Direct connections for data path\n    assign outAxi4St.tdata = inAxi4St.tdata;\n    assign outAxi4St.tkeep = inAxi4St.tkeep;\n    assign outAxi4St.tuser = inAxi4St.tuser;\n    assign outAxi4St.tlast = inAxi4St.tlast;\n    \n    // Handshaking logic\n    assign inTready = outTready && transfer_allowed;\n    assign outAxi4St.tvalid = inAxi4St.tvalid && transfer_allowed;\n\nendmodule\n```\n\n4. Extra Data Handler:\n```systemverilog\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n)(\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic                      transfer_valid,\n    output logic [ExtraDataWidth-1:0] outExtra\n);\n\n    // Direct connection when transfer is valid\n    assign outExtra = transfer_valid ? inExtra : '0;\n\nendmodule\n```\n\n5. Mode Controller:\n```systemverilog\nmodule mode_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        i_rate_by_frame,\n    input  logic        frame_active,\n    input  logic        rate_exceeded,\n    output logic        throttle_allowed,\n    output logic        waiting_period\n);\n\n    reg waiting_state;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            waiting_state <= 1'b0;\n            waiting_period <= 1'b0;\n        end\n        else begin\n            if (i_rate_by_frame) begin\n                if (frame_active)\n                    waiting_state <= rate_exceeded;\n                else if (!rate_exceeded)\n                    waiting_state <= 1'b0;\n                    \n                waiting_period <= waiting_state;\n            end\n            else begin\n                waiting_state <= 1'b0;\n                waiting_period <= 1'b0;\n            end\n        end\n    end\n\n    assign throttle_allowed = i_rate_by_frame ? !frame_active : 1'b1;\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Rate Controller and Mode Controller:\n```systemverilog\n- transfer_allowed: Controls data flow\n- rate_exceeded: Indicates rate limit status\n```\n\n2. Between Frame Tracker and Mode Controller:\n```systemverilog\n- frame_active: Indicates active frame\n- frame_complete: Signals frame completion\n```\n\n3. Between Interface Controller and Rate Controller:\n```systemverilog\n- transfer_valid: Indicates successful transfer\n- transfer_allowed: Controls handshaking\n```\n\n4. Between Extra Data Handler and Interface Controller:\n```systemverilog\n- transfer_valid: Synchronizes extra data\n```\n\n5. Top-Level Integration Points:\n```systemverilog\n- Clock and reset distribution\n- Parameter propagation\n- AXI4-Stream interface signals\n- Rate control parameters\n```\n\nThese interfaces are critical for:\n- Maintaining protocol compliance\n- Ensuring proper rate limiting\n- Coordinating frame handling\n- Managing data flow\n- Synchronizing operations\n\nThe modular design allows for:\n- Clean separation of concerns\n- Easy testing and verification\n- Simple maintenance and modification\n- Clear signal relationships\n- Efficient debug capabilityWrite the top module (dut) that instantiates all these submodules and connects them together.\n [NEW STEP]\n \nHere's the top-level dut module that integrates all the submodules:\n\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n)(\n    input  logic                        clock,\n    input  logic                        reset,\n    input  AxiStreamType               inAxi4St,\n    output logic                       inTready,\n    input  logic [ExtraDataWidth-1:0]  inExtra,\n    output AxiStreamType               outAxi4St,\n    input  logic                       outTready,\n    output logic [ExtraDataWidth-1:0]  outExtra,\n    input  logic [7:0]                 i_rate_numerator,\n    input  logic [7:0]                 i_rate_denominator,\n    input  logic                       i_rate_by_frame\n);\n\n    // Internal signals\n    logic        transfer_valid;\n    logic        transfer_allowed;\n    logic        frame_active;\n    logic        frame_complete;\n    logic [31:0] frame_size;\n    logic        rate_exceeded;\n    logic        throttle_allowed;\n    logic        waiting_period;\n\n    // Calculate transfer_valid\n    assign transfer_valid = inAxi4St.tvalid && outTready && transfer_allowed;\n\n    // Instantiate Rate Controller\n    rate_controller rate_ctrl_inst (\n        .clock             (clock),\n        .reset            (reset),\n        .i_rate_numerator (i_rate_numerator),\n        .i_rate_denominator(i_rate_denominator),\n        .i_rate_by_frame  (i_rate_by_frame),\n        .transfer_valid   (transfer_valid),\n        .frame_end        (frame_complete),\n        .transfer_allowed (transfer_allowed)\n    );\n\n    // Instantiate Frame Tracker\n    frame_tracker frame_track_inst (\n        .clock          (clock),\n        .reset         (reset),\n        .tvalid        (inAxi4St.tvalid),\n        .tlast         (inAxi4St.tlast),\n        .transfer_valid(transfer_valid),\n        .frame_active  (frame_active),\n        .frame_size    (frame_size),\n        .frame_complete(frame_complete)\n    );\n\n    // Instantiate AXI4-Stream Interface Controller\n    axi4_interface_controller #(\n        .AxiStreamType(AxiStreamType)\n    ) axi4_if_ctrl_inst (\n        .clock           (clock),\n        .reset          (reset),\n        .inAxi4St       (inAxi4St),\n        .outTready      (outTready),\n        .transfer_allowed(transfer_allowed),\n        .inTready       (inTready),\n        .outAxi4St      (outAxi4St)\n    );\n\n    // Instantiate Extra Data Handler\n    extra_data_handler #(\n        .ExtraDataWidth(ExtraDataWidth)\n    ) extra_data_inst (\n        .inExtra       (inExtra),\n        .transfer_valid(transfer_valid),\n        .outExtra     (outExtra)\n    );\n\n    // Instantiate Mode Controller\n    mode_controller mode_ctrl_inst (\n        .clock          (clock),\n        .reset         (reset),\n        .i_rate_by_frame(i_rate_by_frame),\n        .frame_active  (frame_active),\n        .rate_exceeded (rate_exceeded),\n        .throttle_allowed(throttle_allowed),\n        .waiting_period(waiting_period)\n    );\n\n    // Assertions for verification\n    // Protocol compliance\n    property axi_valid_stable;\n        @(posedge clock) disable iff (reset)\n            outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\n    endproperty\n    assert property(axi_valid_stable);\n\n    // Data stability\n    property axi_data_stable;\n        @(posedge clock) disable iff (reset)\n            outAxi4St.tvalid && !outTready |=> \n            $stable(outAxi4St.tdata) && $stable(outAxi4St.tlast);\n    endproperty\n    assert property(axi_data_stable);\n\n    // Frame integrity\n    property frame_integrity;\n        @(posedge clock) disable iff (reset)\n            frame_active && i_rate_by_frame |-> !waiting_period;\n    endproperty\n    assert property(frame_integrity);\n\n    // Synthesis assertions\n    initial begin\n        // Parameter checks\n        assert (ExtraDataWidth > 0) else \n            $error(\"ExtraDataWidth must be greater than 0\");\n        assert (AxiStreamWidth == 8) else \n            $error(\"AxiStreamWidth must be 8 for this implementation\");\n    end\n\nendmodule\n```\n\nKey Features of the Integration:\n\n1. Signal Connections:\n- All clock and reset distributions\n- AXI4-Stream interface signals\n- Rate control parameters\n- Internal control signals\n\n2. Module Instantiations:\n- All submodules properly instantiated\n- Parameters passed correctly\n- Clear signal mappings\n\n3. Control Logic:\n- transfer_valid generation\n- Proper handshaking coordination\n- Mode control integration\n\n4. Verification Support:\n- Basic protocol assertions\n- Parameter checking\n- Signal stability verification\n\n5. Design Structure:\n- Clean hierarchy\n- Clear signal flow\n- Modular organization\n\nImportant Interfaces:\n\n1. External Interfaces:\n```systemverilog\n// AXI4-Stream\ninput  AxiStreamType inAxi4St\noutput logic        inTready\noutput AxiStreamType outAxi4St\ninput  logic        outTready\n\n// Rate Control\ninput  logic [7:0]  i_rate_numerator\ninput  logic [7:0]  i_rate_denominator\ninput  logic        i_rate_by_frame\n\n// Extra Data\ninput  logic [ExtraDataWidth-1:0] inExtra\noutput logic [ExtraDataWidth-1:0] outExtra\n```\n\n2. Internal Control:\n```systemverilog\n// Transfer Control\nlogic transfer_valid\nlogic transfer_allowed\n\n// Frame Control\nlogic frame_active\nlogic frame_complete\n\n// Mode Control\nlogic throttle_allowed\nlogic waiting_period\n```\n\nThis integration:\n- Maintains clean interfaces\n- Provides proper control flow\n- Supports both operating modes\n- Includes basic verification\n- Follows good design practices\n- Enables easy debugging\n- Supports maintenance and modification\n\nThe top-level module provides a complete integration of all submodules while maintaining:\n- Signal integrity\n- Protocol compliance\n- Rate limiting functionality\n- Frame handling\n- Extra data management\n- Verification support\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output. This has two modes of rate limiting and both must be implemented.\nMode 0:\n  When input i_rate_by_frame=0, this is a rate limiter where outputs inTready and outAxi4St.tvalid are set to 0 at any point in the frame.\nMode 1:\n  When input i_rate_by_frame=1, this is a rate limiter where outputs inTready and outAxi4St.tvalid can only be 0 on the first data phit of a frame. They must be\n  held at 0 for enough cycles to satisfy the overal rate limiting.\n  For example, if i_rate_by_frame=1, i_rate_numerator=10, i_rate_demoninator=40, this is a 25% rate limiter. If we send a 100 data phit frame, it must be sent with\n  outAxi4St.tvalid=1 for all 100 data phits consecutively. But we need at least 400 cycles of inactively to satisfy the overall rate limiter for the next frame. In this mode\n  i_rate_by_frame=1, you need a larger internal counter than 8-bits, and you may consider it needs to consume/increment by one i_rate_demonitor per sent data phit, and then release/decrement one i_rate_numerator when no data phit is sent (inAxi4St.tvalid=0, outTready=0 during the frame), or after the frame is sent.\n  prior to being able to send again.\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_2"
  },
  {
    "index": 8,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    // Internal signals\n    logic frame_start;\n    logic [7:0] parsed_data;\n    logic parsed_valid;\n    logic buffer_ready;\n    logic data_out_valid;\n    logic [7:0] buffered_data;\n    logic extraction_complete;\n    logic parsing_active;\n    logic output_enable;\n    logic first_beat;\n\n    // MAC extraction signals\n    logic [47:0] dest_mac_int;\n    logic [47:0] src_mac_int;\n\n    // Input handler\n    input_protocol_handler #(\n        .AxiStreamType(AxiStreamType)\n    ) u_input_handler (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .buffer_ready(buffer_ready),\n        .inTready(inTready),\n        .frame_start(frame_start),\n        .data_out(parsed_data),\n        .data_valid(parsed_valid)\n    );\n\n    // MAC extractor\n    mac_extractor #(\n        .AxiStreamWidth(AxiStreamWidth)\n    ) u_mac_extractor (\n        .clock(clock),\n        .reset(reset),\n        .frame_start(frame_start),\n        .data_in(parsed_data),\n        .data_valid(parsed_valid),\n        .dest_mac(dest_mac_int),\n        .src_mac(src_mac_int),\n        .extraction_complete(extraction_complete)\n    );\n\n    // Buffer controller\n    buffer_controller #(\n        .AxiStreamWidth(AxiStreamWidth),\n        .BUFFER_DEPTH(16)\n    ) u_buffer_ctrl (\n        .clock(clock),\n        .reset(reset),\n        .data_in(parsed_data),\n        .data_valid(parsed_valid),\n        .buffer_ready(buffer_ready),\n        .data_out(buffered_data),\n        .data_valid_out(data_out_valid),\n        .output_ready(outTready)\n    );\n\n    // Output handler\n    output_protocol_handler #(\n        .AxiStreamType(AxiStreamType)\n    ) u_output_handler (\n        .clock(clock),\n        .reset(reset),\n        .data_in(buffered_data),\n        .data_valid(data_out_valid),\n        .parsed_dest_mac(dest_mac_int),\n        .parsed_src_mac(src_mac_int),\n        .parsed_valid(extraction_complete),\n        .first_beat(first_beat),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\n\n    // Control FSM\n    control_fsm u_control (\n        .clock(clock),\n        .reset(reset),\n        .frame_start(frame_start),\n        .extraction_complete(extraction_complete),\n        .buffer_ready(buffer_ready),\n        .parsing_active(parsing_active),\n        .output_enable(output_enable),\n        .first_beat(first_beat)\n    );\n\n    // Output assignments for parsed MACs\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end else begin\n            outParsedValid <= first_beat && outAxi4St.tvalid;\n            if (extraction_complete) begin\n                outParsedDestMac <= dest_mac_int;\n                outParsedSourceMac <= src_mac_int;\n            end\n        end\n    end\n\nendmodule\n\nmodule input_protocol_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        buffer_ready,\n    output logic        inTready,\n    output logic        frame_start,\n    output logic [7:0]  data_out,\n    output logic        data_valid\n);\n\n    logic first_beat_r;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            first_beat_r <= 1'b1;\n            inTready <= 1'b0;\n            data_valid <= 1'b0;\n            frame_start <= 1'b0;\n        end else begin\n            inTready <= buffer_ready;\n            data_valid <= inAxi4St.tvalid && inTready;\n            frame_start <= inAxi4St.tvalid && inTready && first_beat_r;\n            \n            if (inAxi4St.tvalid && inTready) begin\n                if (inAxi4St.tlast)\n                    first_beat_r <= 1'b1;\n                else\n                    first_beat_r <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = inAxi4St.tdata;\n\nendmodule\n\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        extraction_complete\n);\n\n    logic [3:0] byte_counter;\n    logic collecting;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            collecting <= 1'b0;\n            extraction_complete <= 1'b0;\n            dest_mac <= '0;\n            src_mac <= '0;\n        end else begin\n            extraction_complete <= 1'b0;\n            \n            if (frame_start)\n                collecting <= 1'b1;\n                \n            if (collecting && data_valid) begin\n                case (byte_counter)\n                    4'd0: dest_mac[47:40] <= data_in;\n                    4'd1: dest_mac[39:32] <= data_in;\n                    4'd2: dest_mac[31:24] <= data_in;\n                    4'd3: dest_mac[23:16] <= data_in;\n                    4'd4: dest_mac[15:8]  <= data_in;\n                    4'd5: dest_mac[7:0]   <= data_in;\n                    4'd6: src_mac[47:40] <= data_in;\n                    4'd7: src_mac[39:32] <= data_in;\n                    4'd8: src_mac[31:24] <= data_in;\n                    4'd9: src_mac[23:16] <= data_in;\n                    4'd10: src_mac[15:8] <= data_in;\n                    4'd11: begin \n                        src_mac[7:0] <= data_in;\n                        extraction_complete <= 1'b1;\n                        collecting <= 1'b0;\n                    end\n                endcase\n                \n                if (collecting)\n                    byte_counter <= byte_counter + 1'b1;\n            end\n            \n            if (frame_start)\n                byte_counter <= '0;\n        end\n    end\n\nendmodule\n\nmodule buffer_controller #(\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned BUFFER_DEPTH = 16\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic        buffer_ready,\n    output logic [7:0]  data_out,\n    output logic        data_valid_out,\n    input  logic        output_ready\n);\n\n    logic [7:0] buffer [$:BUFFER_DEPTH-1];\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            buffer.delete();\n            data_valid_out <= 1'b0;\n        end else begin\n            if (data_valid && buffer_ready)\n                buffer.push_back(data_in);\n                \n            if (output_ready && data_valid_out)\n                void'(buffer.pop_front());\n                \n            data_valid_out <= buffer.size() > 0;\n        end\n    end\n    \n    assign buffer_ready = buffer.size() < BUFFER_DEPTH;\n    assign data_out = buffer.size() > 0 ? buffer[0] : '0;\n\nendmodule\n\nmodule output_protocol_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    input  logic [47:0] parsed_dest_mac,\n    input  logic [47:0] parsed_src_mac,\n    input  logic        parsed_valid,\n    input  logic        first_beat,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outAxi4St <= '0;\n        end else begin\n            outAxi4St.tvalid <= data_valid;\n            outAxi4St.tdata <= data_in;\n            outAxi4St.tkeep <= 1'b1;\n            outAxi4St.tuser <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule control_fsm (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic        extraction_complete,\n    input  logic        buffer_ready,\n    output logic        parsing_active,\n    output logic        output_enable,\n    output logic        first_beat\n);\n\n    typedef enum logic [1:0] {\n        IDLE,\n        PARSING,\n        FORWARDING\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            current_state <= IDLE;\n            first_beat <= 1'b0;\n        end else begin\n            current_state <= next_state;\n            \n            if (frame_start)\n                first_beat <= 1'b1;\n            else if (parsing_active)\n                first_beat <= 1'b0;\n        end\n    end\n    \n    always_comb begin\n        next_state = current_state;\n        parsing_active = 1'b0;\n        output_enable = 1'b0;\n        \n        case (current_state)\n            IDLE: begin\n                if (frame_start)\n                    next_state = PARSING;\n            end\n            \n            PARSING: begin\n                parsing_active = 1'b1;\n                if (extraction_complete)\n                    next_state = FORWARDING;\n            end\n            \n            FORWARDING: begin\n                output_enable = 1'b1;\n                if (buffer_ready)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\n1. This module is a MAC address parser/extractor for Ethernet frames that:\n   - Receives Ethernet frames via AXI4-Stream interface (input)\n   - Extracts Destination MAC (first 6 bytes) and Source MAC (next 6 bytes) from the frame header\n   - Outputs the same frame on another AXI4-Stream interface (possibly delayed)\n   - Provides the parsed MAC addresses and a valid signal aligned with the first data beat of the output frame\n\nHigh-Level Block Diagram:\n```\n                                   +------------------------+\n                                   |                        |\ninAxi4St ----------------------->  |                        |\n                                  |    MAC Parser/Buffer    | -----> outAxi4St\ninTready <-----------------------  |                        |\n                                  |                        | -----> outParsedDestMac[47:0]\noutTready ---------------------->  |                        | -----> outParsedSourceMac[47:0]\n                                  |                        | -----> outParsedValid\nclock    ---------------------->   |                        |\nreset    ---------------------->   |                        |\n                                  +------------------------+\n```\n\nKey Components:\n1. Input Interface Handler\n   - Manages AXI4-Stream input protocol\n   - Generates inTready signal\n\n2. MAC Extraction Logic\n   - Buffers and extracts 12 bytes for MAC addresses\n   - Handles big-endian to little-endian conversion if needed\n   - Aligns extracted data with first output beat\n\n3. Output Interface Handler\n   - Manages AXI4-Stream output protocol\n   - Buffers data for proper timing alignment\n   - Generates parsed MAC outputs and valid signal\n\nThe module's complexity varies based on the AXI4-Stream data width (parameter AxiStreamWidth), requiring different amounts of buffering and timing alignment.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nLet me outline the key parameterizable aspects and their reasonable default values:\n\nKey Parameterizable Aspects:\n\n1. AXI4-Stream Interface Width:\n```systemverilog\nparameter int unsigned AxiStreamWidth = 8  // Already specified in requirements\n```\n- Common values: 8, 16, 32, 64, 128 bits\n- Default: 8 bits (as specified)\n- Affects buffering depth and parsing latency\n\n2. AXI4-Stream Type Structure:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s  // Already specified\n```\n- Contains tdata, tkeep, tuser, tlast, tvalid fields\n- Default: 8-bit version as shown in requirements\n\n3. Additional Useful Parameters (if needed):\n```systemverilog\nparameter int unsigned MAC_ADDR_WIDTH = 48    // Width of MAC address\nparameter int unsigned ETH_HEADER_BYTES = 12  // Total bytes to parse (6+6)\n```\n\n4. Derived Parameters (calculated from other parameters):\n```systemverilog\nlocalparam int unsigned BYTES_PER_TRANSFER = AxiStreamWidth/8;\nlocalparam int unsigned BUFFER_DEPTH = (ETH_HEADER_BYTES + BYTES_PER_TRANSFER - 1) / BYTES_PER_TRANSFER;\n```\n\nReasonable Default Values:\n1. For 8-bit data width:\n   - Buffer depth: 12 transfers needed\n   - Latency: 11 cycles minimum\n\n2. For 32-bit data width:\n   - Buffer depth: 3 transfers needed\n   - Latency: 2 cycles minimum\n\n3. For 128-bit data width:\n   - Buffer depth: 1 transfer needed\n   - Latency: 0 cycles possible\n\nKey Considerations:\n1. The parameters should maintain flexibility while ensuring:\n   - Efficient resource usage\n   - Proper timing alignment\n   - Correct data extraction regardless of width\n\n2. The module should handle:\n   - Different AXI4-Stream widths efficiently\n   - Proper alignment of MAC addresses\n   - Correct timing of parsed output signals\n\nThe parameterization allows the module to be used in various system configurations while maintaining functionality.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n1. Input Capture and Buffering:\n```systemverilog\n// Input buffer registers\nlogic [AxiStreamWidth-1:0] data_buffer[$]; // Queue for storing input data\nlogic [47:0] dest_mac_reg;   // Register for destination MAC\nlogic [47:0] src_mac_reg;    // Register for source MAC\nlogic parsing_active;        // State tracking\nlogic [3:0] byte_counter;    // Track bytes received\n```\n\n2. MAC Address Extraction Logic:\n```systemverilog\n// For 8-bit width example\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        byte_counter <= '0;\n        parsing_active <= 1'b0;\n    end\n    else if (inAxi4St.tvalid && inTready) begin\n        case (byte_counter)\n            // Destination MAC\n            0: dest_mac_reg[47:40] <= inAxi4St.tdata;\n            1: dest_mac_reg[39:32] <= inAxi4St.tdata;\n            // ... continue for all bytes\n            // Source MAC\n            6: src_mac_reg[47:40] <= inAxi4St.tdata;\n            // ... continue for all bytes\n        endcase\n        byte_counter <= byte_counter + 1;\n    end\nend\n```\n\n3. Output Buffer Management:\n```systemverilog\n// Output buffer and control\nlogic [AxiStreamWidth-1:0] output_buffer[$]; // Queue for output data\nlogic output_valid_reg;\nlogic first_beat;           // Track first beat of output frame\n```\n\nRequired Registers:\n1. State Registers:\n```systemverilog\ntypedef enum logic [1:0] {\n    IDLE,\n    PARSING,\n    FORWARDING\n} state_t;\nstate_t current_state;\n```\n\n2. Control Registers:\n```systemverilog\nlogic parsed_valid_reg;\nlogic first_beat_reg;\nlogic [47:0] parsed_dest_mac_reg;\nlogic [47:0] parsed_src_mac_reg;\n```\n\n3. Buffer Control:\n```systemverilog\nlogic buffer_full;\nlogic buffer_empty;\nlogic can_accept_input;\nlogic can_output_data;\n```\n\nCombinational Logic:\n1. Ready Signal Generation:\n```systemverilog\nassign inTready = !buffer_full && can_accept_input;\n```\n\n2. Output Control:\n```systemverilog\nassign outAxi4St.tvalid = !buffer_empty && can_output_data;\nassign outParsedValid = first_beat_reg && outAxi4St.tvalid;\n```\n\n3. MAC Address Alignment:\n```systemverilog\n// Byte ordering logic for big-endian to little-endian conversion\nalways_comb begin\n    outParsedDestMac = {dest_mac_reg[7:0], dest_mac_reg[15:8], ...};\n    outParsedSourceMac = {src_mac_reg[7:0], src_mac_reg[15:8], ...};\nend\n```\n\n4. Buffer Management Logic:\n```systemverilog\n// Buffer full/empty conditions\nassign buffer_full = (data_buffer.size() >= BUFFER_DEPTH);\nassign buffer_empty = (data_buffer.size() == 0);\n```\n\nKey Processing Considerations:\n1. Handle different data widths efficiently\n2. Maintain proper timing alignment\n3. Ensure correct byte ordering\n4. Manage backpressure through ready signals\n5. Track frame boundaries using tlast\n6. Support continuous streaming of frames\n\nThis structure allows for efficient processing while maintaining AXI4-Stream protocol compliance and proper MAC address extraction.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me break down the timing, latency, throughput, and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock;  // Single system clock\ninput logic reset;  // Synchronous reset (specified in requirements)\n```\n\nLatency Requirements:\n1. Variable based on AxiStreamWidth:\n```systemverilog\n// Examples of minimum latency:\n// For 8-bit width:  11 cycles (need to collect 12 bytes)\n// For 16-bit width: 5 cycles  (need to collect 6 words)\n// For 32-bit width: 2 cycles  (need to collect 3 words)\n// For 64-bit width: 1 cycle   (need to collect 2 words)\n// For 128-bit width: 0 cycles (all data available in first word)\n```\n\nThroughput Requirements:\n1. Full AXI4-Stream throughput:\n```systemverilog\n// No artificial throughput limitations\n// One transfer per clock when:\n//   inAxi4St.tvalid && inTready\n//   outAxi4St.tvalid && outTready\n```\n\nReset Requirements (Synchronous):\n1. Signals requiring reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // State machine\n        current_state <= IDLE;\n        \n        // Control registers\n        byte_counter <= '0;\n        parsing_active <= 1'b0;\n        first_beat_reg <= 1'b0;\n        parsed_valid_reg <= 1'b0;\n        \n        // Output registers\n        outAxi4St <= '0;\n        outParsedValid <= 1'b0;\n        outParsedDestMac <= '0;\n        outParsedSourceMac <= '0;\n        \n        // Buffer control\n        data_buffer.delete(); // Clear queue\n        output_buffer.delete();\n    end\nend\n```\n\nTiming Constraints:\n1. AXI4-Stream Protocol Timing:\n```systemverilog\n// Valid to Ready timing:\n//   tvalid must remain stable until ready\n//   data must remain stable when tvalid high until ready\nproperty valid_stable;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |-> ##1 $stable(inAxi4St);\nendproperty\n```\n\n2. Frame Boundary Timing:\n```systemverilog\n// First beat detection\nalways_ff @(posedge clock) begin\n    if (reset)\n        first_beat <= 1'b1;\n    else if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast)\n            first_beat <= 1'b1;\n        else\n            first_beat <= 1'b0;\n    end\nend\n```\n\n3. Output Alignment:\n```systemverilog\n// Ensure parsed MAC addresses align with first beat\nalways_ff @(posedge clock) begin\n    if (reset)\n        outParsedValid <= 1'b0;\n    else\n        outParsedValid <= first_beat && outAxi4St.tvalid;\nend\n```\n\nKey Timing Considerations:\n1. Synchronous Operation:\n   - All state changes on clock edge\n   - Synchronous reset as specified\n   - No asynchronous paths\n\n2. Throughput Maintenance:\n   - No artificial stalls\n   - Backpressure only when necessary\n   - Continuous frame processing\n\n3. Latency Management:\n   - Minimum latency based on data width\n   - Consistent frame-to-frame timing\n   - Proper alignment of parsed data\n\n4. Protocol Compliance:\n   - AXI4-Stream handshaking rules\n   - Frame boundary preservation\n   - Valid/Ready timing requirements\n\nThese timing and reset specifications ensure reliable operation while maintaining protocol compliance and required functionality.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed to verify this module:\n\nTest Scenarios:\n1. Basic Functionality Tests:\n```systemverilog\n// Single frame test\ntask test_single_frame;\n    // Send single frame with known MACs\n    logic [47:0] test_dest_mac = 48'h112233445566;\n    logic [47:0] test_src_mac = 48'hAABBCCDDEEFF;\n    send_frame(test_dest_mac, test_src_mac);\n    // Verify extracted MACs\n    check_parsed_macs(test_dest_mac, test_src_mac);\nendtask\n```\n\n2. Protocol Edge Cases:\n```systemverilog\n// Back-to-back frames\ntask test_back_to_back;\n    // Send multiple frames without gaps\n    repeat(5) begin\n        send_frame(random_mac(), random_mac());\n    end\nendtask\n\n// Backpressure scenarios\ntask test_backpressure;\n    fork\n        send_frame(random_mac(), random_mac());\n        random_backpressure(); // Toggle outTready randomly\n    join\nendtask\n```\n\n3. Error Conditions:\n```systemverilog\n// Incomplete frame test\ntask test_incomplete_frame;\n    // Send partial frame\n    send_partial_frame();\n    // Verify error handling\nendtask\n\n// Reset during transfer\ntask test_reset_during_transfer;\n    fork\n        send_frame(random_mac(), random_mac());\n        @(posedge clock) #2 reset <= 1'b1;\n    join\nendtask\n```\n\nAssertions:\n1. Protocol Compliance:\n```systemverilog\n// Valid/Ready Handshake\nproperty valid_ready_handshake;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |-> ##1 $stable(inAxi4St);\nendproperty\nassert property(valid_ready_handshake);\n\n// TLAST must be accompanied by TVALID\nproperty tlast_requires_valid;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tlast |-> inAxi4St.tvalid;\nendproperty\nassert property(tlast_requires_valid);\n```\n\n2. Functional Checks:\n```systemverilog\n// Parsed MAC valid timing\nproperty parsed_mac_valid_timing;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |-> outAxi4St.tvalid && first_beat;\nendproperty\nassert property(parsed_mac_valid_timing);\n\n// MAC alignment check\nproperty mac_alignment;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |-> !$isunknown({outParsedDestMac, outParsedSourceMac});\nendproperty\nassert property(mac_alignment);\n```\n\n3. State Machine Checks:\n```systemverilog\n// State transitions\nproperty valid_state_transitions;\n    @(posedge clock) disable iff (reset)\n    (current_state == PARSING) |-> \n        ##[1:12] (current_state == FORWARDING);\nendproperty\nassert property(valid_state_transitions);\n\n// No stuck states\nproperty no_stuck_states;\n    @(posedge clock) disable iff (reset)\n    current_state != IDLE |-> \n        ##[1:100] (current_state == IDLE);\nendproperty\nassert property(no_stuck_states);\n```\n\n4. Buffer Management:\n```systemverilog\n// Buffer overflow check\nproperty no_buffer_overflow;\n    @(posedge clock) disable iff (reset)\n    data_buffer.size() <= BUFFER_DEPTH;\nendproperty\nassert property(no_buffer_overflow);\n\n// Data ordering\nproperty output_order_maintained;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && outTready |-> \n        ##1 $stable(output_buffer.size());\nendproperty\nassert property(output_order_maintained);\n```\n\nCoverage Points:\n```systemverilog\ncovergroup mac_parser_cg;\n    state_cp: coverpoint current_state {\n        bins all_states[] = {IDLE, PARSING, FORWARDING};\n        bins transitions[] = (IDLE => PARSING => FORWARDING => IDLE);\n    }\n    \n    buffer_cp: coverpoint data_buffer.size() {\n        bins empty = {0};\n        bins partial = {[1:BUFFER_DEPTH-1]};\n        bins full = {BUFFER_DEPTH};\n    }\n    \n    backpressure_cp: coverpoint {inTready, outTready} {\n        bins no_backpressure = {2'b11};\n        bins input_backpressure = {2'b01};\n        bins output_backpressure = {2'b10};\n    }\nendgroup\n```\n\nTest Strategy:\n1. Unit-level tests\n2. Random stimulus\n3. Corner cases\n4. Performance testing\n5. Error injection\n6. Reset testing\n7. Coverage-driven verification\n\nThese tests and assertions help ensure:\n- Protocol compliance\n- Functional correctness\n- Error handling\n- Performance requirements\n- Corner case behaviorWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical submodules:\n\n1. Input Protocol Handler:\n```systemverilog\nmodule input_protocol_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output logic        frame_start,\n    output logic [7:0]  data_out,\n    output logic        data_valid\n);\n    // Handles AXI4-Stream input protocol\n    // Detects frame boundaries\n    // Generates frame_start signal\n    // Manages input handshaking\nendmodule\n```\n\n2. MAC Address Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        extraction_complete\n);\n    // Collects bytes for MAC addresses\n    // Handles byte ordering (big-endian)\n    // Signals when extraction is complete\nendmodule\n```\n\n3. Data Buffer Controller:\n```systemverilog\nmodule buffer_controller #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic        buffer_ready,\n    output logic [7:0]  data_out,\n    output logic        data_valid_out,\n    input  logic        output_ready\n);\n    // Manages data buffering\n    // Handles backpressure\n    // Controls data flow timing\nendmodule\n```\n\n4. Output Protocol Handler:\n```systemverilog\nmodule output_protocol_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    input  logic [47:0] parsed_dest_mac,\n    input  logic [47:0] parsed_src_mac,\n    input  logic        parsed_valid,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    // Generates AXI4-Stream output\n    // Aligns parsed MAC data\n    // Manages output handshaking\nendmodule\n```\n\n5. Control State Machine:\n```systemverilog\nmodule control_fsm (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic        extraction_complete,\n    input  logic        buffer_ready,\n    output logic        parsing_active,\n    output logic        output_enable,\n    output logic        first_beat\n);\n    // Main control state machine\n    // Coordinates between submodules\n    // Manages operational states\n    // Tracks frame progress\nendmodule\n```\n\nTop-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n    // Internal signals\n    logic frame_start, parsing_active;\n    logic [7:0] internal_data;\n    logic data_valid, extraction_complete;\n\n    // Instantiate submodules\n    input_protocol_handler input_handler (/*...*/);\n    mac_extractor mac_parser (/*...*/);\n    buffer_controller buffer_ctrl (/*...*/);\n    output_protocol_handler output_handler (/*...*/);\n    control_fsm controller (/*...*/);\n\nendmodule\n```\n\nInteractions between blocks:\n1. Data Flow:\n   - Input Handler \u2192 MAC Extractor \u2192 Buffer Controller \u2192 Output Handler\n   \n2. Control Flow:\n   - Control FSM coordinates all other blocks\n   - Generates control signals for synchronization\n   \n3. Status Signals:\n   - Each block provides status to Control FSM\n   - Control FSM manages overall operation\n\nThis modular approach provides:\n- Clear separation of concerns\n- Easier testing and verification\n- Simplified maintenance\n- Better reusability\n- Clearer documentationWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write the SystemVerilog code for each submodule and highlight their critical interfaces:\n\n1. Input Protocol Handler:\n```systemverilog\nmodule input_protocol_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        buffer_ready,    // From Buffer Controller\n    output logic        inTready,\n    output logic        frame_start,\n    output logic [7:0]  data_out,\n    output logic        data_valid\n);\n\n    logic first_beat_r;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            first_beat_r <= 1'b1;\n            inTready <= 1'b0;\n            data_valid <= 1'b0;\n            frame_start <= 1'b0;\n        end else begin\n            inTready <= buffer_ready;\n            data_valid <= inAxi4St.tvalid && inTready;\n            frame_start <= inAxi4St.tvalid && inTready && first_beat_r;\n            \n            if (inAxi4St.tvalid && inTready) begin\n                if (inAxi4St.tlast)\n                    first_beat_r <= 1'b1;\n                else\n                    first_beat_r <= 1'b0;\n            end\n        end\n    end\n\n    assign data_out = inAxi4St.tdata;\n\nendmodule\n```\n\n2. MAC Extractor:\n```systemverilog\nmodule mac_extractor #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic [47:0] dest_mac,\n    output logic [47:0] src_mac,\n    output logic        extraction_complete\n);\n\n    logic [3:0] byte_counter;\n    logic collecting;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            collecting <= 1'b0;\n            extraction_complete <= 1'b0;\n            dest_mac <= '0;\n            src_mac <= '0;\n        end else begin\n            extraction_complete <= 1'b0;\n            \n            if (frame_start)\n                collecting <= 1'b1;\n                \n            if (collecting && data_valid) begin\n                case (byte_counter)\n                    // Destination MAC\n                    4'd0: dest_mac[47:40] <= data_in;\n                    4'd1: dest_mac[39:32] <= data_in;\n                    4'd2: dest_mac[31:24] <= data_in;\n                    4'd3: dest_mac[23:16] <= data_in;\n                    4'd4: dest_mac[15:8]  <= data_in;\n                    4'd5: dest_mac[7:0]   <= data_in;\n                    // Source MAC\n                    4'd6: src_mac[47:40] <= data_in;\n                    4'd7: src_mac[39:32] <= data_in;\n                    4'd8: src_mac[31:24] <= data_in;\n                    4'd9: src_mac[23:16] <= data_in;\n                    4'd10: src_mac[15:8] <= data_in;\n                    4'd11: begin \n                        src_mac[7:0] <= data_in;\n                        extraction_complete <= 1'b1;\n                        collecting <= 1'b0;\n                    end\n                endcase\n                \n                if (collecting)\n                    byte_counter <= byte_counter + 1'b1;\n            end\n            \n            if (frame_start)\n                byte_counter <= '0;\n        end\n    end\n\nendmodule\n```\n\n3. Buffer Controller:\n```systemverilog\nmodule buffer_controller #(\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned BUFFER_DEPTH = 16\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    output logic        buffer_ready,\n    output logic [7:0]  data_out,\n    output logic        data_valid_out,\n    input  logic        output_ready\n);\n\n    logic [7:0] buffer [$:BUFFER_DEPTH-1];\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            buffer.delete();\n            data_valid_out <= 1'b0;\n        end else begin\n            // Input handling\n            if (data_valid && buffer_ready)\n                buffer.push_back(data_in);\n                \n            // Output handling\n            if (output_ready && data_valid_out)\n                void'(buffer.pop_front());\n                \n            data_valid_out <= buffer.size() > 0;\n        end\n    end\n    \n    assign buffer_ready = buffer.size() < BUFFER_DEPTH;\n    assign data_out = buffer.size() > 0 ? buffer[0] : '0;\n\nendmodule\n```\n\n4. Output Protocol Handler:\n```systemverilog\nmodule output_protocol_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  data_in,\n    input  logic        data_valid,\n    input  logic [47:0] parsed_dest_mac,\n    input  logic [47:0] parsed_src_mac,\n    input  logic        parsed_valid,\n    input  logic        first_beat,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outAxi4St <= '0;\n        end else begin\n            outAxi4St.tvalid <= data_valid;\n            outAxi4St.tdata <= data_in;\n            \n            // Other AXI signals would be handled here\n            outAxi4St.tkeep <= 1'b1;\n            outAxi4St.tuser <= 1'b0;\n            // tlast would be determined by frame boundaries\n        end\n    end\n\nendmodule\n```\n\n5. Control FSM:\n```systemverilog\nmodule control_fsm (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        frame_start,\n    input  logic        extraction_complete,\n    input  logic        buffer_ready,\n    output logic        parsing_active,\n    output logic        output_enable,\n    output logic        first_beat\n);\n\n    typedef enum logic [1:0] {\n        IDLE,\n        PARSING,\n        FORWARDING\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            current_state <= IDLE;\n            first_beat <= 1'b0;\n        end else begin\n            current_state <= next_state;\n            \n            if (frame_start)\n                first_beat <= 1'b1;\n            else if (parsing_active)\n                first_beat <= 1'b0;\n        end\n    end\n    \n    always_comb begin\n        next_state = current_state;\n        parsing_active = 1'b0;\n        output_enable = 1'b0;\n        \n        case (current_state)\n            IDLE: begin\n                if (frame_start)\n                    next_state = PARSING;\n            end\n            \n            PARSING: begin\n                parsing_active = 1'b1;\n                if (extraction_complete)\n                    next_state = FORWARDING;\n            end\n            \n            FORWARDING: begin\n                output_enable = 1'b1;\n                if (buffer_ready)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n```\n\nCritical Interfaces:\n1. Between Input Handler and MAC Extractor:\n- frame_start signal\n- data_valid and data paths\n\n2. Between MAC Extractor and Buffer Controller:\n- extraction_complete signal\n- data flow control\n\n3. Between Buffer Controller and Output Handler:\n- buffer status signals\n- data transfer coordination\n\n4. Control FSM interfaces with all modules:\n- State control signals\n- Synchronization points\n- Flow control\n\n5. Global signals across all modules:\n- clock and reset\n- AXI4-Stream protocol signals\n\nThe interfaces need to ensure:\n1. Proper data flow\n2. Correct timing alignment\n3. Protocol compliance\n4. Efficient backpressure handling\n5. Clear state transitions\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_2"
  },
  {
    "index": 7,
    "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000,\n    parameter int FifoPacketMtuInBytes = 1504,\n    parameter int FifoSizeInBytes = 4096,\n    parameter int MaxNumberOfPackets = 32,\n    parameter int IngressPrefillBytes = -1\n) (\n    input  logic                                      clock,\n    input  logic                                      reset,\n    input  AxiStreamType [NumPorts-1:0]              inAxi4St,\n    output logic [NumPorts-1:0]                      inTready,\n    output AxiStreamType [NumPorts-1:0]              outAxi4St,\n    input  logic [NumPorts-1:0]                      outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0]        egressFifoDropEvents\n);\n\n    // MAC Table entries\n    typedef struct packed {\n        logic        valid;\n        logic [47:0] mac_addr;\n        logic [$clog2(NumPorts)-1:0] port_num;\n        logic [$clog2(MacTableCyclesPerEpoch)-1:0] age_counter;\n    } mac_entry_t;\n\n    // Internal signals for parser outputs\n    logic [NumPorts-1:0][47:0] parsed_dest_mac;\n    logic [NumPorts-1:0][47:0] parsed_source_mac;\n    logic [NumPorts-1:0]       parsed_valid;\n    AxiStreamType [NumPorts-1:0] parsed_stream;\n\n    // MAC table storage\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n    logic [$clog2(MacTableDepth)-1:0] free_index;\n    logic table_full;\n\n    // Routing signals\n    logic [NumPorts-1:0] mac_found;\n    logic [NumPorts-1:0][$clog2(NumPorts)-1:0] dest_port;\n    logic [NumPorts-1:0][NumPorts-1:0] route_mask;\n\n    // Instantiate MAC parsers for each port\n    generate\n        for (genvar i = 0; i < NumPorts; i++) begin : gen_parsers\n            local_axist_eth_parser #(\n                .AxiStreamType(AxiStreamType),\n                .AxiStreamWidth(AxiStreamWidth)\n            ) eth_parser (\n                .clock(clock),\n                .reset(reset),\n                .inAxi4St(inAxi4St[i]),\n                .inTready(),  // Not used\n                .outAxi4St(parsed_stream[i]),\n                .outTready(1'b1),\n                .outParsedValid(parsed_valid[i]),\n                .outParsedDestMac(parsed_dest_mac[i]),\n                .outParsedSourceMac(parsed_source_mac[i])\n            );\n        end\n    endgenerate\n\n    // MAC Table Learning and Aging\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                mac_table[i].valid <= 1'b0;\n                mac_table[i].age_counter <= '0;\n            end\n            free_index <= '0;\n            table_full <= 1'b0;\n        end else begin\n            // Learning\n            for (int port = 0; port < NumPorts; port++) begin\n                if (parsed_valid[port]) begin\n                    logic found;\n                    found = 1'b0;\n                    \n                    // Update existing entry\n                    for (int i = 0; i < MacTableDepth; i++) begin\n                        if (mac_table[i].valid && \n                            mac_table[i].mac_addr == parsed_source_mac[port]) begin\n                            mac_table[i].port_num <= port[$clog2(NumPorts)-1:0];\n                            mac_table[i].age_counter <= '0;\n                            found = 1'b1;\n                        end\n                    end\n                    \n                    // Add new entry if not found\n                    if (!found && !table_full) begin\n                        mac_table[free_index].valid <= 1'b1;\n                        mac_table[free_index].mac_addr <= parsed_source_mac[port];\n                        mac_table[free_index].port_num <= port[$clog2(NumPorts)-1:0];\n                        mac_table[free_index].age_counter <= '0;\n                        free_index <= free_index + 1;\n                        if (free_index == MacTableDepth-1)\n                            table_full <= 1'b1;\n                    end\n                end\n            end\n\n            // Aging\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter == MacTableCyclesPerEpoch-1) begin\n                        mac_table[i].valid <= 1'b0;\n                        table_full <= 1'b0;\n                    end else begin\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                    end\n                end\n            end\n        end\n    end\n\n    // MAC Lookup and Route Mask Generation\n    always_comb begin\n        for (int port = 0; port < NumPorts; port++) begin\n            mac_found[port] = 1'b0;\n            dest_port[port] = '0;\n            route_mask[port] = '0;\n            \n            // MAC table lookup\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid && \n                    mac_table[i].mac_addr == parsed_dest_mac[port]) begin\n                    mac_found[port] = 1'b1;\n                    dest_port[port] = mac_table[i].port_num;\n                end\n            end\n            \n            // Generate route mask\n            if (parsed_valid[port]) begin\n                if (parsed_dest_mac[port][40]) begin // Multicast/Broadcast\n                    route_mask[port] = {NumPorts{1'b1}} & ~(1'b1 << port);\n                end else if (mac_found[port]) begin\n                    route_mask[port] = (1'b1 << dest_port[port]) & ~(1'b1 << port);\n                end else begin\n                    route_mask[port] = {NumPorts{1'b1}} & ~(1'b1 << port);\n                end\n            end\n        end\n    end\n\n    // Output FIFOs\n    generate\n        for (genvar out_port = 0; out_port < NumPorts; out_port++) begin : gen_output_fifos\n            local_axist_storefwd_fifo #(\n                .AxiStreamType(AxiStreamType),\n                .AxiStreamWidth(AxiStreamWidth),\n                .PacketMtuInBytes(FifoPacketMtuInBytes),\n                .FifoSizeInBytes(FifoSizeInBytes),\n                .MaxNumberOfPackets(MaxNumberOfPackets)\n            ) output_fifo (\n                .clock(clock),\n                .reset(reset),\n                .inAxi4St(parsed_stream[route_mask[out_port]]),\n                .inError(1'b0),\n                .inTready(),\n                .outAxi4St(outAxi4St[out_port]),\n                .outError(),\n                .outExtra(),\n                .outTready(outTready[out_port]),\n                .inFifoAfull(),\n                .inDropEvent(),\n                .outDropEvent()\n            );\n        end\n    endgenerate\n\n    // Tie off unused outputs\n    assign inTready = {NumPorts{1'b1}};\n    assign egressFifoDropEvents = '0;\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module does not need to support a 'ready' output signal for backpressure for the inAxi4St inputs, it is assumed these are received Ethernet frames coming from an Ethernet MAC Rx that does not support flow control with a 'ready' signal.\nThe module does need to support 'outReady' input signals for each transmit port, since outAxi4St will connect four Ethernet MAC Transmit ports.\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n     -- parameter int FifoPacketMutInBytes = 1504\n        -- Maximum Ethernet Frame size, in bytes.\n     -- parameter int FifoSizeInBytes = 4096\n        -- Maximum FIFO size for a single FIFO within the design, in bytes. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be internally stored for any single ingress to egress AxiStreamType output bus (outAxi4St[tx_port]).\n           For Example, if NumPorts=4, and all four ports inAxi4St[3:0] have frames with Destination MAC that steer to outAxi4St[0] (egress port 0), outAxi4St[0] can only egress one data phit per cycle, while four ports are queuing a total of four data phits per cycle. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n\nAdditionally, you have some helper modules that you must use (the internals are not shown)\n\nmodule local_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\nThis module takes an AXI4 Stream input (inAxi4St struct, flow control inTready), and outputs a delayed version of\nthe packet on an AXI4 Stream output (outAxi4St, flow control outTready). outParsedValid=1 on the first data phit\noutput from outAxi4St. outParsedDestMac and outParsedSourceMac are valid when outParsedValid=1.\n\n\nmodule local_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n\nThis module takes an AXI4 Stream input (inAxi4St struct, flow control inTready), and outputs a store-and-forwarded version of\nthe packet on an AXI4 Stream output (outAxi4St, flow control outTready). You can ignore inError (connect to 1'b0), inExtra, outError, and outExtra. This could be useful on an AXI4 Stream from an Ethernet Receive port, to ensure an entire packet is stored prior to sending it to a Transmit Ethernet port.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level understanding of this Layer-2 Ethernet Switch:\n\nMain Functionality:\n1. It's a 4-port unmanaged Ethernet switch that routes frames between ports based on MAC addresses\n2. Key features:\n   - Maintains a 16-entry MAC address table\n   - Learning capability: Records source MAC addresses and associated ports\n   - Frame forwarding rules:\n     * If destination MAC is known: Forward to specific port\n     * If destination MAC is unknown: Flood to all ports except source\n     * For broadcast/multicast: Flood to all ports except source\n     * No loopback: Never forwards frames back to receiving port\n\nHigh-Level Block Diagram:\n```\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502              Layer-2 Switch                 \u2502\ninAxi4St[0] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                           \u2502\u25c4\u2500\u2500\u2500 outTready[0]\n                      \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\ninAxi4St[1] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  \u2502 MAC Address  \u2502    \u2502 Packet Routing \u2502   \u2502\u2500\u2500\u2500\u2500\u25ba outAxi4St[0]\n                      \u2502  \u2502    Table      \u2502\u25c4\u2500\u2500\u25ba\u2502     Logic      \u2502   \u2502\ninAxi4St[2] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  \u2502 (16 entries) \u2502    \u2502                \u2502   \u2502\u2500\u2500\u2500\u2500\u25ba outAxi4St[1]\n                      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\ninAxi4St[3] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                           \u2502\u2500\u2500\u2500\u2500\u25ba outAxi4St[2]\n                      \u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n                      \u2502      \u2502   Output Port FIFOs    \u2502           \u2502\u2500\u2500\u2500\u2500\u25ba outAxi4St[3]\n                      \u2502      \u2502  (Store & Forward)     \u2502           \u2502\n                      \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nKey Components:\n1. MAC Parser (local_axist_eth_parser) for each input port\n2. MAC Address Table (16 entries with aging mechanism)\n3. Packet Routing Logic\n4. Output FIFOs (local_axist_storefwd_fifo) for each output port\n5. Control Logic for managing the overall operation\n\nThe design handles AXI4-Stream interfaces for both input and output, with output ports supporting backpressure through outTready signals. Each port can handle Ethernet frames between 60 and 1504 bytes.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\n1. Core Switch Parameters:\n```systemverilog\nparameter int NumPorts = 4              // Number of switch ports\nparameter int MacTableDepth = 16        // MAC address table entries\n```\n\n2. AXI Stream Interface:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s  // AXI Stream struct type\nparameter int unsigned AxiStreamWidth = 8             // Width of tdata field\n```\n\n3. Frame Size Controls:\n```systemverilog\nparameter int FifoPacketMtuInBytes = 1504    // Max frame size\nparameter int unsigned MinFrameSize = 60      // Min frame size\n```\n\n4. Memory and Storage:\n```systemverilog\nparameter int FifoSizeInBytes = 4096         // FIFO size per output port\nparameter int MaxNumberOfPackets = 32         // Max packets per FIFO\n```\n\n5. MAC Table Management:\n```systemverilog\nparameter int MacTableCyclesPerEpoch = 32'd1_750_000_000  // Aging timeout\n```\n\n6. Implementation Specific:\n```systemverilog\nparameter IngressPrefillBytes = -1    // Required parameter\n```\n\nThese parameters allow for customization of:\n1. Switch scale (number of ports)\n2. Memory resources (FIFO sizes, MAC table depth)\n3. Performance characteristics (packet buffering)\n4. Protocol compliance (frame sizes)\n5. MAC learning behavior (aging timeout)\n\nThe default values provided in the problem description are reasonable because:\n- 4 ports is a common size for small switches\n- 16 MAC table entries provides basic functionality while being resource-efficient\n- 8-bit AXI width matches common implementations\n- 4KB FIFO size allows for multiple full-size frames\n- 32 max packets prevents resource exhaustion\n- The aging timeout (~1.75B cycles) provides reasonable MAC table entry lifetime\n\nAdditional parameters could be considered for:\n- Error handling configurations\n- Quality of Service features\n- Debug/monitoring features\n- Timing parameters\n\nHowever, these would add complexity and aren't required by the base specification.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing flow and required logic components:\n\nData Processing Flow:\n```\nInput \u2192 Parse \u2192 Route \u2192 Buffer \u2192 Output\n```\n\n1. Input Processing (Per Port):\n```systemverilog\n// MAC Parser instance per port\nlogic [47:0] parsed_dest_mac[NumPorts];\nlogic [47:0] parsed_source_mac[NumPorts];\nlogic        parsed_valid[NumPorts];\n\n// Frame tracking\nlogic [NumPorts-1:0] frame_in_progress;\nlogic [$clog2(FifoPacketMtuInBytes):0] byte_count[NumPorts];\n```\n\n2. MAC Table Logic:\n```systemverilog\ntypedef struct packed {\n    logic        valid;\n    logic [47:0] mac_addr;\n    logic [$clog2(NumPorts)-1:0] port_num;\n    logic [$clog2(MacTableCyclesPerEpoch)-1:0] age_counter;\n} mac_entry_t;\n\nmac_entry_t mac_table[MacTableDepth];\n```\n\n3. Routing Logic:\n```systemverilog\n// Per input port, routing decisions\nlogic [NumPorts-1:0] route_mask[NumPorts];  // Which output ports to route to\nlogic route_valid[NumPorts];                // Valid routing decision\n\n// Lookup result\nlogic mac_found;\nlogic [$clog2(NumPorts)-1:0] dest_port;\n```\n\n4. Output Buffer Logic:\n```systemverilog\n// Per output port FIFO control\nlogic [NumPorts-1:0] fifo_ready;\nlogic [NumPorts-1:0] fifo_afull;\n```\n\nCombinational Logic Needed:\n1. MAC Table Lookup:\n```systemverilog\n// Find destination MAC in table\nalways_comb begin\n    mac_found = 0;\n    dest_port = '0;\n    for (int i = 0; i < MacTableDepth; i++) begin\n        if (mac_table[i].valid && mac_table[i].mac_addr == parsed_dest_mac) begin\n            mac_found = 1;\n            dest_port = mac_table[i].port_num;\n        end\n    end\nend\n```\n\n2. Route Decision:\n```systemverilog\n// Determine output ports for frame\nalways_comb begin\n    for (int i = 0; i < NumPorts; i++) begin\n        route_mask[i] = '0;\n        if (parsed_valid[i]) begin\n            if (mac_found) begin\n                route_mask[i][dest_port] = 1'b1;\n            end else begin\n                // Flood to all ports except source\n                route_mask[i] = {NumPorts{1'b1}} & ~(1 << i);\n            end\n        end\n    end\nend\n```\n\nSequential Logic Needed:\n1. MAC Learning:\n```systemverilog\n// Add/update source MAC addresses\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        for (int i = 0; i < MacTableDepth; i++)\n            mac_table[i].valid <= 0;\n    end else begin\n        // MAC learning logic\n        if (parsed_valid) begin\n            // Update or add new MAC entry\n        end\n        // Age counter updates\n    end\nend\n```\n\n2. Frame Tracking:\n```systemverilog\n// Track frame progress\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_in_progress <= '0;\n        byte_count <= '{default: '0};\n    end else begin\n        for (int i = 0; i < NumPorts; i++) begin\n            if (inAxi4St[i].tvalid && inAxi4St[i].tlast)\n                frame_in_progress[i] <= 0;\n            else if (parsed_valid[i])\n                frame_in_progress[i] <= 1;\n            \n            // Update byte count\n            if (inAxi4St[i].tvalid)\n                byte_count[i] <= byte_count[i] + 1;\n            if (inAxi4St[i].tlast)\n                byte_count[i] <= '0;\n        end\n    end\nend\n```\n\n3. Output Control:\n```systemverilog\n// Manage output FIFOs and backpressure\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        fifo_ready <= '1;\n    end else begin\n        for (int i = 0; i < NumPorts; i++) begin\n            if (fifo_afull[i])\n                fifo_ready[i] <= 0;\n            else if (!frame_in_progress[i])\n                fifo_ready[i] <= 1;\n        end\n    end\nend\n```\n\nThis logic structure supports:\n- Parallel processing of multiple input ports\n- MAC address learning and aging\n- Frame routing decisions\n- Output buffering and flow control\n- Error detection and handling\n\nThe design must carefully manage timing and synchronization between these blocks to ensure proper frame handling and prevent data loss.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nFrom the problem description and requirements, let's analyze the timing aspects:\n\nClocking Requirements:\n1. Single Clock Domain\n- All logic operates on single 'clock' input\n- No clock domain crossing requirements specified\n- AXI Stream interfaces operate on same clock\n\nReset Requirements:\n1. Synchronous Reset\n- Problem explicitly states \"reset is a synchronous reset\"\n- All sequential elements should be reset synchronously\n- Reset should initialize:\n  * MAC address table entries\n  * Frame tracking logic\n  * FIFOs\n  * State machines\n  * Output registers\n\nSignals Requiring Reset:\n```systemverilog\n// Core control\nframe_in_progress <= '0;\nbyte_count <= '{default: '0};\n\n// MAC table\nfor (int i = 0; i < MacTableDepth; i++) begin\n    mac_table[i].valid <= 1'b0;\n    mac_table[i].age_counter <= '0;\nend\n\n// Output control\noutAxi4St <= '{default: '0};\nfifo_ready <= '1;\n```\n\nLatency Considerations:\n1. MAC Parser (local_axist_eth_parser)\n- Adds latency to extract MAC addresses\n- Must complete parsing before routing decision\n\n2. Store-and-Forward FIFO (local_axist_storefwd_fifo)\n- Full packet must be received before forwarding\n- Minimum latency = 60 bytes (minimum frame size)\n- Maximum latency = 1504 bytes (maximum frame size)\n\n3. MAC Table Lookup\n- Should complete within one clock cycle\n- Parallel comparison of all entries\n\nThroughput Requirements:\n1. Input Processing\n- Must handle line rate on all 4 ports simultaneously\n- No backpressure support on inputs (inTready tied to 1'b1)\n\n2. Output Processing\n- Must support backpressure via outTready\n- Each output port can only transmit one byte per clock\n- Need buffering when multiple inputs target same output\n\nCritical Timing Paths:\n1. MAC Table Lookup\n```systemverilog\n// Must complete in one cycle\nalways_comb begin\n    mac_found = 1'b0;\n    dest_port = '0;\n    for (int i = 0; i < MacTableDepth; i++) begin\n        if (mac_table[i].valid && \n            mac_table[i].mac_addr == parsed_dest_mac) begin\n            mac_found = 1'b1;\n            dest_port = mac_table[i].port_num;\n        end\n    end\nend\n```\n\n2. Routing Decision\n```systemverilog\n// Must complete in one cycle\nalways_comb begin\n    for (int i = 0; i < NumPorts; i++) begin\n        if (parsed_valid[i]) begin\n            route_mask[i] = mac_found ? \n                           (1'b1 << dest_port) :\n                           ({NumPorts{1'b1}} & ~(1'b1 << i));\n        end\n    end\nend\n```\n\nPerformance Constraints:\n1. Input Processing\n- Must accept new data every clock when tvalid=1\n- No drops due to processing delays\n\n2. Output Processing\n- Must be ready to transmit when FIFOs have data\n- Handle output port contention\n\nImplementation Considerations:\n1. Pipelining\n- MAC table lookup could be pipelined if timing is tight\n- Routing decisions could be registered\n\n2. Resource Sharing\n- Multiple input ports sharing MAC lookup logic\n- Output port arbitration\n\n3. Buffering\n- FIFOs must be sized to handle worst-case scenarios\n- Maximum 32 packets per output port\n\nReset Strategy:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Reset all control logic\n        frame_in_progress <= '0;\n        mac_table <= '{default: '0};\n        outAxi4St <= '{default: '0};\n        // etc...\n    end else begin\n        // Normal operation\n    end\nend\n```\n\nThe design must maintain wire-speed performance while managing multiple concurrent packet flows and handling backpressure on outputs.What test cases are needed to verify the design? What assertions would help validate the design? What's the best way to verify functionality in simulation?\n [NEW STEP]\n \nLet's break down the verification strategy:\n\nTest Cases Categories:\n\n1. Basic Functionality:\n```systemverilog\n// Single port to single port\ntask test_single_port_transfer();\n    // Send frame from port 0 to port 1\n    send_frame(0, PORT1_MAC, PORT0_MAC, test_data);\n    check_frame(1, PORT1_MAC, PORT0_MAC, test_data);\nendtask\n\n// Broadcast frame\ntask test_broadcast();\n    // Send broadcast from port 0\n    send_frame(0, BROADCAST_MAC, PORT0_MAC, test_data);\n    // Check received on ports 1,2,3\n    fork\n        check_frame(1, BROADCAST_MAC, PORT0_MAC, test_data);\n        check_frame(2, BROADCAST_MAC, PORT0_MAC, test_data);\n        check_frame(3, BROADCAST_MAC, PORT0_MAC, test_data);\n    join\nendtask\n```\n\n2. MAC Learning:\n```systemverilog\ntask test_mac_learning();\n    // Send frame to unknown MAC\n    send_frame(0, UNKNOWN_MAC, PORT0_MAC, test_data);\n    // Verify flooding\n    check_flooding(0, test_data);\n    \n    // Send reply frame\n    send_frame(1, PORT0_MAC, UNKNOWN_MAC, test_data);\n    // Verify direct routing\n    check_frame(0, PORT0_MAC, UNKNOWN_MAC, test_data);\nendtask\n```\n\n3. MAC Aging:\n```systemverilog\ntask test_mac_aging();\n    // Add MAC entry\n    send_frame(0, PORT1_MAC, PORT0_MAC, test_data);\n    \n    // Wait aging period\n    repeat(MacTableCyclesPerEpoch) @(posedge clock);\n    \n    // Verify entry expired (should flood)\n    send_frame(2, PORT0_MAC, PORT2_MAC, test_data);\n    check_flooding(2, test_data);\nendtask\n```\n\n4. Stress Testing:\n```systemverilog\ntask test_concurrent_traffic();\n    // Send frames from all ports simultaneously\n    fork\n        send_frame(0, PORT1_MAC, PORT0_MAC, data0);\n        send_frame(1, PORT2_MAC, PORT1_MAC, data1);\n        send_frame(2, PORT3_MAC, PORT2_MAC, data2);\n        send_frame(3, PORT0_MAC, PORT3_MAC, data3);\n    join\nendtask\n```\n\nAssertions:\n\n1. Protocol Checks:\n```systemverilog\n// Frame size checks\nproperty frame_size_check;\n    @(posedge clock)\n    $rose(frame_in_progress) |-> \n    (byte_count >= MIN_FRAME_SIZE && byte_count <= MAX_FRAME_SIZE);\nendproperty\nassert property(frame_size_check);\n\n// No loopback\nproperty no_loopback;\n    @(posedge clock)\n    parsed_valid |-> !(route_mask[src_port][src_port]);\nendproperty\nassert property(no_loopback);\n```\n\n2. MAC Table Checks:\n```systemverilog\n// Single MAC entry\nproperty unique_mac_entry;\n    @(posedge clock)\n    mac_table.valid |-> \n    $onehot(mac_table.mac_addr == parsed_source_mac);\nendproperty\nassert property(unique_mac_entry);\n\n// Valid aging\nproperty valid_aging;\n    @(posedge clock)\n    mac_table.valid && (mac_table.age_counter == MacTableCyclesPerEpoch)\n    |-> ##1 !mac_table.valid;\nendproperty\nassert property(valid_aging);\n```\n\n3. Data Path Checks:\n```systemverilog\n// FIFO overflow prevention\nproperty fifo_overflow_check;\n    @(posedge clock)\n    fifo_afull |-> !write_enable;\nendproperty\nassert property(fifo_overflow_check);\n\n// Valid routing\nproperty valid_routing;\n    @(posedge clock)\n    parsed_valid |-> |route_mask;\nendproperty\nassert property(valid_routing);\n```\n\nSimulation Strategy:\n\n1. Test Environment Setup:\n```systemverilog\nclass switch_env;\n    virtual switch_if vif;\n    mailbox gen2drv, drv2scb;\n    \n    generator  gen;\n    driver     drv;\n    monitor    mon;\n    scoreboard scb;\n    \n    function new();\n        gen2drv = new();\n        drv2scb = new();\n        gen = new(gen2drv);\n        drv = new(vif, gen2drv);\n        mon = new(vif, drv2scb);\n        scb = new(drv2scb);\n    endfunction\nendclass\n```\n\n2. Coverage:\n```systemverilog\ncovergroup switch_cov;\n    // Port coverage\n    cp_ports: coverpoint src_port {\n        bins ports[] = {[0:NumPorts-1]};\n    }\n    \n    // MAC table coverage\n    cp_mac_table: coverpoint mac_table_usage {\n        bins empty = {0};\n        bins partial = {[1:MacTableDepth-1]};\n        bins full = {MacTableDepth};\n    }\n    \n    // Cross coverage\n    cross_ports_routing: cross src_port, dest_port {\n        ignore_bins loopback = binsof(src_port) intersect {dest_port};\n    }\nendgroup\n```\n\n3. Transaction Generation:\n```systemverilog\nclass frame_transaction;\n    rand bit [47:0] dest_mac;\n    rand bit [47:0] src_mac;\n    rand bit [7:0]  data[];\n    rand bit [1:0]  src_port;\n    \n    constraint valid_size {\n        data.size() inside {[MIN_FRAME_SIZE:MAX_FRAME_SIZE]};\n    }\nendclass\n```\n\n4. Verification Plan:\n- Basic functionality testing\n- Corner cases and error conditions\n- Performance testing\n- Stress testing\n- Coverage-driven verification\n- Random testing with constraints\n\n5. Debug Features:\n```systemverilog\n// Debug interface\ninterface switch_debug_if;\n    logic [NumPorts-1:0] port_active;\n    logic [MacTableDepth-1:0] mac_valid;\n    logic [$clog2(FifoSizeInBytes)-1:0] fifo_usage[NumPorts];\n    \n    task display_state();\n        $display(\"Active Ports: %b\", port_active);\n        $display(\"MAC Table Usage: %d\", $countones(mac_valid));\n        foreach(fifo_usage[i])\n            $display(\"FIFO[%0d] Usage: %d\", i, fifo_usage[i]);\n    endtask\nendinterface\n```\n\nThis comprehensive verification approach ensures:\n- All functional requirements are tested\n- Corner cases are covered\n- Performance requirements are met\n- Design robustness is verified\n- Easy debug capabilityWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline comprehensive test scenarios and assertions for the Layer-2 Switch:\n\nTest Scenarios:\n\n1. Basic Frame Routing:\n```systemverilog\nclass BasicRoutingTests;\n    // Direct port-to-port\n    task test_direct_routing();\n        // Send frame port 0 -> port 1\n        send_frame(0, MAC_PORT1, MAC_PORT0, TEST_DATA);\n        // Verify learned MAC\n        check_mac_table(MAC_PORT0, 0);\n        // Verify frame received\n        check_frame(1, MAC_PORT1, MAC_PORT0, TEST_DATA);\n    endtask\n\n    // Unknown destination (flooding)\n    task test_unknown_dest();\n        // Send to unknown MAC\n        send_frame(0, UNKNOWN_MAC, MAC_PORT0, TEST_DATA);\n        // Verify flooded to all ports except source\n        check_flooding(0, TEST_DATA);\n    endtask\nendclass\n```\n\n2. MAC Learning Scenarios:\n```systemverilog\nclass MacLearningTests;\n    // MAC table population\n    task test_mac_learning();\n        // Fill table\n        for (int i = 0; i < MacTableDepth; i++) begin\n            send_frame(0, unique_mac[i], src_mac[i], TEST_DATA);\n            check_mac_table(src_mac[i], 0);\n        end\n        \n        // Verify overflow behavior\n        send_frame(0, extra_mac, src_mac_new, TEST_DATA);\n        check_mac_replacement();\n    endtask\n\n    // MAC aging\n    task test_mac_aging();\n        // Add MAC entry\n        send_frame(0, MAC_PORT1, MAC_PORT0, TEST_DATA);\n        // Wait aging period\n        repeat(MacTableCyclesPerEpoch) @(posedge clock);\n        // Verify entry expired\n        check_mac_expired(MAC_PORT0);\n    endtask\nendclass\n```\n\n3. Stress Testing:\n```systemverilog\nclass StressTests;\n    // Multiple concurrent frames\n    task test_concurrent_traffic();\n        fork\n            send_frame(0, MAC_PORT1, MAC_PORT0, DATA0);\n            send_frame(1, MAC_PORT2, MAC_PORT1, DATA1);\n            send_frame(2, MAC_PORT3, MAC_PORT2, DATA2);\n            send_frame(3, MAC_PORT0, MAC_PORT3, DATA3);\n        join\n        check_all_received();\n    endtask\n\n    // FIFO overflow conditions\n    task test_fifo_overflow();\n        // Send MaxNumberOfPackets+1 frames to same output\n        for (int i = 0; i <= MaxNumberOfPackets; i++) begin\n            send_frame(0, MAC_PORT1, MAC_PORT0, TEST_DATA);\n        end\n        check_overflow_handling();\n    endtask\nendclass\n```\n\n4. Error Conditions:\n```systemverilog\nclass ErrorTests;\n    // Undersized frames\n    task test_undersized_frame();\n        send_small_frame(0, MAC_PORT1, MAC_PORT0, SHORT_DATA);\n        check_frame_dropped();\n    endtask\n\n    // Oversized frames\n    task test_oversized_frame();\n        send_large_frame(0, MAC_PORT1, MAC_PORT0, LONG_DATA);\n        check_frame_dropped();\n    endtask\nendclass\n```\n\nAssertions:\n\n1. Protocol Assertions:\n```systemverilog\n// Frame size checks\nproperty valid_frame_size;\n    @(posedge clock)\n    frame_complete |-> \n        (byte_count inside {[MIN_FRAME_SIZE:MAX_FRAME_SIZE]});\nendproperty\nassert property(valid_frame_size) else\n    $error(\"Invalid frame size detected\");\n\n// Valid MAC addresses\nproperty valid_mac_addr;\n    @(posedge clock)\n    parsed_valid |-> !parsed_dest_mac[47];  // Not multicast\nendproperty\nassert property(valid_mac_addr);\n```\n\n2. Routing Assertions:\n```systemverilog\n// No loopback\nproperty no_loopback_routing;\n    @(posedge clock)\n    parsed_valid |-> (route_mask[src_port][src_port] == 0);\nendproperty\nassert property(no_loopback_routing);\n\n// Valid routing decision\nproperty valid_routing_decision;\n    @(posedge clock)\n    parsed_valid |-> ##[1:2] |route_mask;\nendproperty\nassert property(valid_routing_decision);\n```\n\n3. MAC Table Assertions:\n```systemverilog\n// Unique MAC entries\nproperty unique_mac_entries;\n    @(posedge clock)\n    $onehot(mac_table.valid && (mac_table.mac_addr == check_mac));\nendproperty\nassert property(unique_mac_entries);\n\n// MAC aging\nproperty mac_aging;\n    @(posedge clock)\n    (mac_table.valid && mac_table.age_counter == MacTableCyclesPerEpoch)\n    |-> ##1 !mac_table.valid;\nendproperty\nassert property(mac_aging);\n```\n\n4. FIFO Assertions:\n```systemverilog\n// FIFO overflow protection\nproperty fifo_overflow_check;\n    @(posedge clock)\n    fifo_afull |-> !write_enable;\nendproperty\nassert property(fifo_overflow_check);\n\n// Packet count limit\nproperty packet_count_limit;\n    @(posedge clock)\n    packet_count <= MaxNumberOfPackets;\nendproperty\nassert property(packet_count_limit);\n```\n\n5. Coverage:\n```systemverilog\ncovergroup switch_coverage;\n    // Port usage\n    port_cp: coverpoint src_port {\n        bins ports[] = {[0:NumPorts-1]};\n    }\n    \n    // MAC table usage\n    mac_table_cp: coverpoint mac_table_usage {\n        bins empty = {0};\n        bins partial = {[1:MacTableDepth-1]};\n        bins full = {MacTableDepth};\n    }\n    \n    // Frame sizes\n    frame_size_cp: coverpoint frame_size {\n        bins min = {MIN_FRAME_SIZE};\n        bins max = {MAX_FRAME_SIZE};\n        bins mid = {[MIN_FRAME_SIZE+1:MAX_FRAME_SIZE-1]};\n    }\n    \n    // Cross coverage\n    port_cross: cross src_port, dst_port;\nendgroup\n```\n\nThis verification plan ensures:\n- Complete functional coverage\n- Corner case detection\n- Protocol compliance\n- Performance validation\n- Error handling verification\n- Comprehensive assertion checking\n\nThe combination of directed tests, random scenarios, assertions, and coverage metrics provides thorough verification of the design.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. MAC Parser Block (one per input port):\n```systemverilog\nmodule mac_parser_block (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        parse_valid,\n    output AxiStreamType outAxi4St\n);\n    // Uses local_axist_eth_parser\n    // Extracts MAC addresses from incoming frames\n    // Passes frame data through to next stage\n```\n\n2. MAC Table Manager:\n```systemverilog\nmodule mac_table_manager (\n    input  logic        clock,\n    input  logic        reset,\n    // Learning interface\n    input  logic [47:0] learn_mac,\n    input  logic [$clog2(NumPorts)-1:0] learn_port,\n    input  logic        learn_valid,\n    // Lookup interface\n    input  logic [47:0] lookup_mac,\n    output logic        mac_found,\n    output logic [$clog2(NumPorts)-1:0] dest_port\n);\n    // Maintains MAC address table\n    // Handles MAC learning\n    // Performs MAC lookups\n    // Manages aging timeouts\n```\n\n3. Route Decision Engine:\n```systemverilog\nmodule route_decision_engine (\n    input  logic        clock,\n    input  logic        reset,\n    // MAC lookup results\n    input  logic        mac_found,\n    input  logic [$clog2(NumPorts)-1:0] dest_port,\n    input  logic [$clog2(NumPorts)-1:0] src_port,\n    // Output routing\n    output logic [NumPorts-1:0] route_mask\n);\n    // Determines output port(s) for each frame\n    // Implements flooding logic\n    // Prevents loopback\n```\n\n4. Output Port Manager (one per output port):\n```systemverilog\nmodule output_port_manager #(\n    parameter int PortNum = 0\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // Input streams from each input port\n    input  AxiStreamType inAxi4St[NumPorts],\n    input  logic [NumPorts-1:0] route_mask,\n    // Output interface\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    // Manages store-and-forward FIFO\n    // Implements output arbitration\n    // Handles backpressure\n```\n\n5. Frame Statistics Collector:\n```systemverilog\nmodule frame_statistics (\n    input  logic        clock,\n    input  logic        reset,\n    // Frame events\n    input  logic [NumPorts-1:0] frame_start,\n    input  logic [NumPorts-1:0] frame_complete,\n    input  logic [NumPorts-1:0] frame_error,\n    // Statistics outputs\n    output logic [NumPorts-1:0][NumPorts-1:0] drop_events\n);\n    // Tracks frame statistics\n    // Monitors drop events\n```\n\n6. Top-Level Control:\n```systemverilog\nmodule switch_control (\n    input  logic        clock,\n    input  logic        reset,\n    // Interface to all submodules\n    // Global control signals\n);\n    // Coordinates all submodules\n    // Manages global state\n    // Handles reset sequence\n```\n\nIntegration in Top-Level:\n```systemverilog\nmodule dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    // Other parameters...\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St[NumPorts],\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType outAxi4St[NumPorts],\n    input  logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // Instantiate MAC Parsers\n    mac_parser_block mac_parsers[NumPorts] (\n        // Connections\n    );\n\n    // MAC Table Manager\n    mac_table_manager mac_table (\n        // Connections\n    );\n\n    // Route Decision Engine\n    route_decision_engine route_engine (\n        // Connections\n    );\n\n    // Output Port Managers\n    output_port_manager output_managers[NumPorts] (\n        // Connections\n    );\n\n    // Statistics Collection\n    frame_statistics stats (\n        // Connections\n    );\n\n    // Control Logic\n    switch_control controller (\n        // Connections\n    );\n```\n\nKey Interfaces Between Blocks:\n1. Parser \u2192 MAC Table:\n- Extracted MAC addresses\n- Frame valid signals\n\n2. MAC Table \u2192 Route Engine:\n- Lookup results\n- Port mappings\n\n3. Route Engine \u2192 Output Managers:\n- Routing masks\n- Frame steering\n\n4. All Blocks \u2192 Statistics:\n- Event signals\n- Error conditions\n\nBenefits of This Structure:\n1. Modularity and maintainability\n2. Parallel development possible\n3. Easier verification\n4. Clear separation of concerns\n5. Reusable components\n6. Simplified debugging\n7. Better scalability\n\nEach block has a distinct responsibility while working together to implement the complete switch functionality.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nLet me write the SystemVerilog code for each submodule starting with the most critical ones:\n\n1. MAC Parser Block:\n```systemverilog\nmodule mac_parser_block #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic [47:0] dest_mac,\n    output logic [47:0] source_mac,\n    output logic        parse_valid,\n    output AxiStreamType outAxi4St\n);\n\n    // Instantiate ethernet parser\n    local_axist_eth_parser #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n    ) eth_parser (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(),  // Not used\n        .outAxi4St(outAxi4St),\n        .outTready(1'b1),\n        .outParsedValid(parse_valid),\n        .outParsedDestMac(dest_mac),\n        .outParsedSourceMac(source_mac)\n    );\n\nendmodule\n```\n\n2. MAC Table Manager:\n```systemverilog\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16,\n    parameter int NumPorts = 4,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // Learning interface\n    input  logic [47:0] learn_mac,\n    input  logic [$clog2(NumPorts)-1:0] learn_port,\n    input  logic        learn_valid,\n    // Lookup interface\n    input  logic [47:0] lookup_mac,\n    output logic        mac_found,\n    output logic [$clog2(NumPorts)-1:0] dest_port\n);\n\n    typedef struct packed {\n        logic        valid;\n        logic [47:0] mac_addr;\n        logic [$clog2(NumPorts)-1:0] port_num;\n        logic [$clog2(MacTableCyclesPerEpoch)-1:0] age_counter;\n    } mac_entry_t;\n\n    mac_entry_t mac_table[MacTableDepth];\n    logic [$clog2(MacTableDepth)-1:0] free_index;\n    logic table_full;\n\n    // MAC Lookup\n    always_comb begin\n        mac_found = 1'b0;\n        dest_port = '0;\n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (mac_table[i].valid && mac_table[i].mac_addr == lookup_mac) begin\n                mac_found = 1'b1;\n                dest_port = mac_table[i].port_num;\n            end\n        end\n    end\n\n    // MAC Learning and Aging\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                mac_table[i].valid <= 1'b0;\n                mac_table[i].age_counter <= '0;\n            end\n            free_index <= '0;\n            table_full <= 1'b0;\n        end else begin\n            // Learning\n            if (learn_valid) begin\n                logic found;\n                found = 1'b0;\n                \n                // Update existing entry\n                for (int i = 0; i < MacTableDepth; i++) begin\n                    if (mac_table[i].valid && \n                        mac_table[i].mac_addr == learn_mac) begin\n                        mac_table[i].port_num <= learn_port;\n                        mac_table[i].age_counter <= '0;\n                        found = 1'b1;\n                    end\n                end\n                \n                // Add new entry if not found\n                if (!found && !table_full) begin\n                    mac_table[free_index].valid <= 1'b1;\n                    mac_table[free_index].mac_addr <= learn_mac;\n                    mac_table[free_index].port_num <= learn_port;\n                    mac_table[free_index].age_counter <= '0;\n                    free_index <= free_index + 1;\n                    if (free_index == MacTableDepth-1)\n                        table_full <= 1'b1;\n                end\n            end\n\n            // Aging\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter == MacTableCyclesPerEpoch-1) begin\n                        mac_table[i].valid <= 1'b0;\n                        table_full <= 1'b0;\n                    end else begin\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule\n```\n\n3. Route Decision Engine:\n```systemverilog\nmodule route_decision_engine #(\n    parameter int NumPorts = 4\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // MAC lookup results\n    input  logic        mac_found,\n    input  logic [$clog2(NumPorts)-1:0] dest_port,\n    input  logic [$clog2(NumPorts)-1:0] src_port,\n    input  logic [47:0] dest_mac,\n    input  logic        frame_valid,\n    // Output routing\n    output logic [NumPorts-1:0] route_mask\n);\n\n    always_comb begin\n        route_mask = '0;\n        \n        if (frame_valid) begin\n            if (dest_mac[40]) begin  // Multicast/Broadcast\n                route_mask = {NumPorts{1'b1}} & ~(1'b1 << src_port);\n            end else if (mac_found) begin\n                route_mask = (1'b1 << dest_port) & ~(1'b1 << src_port);\n            end else begin\n                route_mask = {NumPorts{1'b1}} & ~(1'b1 << src_port);\n            end\n        end\n    end\n\nendmodule\n```\n\n4. Output Port Manager:\n```systemverilog\nmodule output_port_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int PortNum = 0,\n    parameter int NumPorts = 4,\n    parameter int FifoPacketMtuInBytes = 1504,\n    parameter int FifoSizeInBytes = 4096,\n    parameter int MaxNumberOfPackets = 32\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St[NumPorts],\n    input  logic [NumPorts-1:0] route_mask,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n\n    // Store-and-forward FIFO for each input source\n    local_axist_storefwd_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .PacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .MaxNumberOfPackets(MaxNumberOfPackets)\n    ) output_fifo (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St[route_mask]),\n        .inError(1'b0),\n        .inTready(),  // Not used\n        .outAxi4St(outAxi4St),\n        .outError(),  // Not used\n        .outTready(outTready)\n    );\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Parser \u2192 MAC Table:\n```systemverilog\ninterface mac_parser_if;\n    logic [47:0] dest_mac;\n    logic [47:0] source_mac;\n    logic        parse_valid;\nendinterface\n```\n\n2. MAC Table \u2192 Route Engine:\n```systemverilog\ninterface mac_route_if;\n    logic        mac_found;\n    logic [$clog2(NumPorts)-1:0] dest_port;\n    logic        lookup_valid;\nendinterface\n```\n\n3. Route Engine \u2192 Output Managers:\n```systemverilog\ninterface route_output_if;\n    logic [NumPorts-1:0] route_mask;\n    logic        frame_valid;\nendinterface\n```\n\nThese interfaces need careful timing and handshaking consideration to ensure proper frame handling and prevent data loss. The critical paths are:\n\n1. MAC Learning Path:\n- Parser extracts source MAC\n- MAC Table updates entry\n- Age counter management\n\n2. Frame Routing Path:\n- Parser extracts destination MAC\n- MAC Table lookup\n- Route decision\n- Output port selection\n\n3. Data Path:\n- Input frame buffering\n- Route mask application\n- Output FIFO management\n- Backpressure handling\n\nThe design must maintain proper synchronization between these paths while meeting timing requirements.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module does not need to support a 'ready' output signal for backpressure for the inAxi4St inputs, it is assumed these are received Ethernet frames coming from an Ethernet MAC Rx that does not support flow control with a 'ready' signal.\nThe module does need to support 'outReady' input signals for each transmit port, since outAxi4St will connect four Ethernet MAC Transmit ports.\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n     -- parameter int FifoPacketMutInBytes = 1504\n        -- Maximum Ethernet Frame size, in bytes.\n     -- parameter int FifoSizeInBytes = 4096\n        -- Maximum FIFO size for a single FIFO within the design, in bytes. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be internally stored for any single ingress to egress AxiStreamType output bus (outAxi4St[tx_port]).\n           For Example, if NumPorts=4, and all four ports inAxi4St[3:0] have frames with Destination MAC that steer to outAxi4St[0] (egress port 0), outAxi4St[0] can only egress one data phit per cycle, while four ports are queuing a total of four data phits per cycle. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n\nAdditionally, you have some helper modules that you must use (the internals are not shown)\n\nmodule local_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\nThis module takes an AXI4 Stream input (inAxi4St struct, flow control inTready), and outputs a delayed version of\nthe packet on an AXI4 Stream output (outAxi4St, flow control outTready). outParsedValid=1 on the first data phit\noutput from outAxi4St. outParsedDestMac and outParsedSourceMac are valid when outParsedValid=1.\n\n\nmodule local_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n\nThis module takes an AXI4 Stream input (inAxi4St struct, flow control inTready), and outputs a store-and-forwarded version of\nthe packet on an AXI4 Stream output (outAxi4St, flow control outTready). You can ignore inError (connect to 1'b0), inExtra, outError, and outExtra. This could be useful on an AXI4 Stream from an Ethernet Receive port, to ensure an entire packet is stored prior to sending it to a Transmit Ethernet port.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/local_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = local_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/local_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = local_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_l2_switch_6"
  },
  {
    "index": 10,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0,\n    parameter int unsigned NumInputs = 4,\n    parameter int unsigned NumSelectBits = $clog2(NumInputs)\n) (\n    input  logic                         clock,\n    input  logic                         reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0]         inTready,\n    output AxiStreamType                 outAxi4St,\n    input  logic                         outTready\n);\n\n    // Internal signals\n    logic [NumInputs-1:0]     current_grant;\n    logic [NumSelectBits-1:0] current_select;\n    logic [NumInputs-1:0]     active_transfer;\n    logic [NumInputs-1:0]     qualified_requests;\n    logic                     update_arb_enable;\n\n    // Generate qualified requests\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++) begin\n            qualified_requests[i] = inAxi4St[i].tvalid && !active_transfer[i];\n        end\n    end\n\n    // Track active transfers and packet boundaries\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            active_transfer <= '0;\n        end else begin\n            for (int i = 0; i < NumInputs; i++) begin\n                if (active_transfer[i]) begin\n                    if (inAxi4St[i].tvalid && inAxi4St[i].tlast && inTready[i]) begin\n                        active_transfer[i] <= 1'b0;\n                    end\n                end else if (current_grant[i] && inAxi4St[i].tvalid) begin\n                    active_transfer[i] <= 1'b1;\n                end\n            end\n        end\n    end\n\n    // Generate arbiter update enable\n    assign update_arb_enable = !active_transfer || \n                             (|(current_grant & inAxi4St.tvalid & inAxi4St.tlast & inTready));\n\n    // Instantiate round robin arbiter\n    local_rrarb #(\n        .NumInputs(NumInputs),\n        .NumSelectBits(NumSelectBits)\n    ) u_rrarb (\n        .clock(clock),\n        .reset(reset),\n        .update_valid(update_arb_enable),\n        .requests_in(qualified_requests),\n        .grant_out(current_grant),\n        .select_out(current_select)\n    );\n\n    // Zero-latency output multiplexing\n    always_comb begin\n        outAxi4St = inAxi4St[current_select];\n    end\n\n    // Generate ready signals\n    always_comb begin\n        inTready = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            inTready[i] = current_grant[i] && outTready;\n        end\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n\nAdditionally, you are required to use the following module (without revealing the internals) to perform round robin arbitration. The outputs of local_rrarb (grant_out, and select_out) are held and will not change unless input update_valid=1. When update_valid=1, a requests_in (vector of request valid bits) is also set, and a new arbitration winner is on the outputs -- grant_out is a 1-hot vector, and select_out is the encoded winner with values between 0 and NumInputs-1.\n\nmodule local_rrarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\n1. This module is an AXI4-Stream Switch/Multiplexer with Round-Robin Arbitration\n2. It takes multiple AXI4-Stream inputs (parameterized number, default=4) and multiplexes them to a single AXI4-Stream output\n3. Key features:\n   - Zero-latency data path from selected input to output\n   - Round-Robin arbitration using the provided local_rrarb module\n   - Maintains packet/frame integrity (won't switch inputs mid-packet)\n   - Synchronous reset operation\n\nHigh-Level Block Diagram:\n```\n[Input AXI4-Stream 0] \u2500\u2510\n[Input AXI4-Stream 1] \u2500\u2524     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n[Input AXI4-Stream 2] \u2500\u2524     \u2502             \u2502\n[Input AXI4-Stream 3] \u2500\u2524\u2500\u2500\u2500\u2500\u25b6\u2502   MUX       \u2502\u2500\u2500\u2500\u2500\u25b6 [Output AXI4-Stream]\n                       \u2502     \u2502             \u2502\n                       \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502           \u25b2\n                       \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                       \u2514\u2500\u2500\u2500\u2500\u25b6\u2502  local_rrarb\u2502\n                             \u2502   (RR Arb)  \u2502\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThe module consists of two main blocks:\n1. Round-Robin Arbiter (local_rrarb):\n   - Handles fair selection among requesting inputs\n   - Provides grant signals and selected input encoding\n   - Updates only when update_valid is asserted\n\n2. Multiplexer:\n   - Routes selected input to output based on arbiter decision\n   - Maintains packet integrity\n   - Generates ready signals for inputs\n   - Passes through AXI4-Stream signals (tdata, tkeep, tuser, tlast, tvalid)\n\nThe arbitration is packet-aware, meaning it only switches between inputs at packet boundaries (when tlast=1 and tvalid=1 of current transfer).What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let me outline the parameterizable aspects and their reasonable default values:\n\nRequired Parameters (as specified):\n1. `AxiStreamType` (type parameter)\n   - Default: local_pkg::axi4st_8_s\n   - Defines the AXI4-Stream interface structure\n   - Contains: tdata[7:0], tkeep, tuser, tlast, tvalid\n\n2. `NumInputs` (integer parameter)\n   - Default: 4\n   - Defines number of input AXI4-Stream interfaces\n   - Reasonable range: 2 to 16 (power of 2 values are common)\n\n3. `AxiStreamWidth` (integer parameter)\n   - Default: 8\n   - Specifies tdata width in bits\n   - Not actively used but required in parameter list\n\n4. `FlopArbSel` (unsigned integer parameter)\n   - Default: 0\n   - Not actively used but required in parameter list\n\n5. `FlopOutput` (unsigned integer parameter)\n   - Default: 0\n   - Not actively used but required in parameter list\n\nDerived Parameters (internal):\n1. `NumSelectBits`\n   - Calculated as: $clog2(NumInputs)\n   - Used for encoding the selected input\n   - Example: For NumInputs=4, NumSelectBits=2\n\nAdditional Parameters That Could Be Useful (but not specified):\n1. Priority scheme configuration\n2. Timeout values\n3. Error handling options\n\nThe current parameter set provides good flexibility for:\n- Interface width customization\n- Number of input ports scaling\n- Structural configuration\n- Different data types through the AxiStreamType parameter\n\nThe default values enable a common configuration:\n- 8-bit data width\n- 4 input ports\n- Basic round-robin arbitration\n- Zero-latency operationHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation requirements, and necessary logic elements:\n\nData Processing Flow:\n1. Input to Output Path:\n```\nInput Selection:\ninAxi4St[selected_input] \u2192 outAxi4St (combinational path)\n```\n\nRequired Logic Elements:\n\n1. Registers:\n```systemverilog\n// Arbitration State\nlogic [NumInputs-1:0] active_transfer;  // Tracks ongoing transfers\nlogic [NumSelectBits-1:0] current_winner;  // Selected input port\nlogic [NumInputs-1:0] current_grant;  // One-hot grant signals\n\n// Optional (not needed for zero-latency):\n// No pipeline registers needed for data path due to zero-latency requirement\n```\n\n2. Combinational Logic:\n```systemverilog\n// Multiplexer for AXI4-Stream signals\nalways_comb begin\n    outAxi4St = inAxi4St[current_winner];  // Direct mux of all signals\nend\n\n// Ready signal generation\nalways_comb begin\n    inTready = '0;\n    inTready[current_winner] = outTready;\nend\n\n// Request Generation for Arbiter\nlogic [NumInputs-1:0] next_requests;\nalways_comb begin\n    for (int i = 0; i < NumInputs; i++) begin\n        next_requests[i] = inAxi4St[i].tvalid && !active_transfer[i];\n    end\nend\n```\n\n3. Control Logic:\n```systemverilog\n// Transfer tracking\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        active_transfer <= '0;\n    end else begin\n        for (int i = 0; i < NumInputs; i++) begin\n            if (active_transfer[i]) begin\n                // Clear on last beat of packet\n                if (inAxi4St[i].tvalid && inAxi4St[i].tlast && inTready[i]) begin\n                    active_transfer[i] <= 1'b0;\n                end\n            end else if (current_grant[i] && inAxi4St[i].tvalid) begin\n                // Set when starting new transfer\n                active_transfer[i] <= 1'b1;\n            end\n        end\n    end\nend\n```\n\n4. Arbitration Interface:\n```systemverilog\n// Interface to local_rrarb\nlogic update_arb;\nalways_comb begin\n    update_arb = !active_transfer || \n                 (outAxi4St.tvalid && outAxi4St.tlast && outTready);\nend\n```\n\nKey Aspects:\n1. Zero-Latency Path:\n   - Direct combinational multiplexing of input to output\n   - No registration of data path signals\n\n2. Control Path:\n   - Tracks active transfers\n   - Manages arbitration updates\n   - Generates ready signals\n\n3. State Management:\n   - Tracks packet boundaries\n   - Maintains round-robin fairness\n   - Handles reset conditions\n\n4. Critical Timing Paths:\n   - Input selection to output\n   - Ready signal generation\n   - Arbitration control logic\n\nThe design prioritizes:\n- Minimal latency\n- Packet integrity\n- Fair arbitration\n- Clean handshakingWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the timing and reset requirements from the problem description:\n\nClocking Requirements:\n1. Single Clock Domain:\n- Input: clock (system clock)\n- All logic operates on the positive edge of clock\n- No clock domain crossing requirements mentioned\n\nLatency Requirements:\n1. Zero-Latency Requirement (explicitly stated):\n```\nInput AXI4St \u2192 Output AXI4St: 0 cycles\n```\n- No registration allowed in the data path\n- Must be purely combinational from input to output\n\nThroughput:\n1. Full AXI4-Stream Throughput:\n- One transfer per clock cycle possible\n- Limited only by:\n  * Input validity (tvalid)\n  * Output readiness (outTready)\n  * Arbitration switching overhead\n\nReset Requirements:\n1. Synchronous Reset (explicitly stated):\n- Input: reset\n- Active-high synchronous reset\n- Should reset the following signals:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        active_transfer <= '0;  // Clear transfer tracking\n        current_winner <= '0;   // Reset arbitration selection\n        current_grant <= '0;    // Clear grants\n    end\n    // ...\nend\n```\n\nTiming Constraints:\n1. Critical Paths:\n```\nInput \u2192 Output: Combinational path through mux\nInput \u2192 Arbiter \u2192 Grant \u2192 Ready: Control path\n```\n\n2. Setup/Hold Requirements:\n```\nInput Registration: Not needed (zero latency)\nControl Logic: Standard setup/hold on clock edge\n```\n\nKey Timing Considerations:\n1. Zero-Latency Path:\n- Must meet timing between input and output\n- May require careful physical design consideration\n- Could limit maximum operating frequency\n\n2. Control Path:\n- Can be registered as needed\n- Must handle arbitration updates\n- Should maintain packet boundaries\n\n3. Handshaking:\n- Ready signal generation must be glitch-free\n- Valid signal must be stable during transfers\n\nSummary of Requirements:\n```\nClock:     Single domain\nReset:     Synchronous, active-high\nLatency:   0 cycles (input to output)\nPipeline:  None allowed in data path\nControl:   Can be registered\nBandwidth: Full AXI4-Stream rate\n```\n\nSpecial Considerations:\n1. High-Speed Operation:\n- Zero-latency requirement may limit maximum frequency\n- Careful attention to multiplexer implementation needed\n\n2. Reset Strategy:\n- Only control logic needs reset\n- Data path is purely combinational\n- All state machines must reset to known states\n\n3. Timing Closure:\n- May require constraint tuning for zero-latency path\n- Control path can be timing optimized separately\n\nThese requirements ensure:\n- Predictable behavior\n- Clean reset operation\n- Maximum performance\n- Reliable data transferWhat verification approach would you suggest? What test scenarios and corner cases should be checked?\n [NEW STEP]\n \nLet me outline a comprehensive verification approach for this AXI4-Stream arbiter:\n\nTest Environment Structure:\n```systemverilog\n|-- Testbench\n    |-- Test Sequences\n    |-- Scoreboard\n    |-- Coverage\n    |-- Monitors\n    |-- Drivers\n    `-- DUT\n```\n\nKey Test Scenarios:\n\n1. Basic Functionality:\n```systemverilog\n// Single input tests\n- Single packet transfer\n- Multiple packet transfer\n- Back-to-back packets\n- Idle cycles between packets\n\n// Multiple input tests\n- Simultaneous requests\n- Sequential requests\n- Mixed valid/invalid requests\n```\n\n2. Arbitration Testing:\n```systemverilog\n// Round Robin Verification\n- Check fairness across all inputs\n- Verify no port starvation\n- Test priority after reset\n- Verify arbitration updates only at packet boundaries\n```\n\n3. Packet Integrity:\n```systemverilog\n// Packet Boundary Tests\n- Various packet lengths\n- Single-cycle packets\n- Maximum length packets\n- Back-to-back packets\n- Verify no mid-packet switching\n```\n\n4. Flow Control:\n```systemverilog\n// Ready/Valid Testing\n- Ready assertion/deassertion patterns\n- Valid assertion/deassertion patterns\n- Backpressure scenarios\n- Zero-wait cycles\n- Random wait states\n```\n\nCorner Cases:\n\n1. Reset Scenarios:\n```systemverilog\n- Reset during active transfer\n- Reset between packets\n- Reset with multiple pending requests\n- Back-to-back reset assertions\n```\n\n2. Edge Cases:\n```systemverilog\n- All inputs requesting simultaneously\n- No inputs requesting\n- Single-cycle packets on all inputs\n- Maximum length packets on all inputs\n- Alternating valid patterns\n```\n\n3. Stress Testing:\n```systemverilog\n- Maximum bandwidth utilization\n- Minimum bandwidth utilization\n- Random backpressure\n- Random valid patterns\n```\n\nCoverage Metrics:\n\n1. Functional Coverage:\n```systemverilog\ncovergroup arb_cg;\n    // Input combinations\n    cp_inputs: coverpoint active_requests {\n        bins single_request[] = {[1:NumInputs]};\n        bins multiple_requests[] = {[2:NumInputs]};\n        bins all_requests = {NumInputs};\n    }\n    \n    // Arbitration transitions\n    cp_arb_transitions: coverpoint current_winner {\n        bins transitions[] = ([0:NumInputs-1] => [0:NumInputs-1]);\n    }\n    \n    // Packet characteristics\n    cp_packet_size: coverpoint packet_length {\n        bins small = {[1:10]};\n        bins medium = {[11:100]};\n        bins large = {[101:$]};\n    }\nendgroup\n```\n\n2. Code Coverage:\n- Line coverage\n- Branch coverage\n- Toggle coverage\n- FSM coverage\n- Expression coverage\n\nAssertion Checks:\n\n1. Protocol Checks:\n```systemverilog\n// No switching during packet\nassert property (\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && !outAxi4St.tlast) |->\n    ##1 (current_winner == $past(current_winner))\n);\n\n// Round Robin fairness\nassert property (\n    @(posedge clock) disable iff (reset)\n    (grant_out != '0) |-> \n    next_grant != grant_out\n);\n```\n\n2. Functionality Checks:\n```systemverilog\n// Zero latency check\nassert property (\n    @(posedge clock)\n    outAxi4St.tdata === inAxi4St[current_winner].tdata\n);\n\n// Ready propagation\nassert property (\n    @(posedge clock)\n    inTready[current_winner] === outTready\n);\n```\n\nRecommended Tools/Methodology:\n1. UVM-based testbench\n2. Formal verification for arbitration properties\n3. Random stimulus with constraints\n4. Performance analysis tools\n5. Coverage-driven verification\n\nSuccess Criteria:\n1. 100% functional coverage\n2. 100% code coverage\n3. All assertions passing\n4. Zero protocol violations\n5. Performance metrics met\n6. All corner cases verified\n\nThis comprehensive verification approach ensures:\n- Correct functionality\n- Protocol compliance\n- Performance requirements\n- Robust operation\n- Complete coverage\n- Corner case handlingWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n\n1. Basic Transfer Scenarios:\n```systemverilog\n// Single input active\ntask test_single_input;\n    // Send packets on one input, verify correct output\n    drive_packet(0, short_packet);\n    drive_packet(0, long_packet);\n    check_no_other_activity(1,2,3);\nendtask\n\n// Multiple inputs active\ntask test_multiple_inputs;\n    // Simultaneous packet requests\n    fork\n        drive_packet(0, packet1);\n        drive_packet(1, packet2);\n        drive_packet(2, packet3);\n    join\nendtask\n```\n\n2. Round Robin Testing:\n```systemverilog\ntask test_round_robin;\n    // Verify correct ordering\n    for (int iter = 0; iter < 4; iter++) begin\n        // All inputs requesting\n        foreach (inAxi4St[i]) begin\n            drive_continuous_valid(i);\n        end\n        // Check rotation of grants\n        verify_grant_sequence();\n    end\nendtask\n```\n\n3. Backpressure Testing:\n```systemverilog\ntask test_backpressure;\n    // Toggle outTready randomly\n    fork\n        random_ready_pattern();\n        drive_all_inputs();\n    join\nendtask\n```\n\n4. Packet Boundary Tests:\n```systemverilog\ntask test_packet_boundaries;\n    // Various packet sizes and timing\n    drive_single_beat_packet(0);\n    drive_max_length_packet(1);\n    drive_back_to_back_packets(2);\nendtask\n```\n\nKey Assertions:\n\n1. Protocol Compliance:\n```systemverilog\n// Verify no switching during packet\nproperty packet_switching_check;\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && !outAxi4St.tlast) |->\n    ##1 (current_winner == $past(current_winner));\nendproperty\nassert property (packet_switching_check);\n\n// Verify valid/ready handshake\nproperty valid_ready_handshake;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=>\n    outAxi4St.tvalid;\nendproperty\nassert property (valid_ready_handshake);\n```\n\n2. Arbitration Checks:\n```systemverilog\n// Verify round-robin behavior\nproperty round_robin_check;\n    @(posedge clock) disable iff (reset)\n    (current_winner == i && next_requests != 0) |->\n    ##[1:$] (current_winner == ((i + 1) % NumInputs));\nendproperty\nassert property (round_robin_check);\n\n// No grant without request\nproperty grant_requires_request;\n    @(posedge clock) disable iff (reset)\n    (|grant_out) |-> (|(grant_out & requests_in));\nendproperty\nassert property (grant_requires_request);\n```\n\n3. Data Path Checks:\n```systemverilog\n// Zero latency verification\nproperty zero_latency_check;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid |-> \n    (outAxi4St == inAxi4St[current_winner]);\nendproperty\nassert property (zero_latency_check);\n\n// Ready signal propagation\nproperty ready_propagation;\n    @(posedge clock) disable iff (reset)\n    (inTready[current_winner] == outTready);\nendproperty\nassert property (ready_propagation);\n```\n\n4. Reset Behavior:\n```systemverilog\n// Reset clears all control signals\nproperty reset_check;\n    @(posedge clock)\n    reset |=> \n    (active_transfer == '0) &&\n    (current_grant == '0);\nendproperty\nassert property (reset_check);\n```\n\n5. Packet Integrity:\n```systemverilog\n// Verify complete packet transfer\nproperty packet_completion;\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && outAxi4St.tlast && outTready) |->\n    ##[1:$] (!active_transfer[current_winner]);\nendproperty\nassert property (packet_completion);\n```\n\nCoverage Points:\n\n```systemverilog\ncovergroup arb_coverage;\n    // Input request patterns\n    cp_requests: coverpoint requests_in {\n        bins single_req[] = {[1:NumInputs]};\n        bins multi_req[] = {[2:$]};\n    }\n    \n    // Winner transitions\n    cp_winner: coverpoint current_winner {\n        bins transitions[] = ([0:NumInputs-1] => [0:NumInputs-1]);\n    }\n    \n    // Packet sizes\n    cp_packet_size: coverpoint packet_length {\n        bins small = {[1:4]};\n        bins medium = {[5:16]};\n        bins large = {[17:$]};\n    }\nendgroup\n```\n\nTest Organization:\n```systemverilog\nclass test_sequence extends uvm_sequence;\n    // Basic tests\n    test_single_input();\n    test_multiple_inputs();\n    \n    // Corner cases\n    test_max_bandwidth();\n    test_min_bandwidth();\n    test_reset_scenarios();\n    \n    // Stress tests\n    test_random_valid_ready();\n    test_continuous_switching();\n    \n    // Error injection\n    test_protocol_violations();\nend\n```\n\nThis verification plan ensures:\n- Complete functional coverage\n- Protocol compliance\n- Performance requirements\n- Corner case handling\n- Error detection\n- Robust operationWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks and describe their specific tasks:\n\n1. Round Robin Arbiter Interface Block:\n```systemverilog\nmodule arb_interface (\n    // Manages interaction with local_rrarb\n    input  logic                     clock,\n    input  logic                     reset,\n    input  logic [NumInputs-1:0]     requests,\n    input  logic                     update_enable,\n    output logic [NumInputs-1:0]     current_grant,\n    output logic [NumSelectBits-1:0] current_select\n);\n```\nTasks:\n- Interfaces with provided local_rrarb module\n- Manages arbitration updates\n- Tracks current winner\n- Handles reset conditions\n\n2. Packet Tracking Block:\n```systemverilog\nmodule packet_tracker (\n    // Monitors packet boundaries and active transfers\n    input  logic                     clock,\n    input  logic                     reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0]     current_grant,\n    output logic [NumInputs-1:0]     active_transfer,\n    output logic                     update_arb_enable\n);\n```\nTasks:\n- Tracks active packet transfers\n- Detects packet boundaries (tlast)\n- Determines when arbitration can update\n- Maintains packet integrity\n\n3. Input Request Manager:\n```systemverilog\nmodule request_manager (\n    // Generates and qualifies requests\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0]     active_transfer,\n    output logic [NumInputs-1:0]     qualified_requests\n);\n```\nTasks:\n- Generates request signals from tvalid\n- Qualifies requests based on active transfers\n- Prevents mid-packet arbitration\n\n4. Output Multiplexer Block:\n```systemverilog\nmodule output_mux (\n    // Handles data path multiplexing\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumSelectBits-1:0]     select,\n    output AxiStreamType                 outAxi4St\n);\n```\nTasks:\n- Zero-latency multiplexing of input to output\n- Routes all AXI4-Stream signals\n- Maintains signal integrity\n\n5. Ready Generation Block:\n```systemverilog\nmodule ready_gen (\n    // Manages ready signal generation\n    input  logic                     outTready,\n    input  logic [NumInputs-1:0]     current_grant,\n    output logic [NumInputs-1:0]     inTready\n);\n```\nTasks:\n- Generates input ready signals\n- Routes outTready to selected input\n- Manages backpressure\n\nTop-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0\n) (\n    // Main module interconnecting all blocks\n    input  logic                     clock,\n    input  logic                     reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0]     inTready,\n    output AxiStreamType             outAxi4St,\n    input  logic                     outTready\n);\n```\n\nBlock Interconnection:\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Packet Tracker \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Request   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6   Arbiter    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  Output  \u2502\n\u2502  Manager   \u2502      \u2502  Interface   \u2502      \u2502   Mux    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                    \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n                    \u2502    Ready     \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502  Generation  \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nCommunication Between Blocks:\n1. Control Path:\n- Packet Tracker \u2192 Arbiter Interface: Update enabling\n- Request Manager \u2192 Arbiter Interface: Request signals\n- Arbiter Interface \u2192 Ready Generation: Grant signals\n\n2. Data Path:\n- Input \u2192 Request Manager: Valid signals\n- Arbiter Interface \u2192 Output Mux: Selection control\n- Ready Generation \u2192 Outputs: Ready signals\n\nEach block's advantages:\n1. Modularity: Easy to modify individual blocks\n2. Testability: Each block can be verified independently\n3. Maintainability: Clear separation of concerns\n4. Reusability: Blocks can be used in other designs\n5. Debug: Easy to isolate issues\n\nThis modular approach ensures:\n- Clean design hierarchy\n- Clear functionality separation\n- Easy modification and maintenance\n- Simplified verification\n- Better code organizationWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write SystemVerilog code for each submodule and highlight their critical interfaces:\n\n1. Round Robin Arbiter Interface:\n```systemverilog\nmodule arb_interface #(\n    parameter int unsigned NumInputs = 4,\n    parameter int unsigned NumSelectBits = $clog2(NumInputs)\n) (\n    input  logic                     clock,\n    input  logic                     reset,\n    input  logic [NumInputs-1:0]     requests,\n    input  logic                     update_enable,\n    output logic [NumInputs-1:0]     current_grant,\n    output logic [NumSelectBits-1:0] current_select\n);\n\n    // Internal signals\n    logic [NumInputs-1:0]     grant_out;\n    logic [NumSelectBits-1:0] select_out;\n\n    // Instantiate provided round robin arbiter\n    local_rrarb #(\n        .NumInputs(NumInputs)\n    ) u_rrarb (\n        .clock(clock),\n        .reset(reset),\n        .update_valid(update_enable),\n        .requests_in(requests),\n        .grant_out(grant_out),\n        .select_out(select_out)\n    );\n\n    // Register outputs\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            current_grant  <= '0;\n            current_select <= '0;\n        end else if (update_enable) begin\n            current_grant  <= grant_out;\n            current_select <= select_out;\n        end\n    end\n\nendmodule\n```\n\n2. Packet Tracker:\n```systemverilog\nmodule packet_tracker #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumInputs = 4\n) (\n    input  logic                         clock,\n    input  logic                         reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0]         current_grant,\n    output logic [NumInputs-1:0]         active_transfer,\n    output logic                         update_arb_enable\n);\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            active_transfer <= '0;\n        end else begin\n            for (int i = 0; i < NumInputs; i++) begin\n                if (active_transfer[i]) begin\n                    if (inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n                        active_transfer[i] <= 1'b0;\n                    end\n                end else if (current_grant[i] && inAxi4St[i].tvalid) begin\n                    active_transfer[i] <= 1'b1;\n                end\n            end\n        end\n    end\n\n    // Generate update enable when no active transfers or current transfer completing\n    assign update_arb_enable = !active_transfer || \n                              (|(current_grant & inAxi4St.tvalid & inAxi4St.tlast));\n\nendmodule\n```\n\n3. Request Manager:\n```systemverilog\nmodule request_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumInputs = 4\n) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0]         active_transfer,\n    output logic [NumInputs-1:0]         qualified_requests\n);\n\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++) begin\n            qualified_requests[i] = inAxi4St[i].tvalid && !active_transfer[i];\n        end\n    end\n\nendmodule\n```\n\n4. Output Multiplexer:\n```systemverilog\nmodule output_mux #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumInputs = 4,\n    parameter int unsigned NumSelectBits = $clog2(NumInputs)\n) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumSelectBits-1:0]     select,\n    output AxiStreamType                 outAxi4St\n);\n\n    // Zero-latency multiplexing\n    always_comb begin\n        outAxi4St = inAxi4St[select];\n    end\n\nendmodule\n```\n\n5. Ready Generation:\n```systemverilog\nmodule ready_gen #(\n    parameter int unsigned NumInputs = 4\n) (\n    input  logic                     outTready,\n    input  logic [NumInputs-1:0]     current_grant,\n    output logic [NumInputs-1:0]     inTready\n);\n\n    // Generate ready signals\n    always_comb begin\n        inTready = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            inTready[i] = current_grant[i] && outTready;\n        end\n    end\n\nendmodule\n```\n\nCritical Interfaces Between Submodules:\n\n1. Control Signals:\n```systemverilog\n// Arbitration Control\nlogic [NumInputs-1:0]     current_grant;\nlogic [NumSelectBits-1:0] current_select;\nlogic                     update_arb_enable;\n```\n\n2. Status Signals:\n```systemverilog\nlogic [NumInputs-1:0] active_transfer;\nlogic [NumInputs-1:0] qualified_requests;\n```\n\n3. Data Path:\n```systemverilog\nAxiStreamType [NumInputs-1:0] inAxi4St;\nAxiStreamType                 outAxi4St;\n```\n\n4. Handshaking:\n```systemverilog\nlogic [NumInputs-1:0] inTready;\nlogic                 outTready;\n```\n\nCritical Interface Considerations:\n1. Timing Critical:\n   - Select to output mux path\n   - Ready generation path\n\n2. Control Dependencies:\n   - Packet tracking affects arbitration\n   - Grant signals affect ready generation\n\n3. Handshaking Requirements:\n   - Ready/valid coordination\n   - Packet boundary tracking\n\nThis modular design allows for:\n- Clean interfaces\n- Easy timing closure\n- Simple verification\n- Clear functionality separation\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n\nAdditionally, you are required to use the following module (without revealing the internals) to perform round robin arbitration. The outputs of local_rrarb (grant_out, and select_out) are held and will not change unless input update_valid=1. When update_valid=1, a requests_in (vector of request valid bits) is also set, and a new arbitration winner is on the outputs -- grant_out is a 1-hot vector, and select_out is the encoded winner with values between 0 and NumInputs-1.\n\nmodule local_rrarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rrarb_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb_test.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb_test;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  oclib_axist_rrarb\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : oclib_axist_rrarb_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_3_test_sim/local_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = local_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = local_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : tb\n",
    "name": "test_axist_rrarb_3"
  },
  {
    "index": 12,
    "dut": "module dut #(\n    parameter int Depth = 8,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1,\n    parameter int unsigned AlmostFull = (Depth - 8),\n    parameter int unsigned AlmostEmpty = 0,\n    parameter bit PreferSrl = 0,\n    parameter int unsigned CountWidth = $clog2(Depth + 1)\n) (\n    input  logic                           clock,\n    input  logic                           reset,\n    input  AxiStreamType                   inAxi4St,\n    output logic                           inTready,\n    output AxiStreamType                   outAxi4St,\n    input  logic                           outTready,\n    output logic [CountWidth-1:0]          inCount,\n    output logic [CountWidth-1:0]          outCount,\n    input  logic                           inError,\n    input  logic [ExtraDataWidth-1:0]      inExtra,\n    output logic                           outError,\n    output logic [ExtraDataWidth-1:0]      outExtra,\n    output logic                           almostFull,\n    output logic                           almostEmpty\n);\n\n// Parameter validation\ninitial begin\n    assert ((Depth == 0) || ((Depth & (Depth-1)) == 0 && Depth > 1))\n    else $error(\"Depth must be 0 or power of 2 greater than 1\");\n    \n    assert (AxiStreamWidth > 0)\n    else $error(\"AxiStreamWidth must be positive\");\n    \n    assert (ExtraDataWidth > 0) \n    else $error(\"ExtraDataWidth must be positive\");\n    \n    assert (AlmostFull <= Depth)\n    else $error(\"AlmostFull must be <= Depth\");\n    \n    assert (AlmostEmpty <= AlmostFull)\n    else $error(\"AlmostEmpty must be <= AlmostFull\");\nend\n\n// Internal signals and types\ntypedef struct packed {\n    logic [AxiStreamWidth-1:0] tdata;\n    logic                      tkeep;\n    logic                      tuser;\n    logic                      tlast;\n    logic                      error;\n    logic [ExtraDataWidth-1:0] extra;\n} fifo_data_t;\n\nfifo_data_t                    fifo_in_data;\nfifo_data_t                    fifo_out_data;\nlogic                          fifo_in_valid;\nlogic                          fifo_in_ready;\nlogic                          fifo_out_valid;\nlogic                          fifo_out_ready;\n\n// Bypass mode (Depth = 0)\ngenerate\nif (Depth == 0) begin : g_bypass\n    always_comb begin\n        outAxi4St.tdata  = inAxi4St.tdata;\n        outAxi4St.tkeep  = inAxi4St.tkeep;\n        outAxi4St.tuser  = inAxi4St.tuser;\n        outAxi4St.tlast  = inAxi4St.tlast;\n        outAxi4St.tvalid = inAxi4St.tvalid;\n        inTready         = outTready;\n        outError         = inError;\n        outExtra        = inExtra;\n        inCount         = '0;\n        outCount        = '0;\n        almostFull      = 1'b0;\n        almostEmpty     = 1'b1;\n    end\nend else begin : g_fifo\n    // Pack input data\n    always_comb begin\n        fifo_in_data.tdata  = inAxi4St.tdata;\n        fifo_in_data.tkeep  = inAxi4St.tkeep;\n        fifo_in_data.tuser  = inAxi4St.tuser;\n        fifo_in_data.tlast  = inAxi4St.tlast;\n        fifo_in_data.error  = inError;\n        fifo_in_data.extra  = inExtra;\n        fifo_in_valid       = inAxi4St.tvalid;\n    end\n\n    // Unpack output data\n    always_comb begin\n        outAxi4St.tdata  = fifo_out_data.tdata;\n        outAxi4St.tkeep  = fifo_out_data.tkeep;\n        outAxi4St.tuser  = fifo_out_data.tuser;\n        outAxi4St.tlast  = fifo_out_data.tlast;\n        outAxi4St.tvalid = fifo_out_valid;\n        outError         = fifo_out_data.error;\n        outExtra        = fifo_out_data.extra;\n        fifo_out_ready   = outTready;\n    end\n\n    // Instantiate local_fifo\n    local_fifo #(\n        .Width($bits(fifo_data_t)),\n        .Depth(Depth),\n        .DataType(fifo_data_t),\n        .AlmostFull(AlmostFull),\n        .AlmostEmpty(AlmostEmpty),\n        .CountWidth(CountWidth)\n    ) u_fifo (\n        .clock(clock),\n        .reset(reset),\n        .almostFull(almostFull),\n        .almostEmpty(almostEmpty),\n        .inCount(inCount),\n        .outCount(outCount),\n        .inData(fifo_in_data),\n        .inValid(fifo_in_valid),\n        .inReady(fifo_in_ready),\n        .outData(fifo_out_data),\n        .outValid(fifo_out_valid),\n        .outReady(fifo_out_ready)\n    );\n\n    assign inTready = fifo_in_ready;\nend\nendgenerate\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that acts as a simple ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported.\n\nAdditionally, you must use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 8\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 0, or a power-of-2.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned AlmostFull = (Depth - 8)\n        -- Number of entries (less than or equal to Depth), that if this many entries or more are occupied in the FIFO, module output almostFull is set to 1.\n     -- parameter int unsigned AlmostEmpty = 0\n        -- Number of entries: that if fewer than this many entries are occupied in the FIFO, module output almostEmpty is set to 1.\n     -- parameter bit          PreferSrl = 0\n        -- Style of the underlying FIFO. This can be left at value 0 and not used internally, but must exist in the parameter list.\n     --  parameter int unsigned CountWidth     = $clog2(Depth + 1)\n        -- Width in bits for module outputs inCount and outCount.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n       -- All fields of inAxi4St, except tvalid, must be stored in the FIFO if DEPTH > 0.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: inCount\n       -- output logic [CountWidth - 1 : 0] inCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if inCount==Depth, then inTready should be 0, because the FIFO is full.\n    -- Output: outCount\n       -- output logic [CountWidth - 1 : 0] outCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if outCount==0, then outAxi4St.tvalid should be 0, because the FIFO is empty\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: almostFull\n       -- output logic almostFull\n       -- is 1 when inCount >= AlmostFull\n    -- Output: almostEmpty\n       -- output logic almostEmpty\n       -- is 1 when outCount <= AlmostEmpty\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module implements a FIFO (First-In-First-Out) buffer specifically designed for AXI4-Stream protocol with additional features. Its main purposes are:\n\n1. Buffer AXI4-Stream data when Depth > 0:\n   - Stores AXI4-Stream protocol signals (tdata, tkeep, tuser, tlast)\n   - Also stores additional signals (inError, inExtra)\n   - Implements ready/valid handshaking protocol\n\n2. Bypass mode when Depth = 0:\n   - Direct connection between input and output (no buffering)\n\n3. Status reporting:\n   - Provides occupancy counts (inCount, outCount)\n   - Reports almost full/empty conditions\n   - Handles backpressure through ready/valid signals\n\nHigh-level Block Diagram:\n```\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502              DUT                     \u2502\ninAxi4St \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2500\u2524                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outAxi4St\ninTready \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                      \u2502\n                    \u2502         local_fifo                    \u2502\ninError \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2524     (when Depth > 0)                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outError\ninExtra \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2524                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outExtra\n                    \u2502                                      \u2502\n                    \u2502                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba almostFull\n                    \u2502                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba almostEmpty\n                    \u2502                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba inCount\nclock \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2524                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outCount\nreset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2524                                      \u2502\noutTready \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2524                                      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThe module uses an existing 'local_fifo' component internally when Depth > 0, and implements bypass logic when Depth = 0. The design combines AXI4-Stream protocol handling with standard FIFO functionality, making it suitable for buffering and flow control in AXI4-Stream interfaces.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nKey Parameters:\n1. FIFO Depth:\n```systemverilog\nparameter int Depth = 8\n```\n- Must be 0 (bypass) or power of 2\n- Default of 8 is reasonable for small buffering needs\n- Depth = 1 is explicitly not supported\n\n2. AXI Stream Data Type:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n```\n- Default is 8-bit data structure\n- Should be flexible to support different data widths\n\n3. AXI Stream Width:\n```systemverilog\nparameter int unsigned AxiStreamWidth = 8\n```\n- Matches tdata width in AxiStreamType\n- Default matches the default struct\n\n4. Extra Data Width:\n```systemverilog\nparameter int unsigned ExtraDataWidth = 1\n```\n- For additional sideband data\n- Minimal default width of 1 is reasonable\n\n5. Almost Full/Empty Thresholds:\n```systemverilog\nparameter int unsigned AlmostFull = (Depth - 8)\nparameter int unsigned AlmostEmpty = 0\n```\n- AlmostFull default leaves headroom for 8 entries\n- AlmostEmpty default is conservative\n\n6. Implementation Style:\n```systemverilog\nparameter bit PreferSrl = 0\n```\n- FIFO implementation preference\n- Default of 0 is specified\n\n7. Count Width:\n```systemverilog\nparameter int unsigned CountWidth = $clog2(Depth + 1)\n```\n- Automatically calculated based on Depth\n- No default needed as it's derived\n\nReasonable Constraints:\n1. Depth must be validated:\n```systemverilog\n// Example assertion\nassert property (@(posedge clock) \n    (Depth == 0) || ((Depth & (Depth-1)) == 0 && Depth > 1));\n```\n\n2. Width parameters must be positive:\n```systemverilog\n// Example assertions\nassert property (AxiStreamWidth > 0);\nassert property (ExtraDataWidth > 0);\n```\n\n3. Almost thresholds must be within bounds:\n```systemverilog\nassert property (AlmostFull <= Depth);\nassert property (AlmostEmpty <= AlmostFull);\n```\n\nThese parameters provide flexibility while maintaining reasonable defaults for common use cases. The validation ensures proper configuration during implementation.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation requirements, and necessary logic:\n\n1. Data Path Logic:\n\nA. Bypass Mode (Depth = 0):\n```systemverilog\n// Direct combinational connections\nalways_comb begin\n    if (Depth == 0) begin\n        // Forward all signals directly\n        outAxi4St = inAxi4St;\n        inTready = outTready;\n        outError = inError;\n        outExtra = inExtra;\n        // Status signals\n        inCount = '0;\n        outCount = '0;\n        almostFull = 1'b0;\n        almostEmpty = 1'b1;\n    end\nend\n```\n\nB. FIFO Mode (Depth > 0):\n```systemverilog\n// Need to create a packed structure for FIFO data\ntypedef struct packed {\n    logic [AxiStreamWidth-1:0] tdata;\n    logic                      tkeep;\n    logic                      tuser;\n    logic                      tlast;\n    logic                      error;\n    logic [ExtraDataWidth-1:0] extra;\n} fifo_data_t;\n\n// FIFO instance\nfifo_data_t fifo_in_data, fifo_out_data;\n\nlocal_fifo #(\n    .Width(AxiStreamWidth + 3 + ExtraDataWidth + 1), // All fields combined\n    .Depth(Depth),\n    .DataType(fifo_data_t),\n    .AlmostFull(AlmostFull),\n    .AlmostEmpty(AlmostEmpty)\n) fifo_inst (\n    // ... port connections\n);\n```\n\n2. Required Registers:\n- None needed in bypass mode\n- FIFO internal registers handled by local_fifo module\n\n3. Input Stage Logic:\n```systemverilog\n// Pack input data into FIFO structure\nalways_comb begin\n    fifo_in_data.tdata = inAxi4St.tdata;\n    fifo_in_data.tkeep = inAxi4St.tkeep;\n    fifo_in_data.tuser = inAxi4St.tuser;\n    fifo_in_data.tlast = inAxi4St.tlast;\n    fifo_in_data.error = inError;\n    fifo_in_data.extra = inExtra;\nend\n```\n\n4. Output Stage Logic:\n```systemverilog\n// Unpack FIFO output\nalways_comb begin\n    outAxi4St.tdata  = fifo_out_data.tdata;\n    outAxi4St.tkeep  = fifo_out_data.tkeep;\n    outAxi4St.tuser  = fifo_out_data.tuser;\n    outAxi4St.tlast  = fifo_out_data.tlast;\n    outAxi4St.tvalid = outValid;\n    outError         = fifo_out_data.error;\n    outExtra         = fifo_out_data.extra;\nend\n```\n\n5. Control Logic:\n```systemverilog\n// Handle valid/ready signaling\nassign inTready = (Depth == 0) ? outTready : fifo_inReady;\nassign outAxi4St.tvalid = (Depth == 0) ? inAxi4St.tvalid : fifo_outValid;\n\n// Status signals\nassign almostFull = (Depth == 0) ? 1'b0 : fifo_almostFull;\nassign almostEmpty = (Depth == 0) ? 1'b1 : fifo_almostEmpty;\nassign inCount = (Depth == 0) ? '0 : fifo_inCount;\nassign outCount = (Depth == 0) ? '0 : fifo_outCount;\n```\n\nKey Processing Points:\n1. Data transformation is primarily packing/unpacking between AXI4-Stream and FIFO data structures\n2. Control signals need proper handling for both bypass and FIFO modes\n3. Status signals must reflect appropriate values in both modes\n4. Error and Extra signals must be propagated through the FIFO alongside main data\n5. Ready/Valid handshaking must be preserved according to AXI4-Stream protocol\n\nThe design requires minimal combinational logic for data transformation and mostly relies on the local_fifo module for storage and control when Depth > 0.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nFrom the problem description and module interface, let's analyze the timing and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock   // Single clock input\n```\n- All operations are synchronous to this clock\n- No clock domain crossing required\n\nReset Requirements:\n1. Synchronous Reset:\n```systemverilog\ninput logic reset   // Specifically mentioned as synchronous reset\n```\n- Must be synchronous to clock\n- Active high reset signal\n\nSignals Requiring Reset:\n1. FIFO Control Signals:\n- All internal FIFO signals (handled by local_fifo)\n- Output valid signals\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        outAxi4St.tvalid <= 1'b0;\n    end\nend\n```\n\nLatency Characteristics:\n1. Bypass Mode (Depth = 0):\n- Zero-latency path\n- Combinational forwarding of all signals\n\n2. FIFO Mode (Depth > 0):\n- Minimum latency of 2 clock cycles through local_fifo\n  * 1 cycle for write\n  * 1 cycle for read\n- No maximum latency requirement specified\n\nThroughput Requirements:\n1. Full Rate Capability:\n- Must support consecutive transfers (one per clock)\n- Ready/Valid handshaking allows for backpressure\n```systemverilog\n// Can transfer when both valid and ready are high\nassign transfer = inAxi4St.tvalid && inTready;\n```\n\nTiming Constraints:\n1. Input Setup/Hold:\n- All inputs must meet setup/hold relative to clock edge\n- No specific timing constraints mentioned, use standard timing\n\n2. Output Timing:\n- Outputs must be registered to meet typical timing requirements\n- Status signals (almostFull, almostEmpty) can be combinational\n\nHandshaking Protocol:\n1. AXI4-Stream Protocol:\n```systemverilog\n// Valid to Ready timing relationship\n// Valid must remain stable until handshake\nassert property (@(posedge clock) \n    inAxi4St.tvalid && !inTready |=> $stable(inAxi4St));\n```\n\nPerformance Considerations:\n1. Zero-bubble Operation:\n- Should support back-to-back transfers\n- No artificial bubbles in data stream\n\n2. Flow Control:\n- Backpressure through ready signal\n- Must not lose data when FIFO is full\n\nExample Timing:\n```\nClock     _|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e|_\nReset     \u203e\u203e\u203e|_________________\nValid     ___|\u203e\u203e\u203e|___|\u203e\u203e\u203e|____\nReady     \u203e\u203e\u203e\u203e\u203e|\u203e\u203e\u203e|\u203e\u203e\u203e|\u203e\u203e\u203e|__\nTransfer  ___|\u203e|___|\u203e|___|\u203e|__\n```\n\nThese timing and reset requirements ensure:\n1. Proper data synchronization\n2. Deterministic behavior after reset\n3. Reliable data transfer with flow control\n4. Compatible operation with AXI4-Stream protocol\n5. Predictable latency based on operating modeWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet's break down the necessary test scenarios and assertions to verify this module:\n\nTest Scenarios:\n1. Basic Functionality Tests:\n```systemverilog\n// Bypass mode (Depth = 0)\n- Direct data pass-through\n- Ready/Valid handshaking\n- Error and Extra signal propagation\n\n// FIFO mode (Depth > 0)\n- Write to empty FIFO\n- Read from full FIFO\n- Back-to-back transfers\n- Partial fills and drains\n```\n\n2. Corner Cases:\n```systemverilog\n// Full/Empty Conditions\n- Write to full FIFO\n- Read from empty FIFO\n- Almost full/empty transitions\n- Simultaneous read/write at boundaries\n\n// Reset Behavior\n- Reset during active transfer\n- Reset when FIFO full\n- Reset when FIFO empty\n```\n\n3. Protocol Tests:\n```systemverilog\n// AXI4-Stream Protocol\n- Complete packet transfers (tlast handling)\n- Partial packet transfers\n- Backpressure scenarios\n- tkeep/tuser signal propagation\n```\n\nAssertions:\n1. Parameter Checks:\n```systemverilog\n// Depth validation\nassert property (@(posedge clock)\n    (Depth == 0) || ((Depth & (Depth-1)) == 0 && Depth > 1))\nelse $error(\"Depth must be 0 or power of 2 greater than 1\");\n\n// Width parameter checks\nassert property (AxiStreamWidth > 0)\nelse $error(\"AxiStreamWidth must be positive\");\n\nassert property (ExtraDataWidth > 0)\nelse $error(\"ExtraDataWidth must be positive\");\n```\n\n2. Protocol Assertions:\n```systemverilog\n// Valid stability\nassert property (@(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |=> $stable(inAxi4St))\nelse $error(\"AXI4-Stream inputs must remain stable when not accepted\");\n\n// Last with valid\nassert property (@(posedge clock) disable iff (reset)\n    inAxi4St.tlast |-> inAxi4St.tvalid)\nelse $error(\"tlast must be accompanied by tvalid\");\n```\n\n3. FIFO Behavior:\n```systemverilog\n// Count consistency\nassert property (@(posedge clock) disable iff (reset)\n    inCount <= Depth)\nelse $error(\"inCount exceeded FIFO depth\");\n\n// Full/Empty conditions\nassert property (@(posedge clock) disable iff (reset)\n    (inCount == Depth) |-> !inTready)\nelse $error(\"FIFO accepting data when full\");\n\nassert property (@(posedge clock) disable iff (reset)\n    (outCount == 0) |-> !outAxi4St.tvalid)\nelse $error(\"FIFO providing data when empty\");\n```\n\n4. Data Integrity:\n```systemverilog\n// Data preservation\nsequence DataMatch;\n    @(posedge clock) \n    (inAxi4St.tvalid && inTready) |=> ##[1:Depth] \n    (outAxi4St.tvalid && outTready && \n     outAxi4St.tdata == $past(inAxi4St.tdata));\nendsequence\nassert property (DataMatch)\nelse $error(\"Data corruption detected\");\n```\n\n5. Status Signal Checks:\n```systemverilog\n// Almost full/empty conditions\nassert property (@(posedge clock) disable iff (reset)\n    (inCount >= AlmostFull) == almostFull)\nelse $error(\"Almost full signal incorrect\");\n\nassert property (@(posedge clock) disable iff (reset)\n    (outCount <= AlmostEmpty) == almostEmpty)\nelse $error(\"Almost empty signal incorrect\");\n```\n\nCoverage Points:\n```systemverilog\n// Transition coverage\ncovergroup fifo_states @(posedge clock);\n    full_to_empty: coverpoint inCount {\n        bins transition[] = (Depth => 0);\n    }\n    empty_to_full: coverpoint inCount {\n        bins transition[] = (0 => Depth);\n    }\nendgroup\n\n// Protocol coverage\ncovergroup axi_transfers @(posedge clock);\n    valid_ready: coverpoint {inAxi4St.tvalid, inTready} {\n        bins handshake = {2'b11};\n        bins backpressure = {2'b10};\n    }\nendgroup\n```\n\nThese test scenarios and assertions should:\n1. Verify correct functionality in all operating modes\n2. Ensure protocol compliance\n3. Catch timing and synchronization issues\n4. Validate data integrity\n5. Verify proper status reporting\n6. Ensure proper reset behavior\n7. Achieve good functional coverageWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the logical functional blocks for this design:\n\n1. Parameter Validation Block:\n```systemverilog\nmodule dut_param_check #(parameters...);\n    // Purpose: Validate parameter combinations\n    // Tasks:\n    // - Check FIFO depth is valid (0 or power of 2)\n    // - Verify width parameters are positive\n    // - Ensure AlmostFull/Empty thresholds are valid\n```\n\n2. Input Interface Block:\n```systemverilog\nmodule dut_input_stage #(parameters...);\n    // Purpose: Handle input processing and packing\n    // Tasks:\n    // - Pack AXI4-Stream signals into FIFO structure\n    // - Combine inError and inExtra with main data\n    // - Handle input handshaking\n    // - Generate inTready signal\n```\n\n3. FIFO Control Block:\n```systemverilog\nmodule dut_fifo_ctrl #(parameters...);\n    // Purpose: Manage FIFO operations\n    // Tasks:\n    // - Instantiate and control local_fifo\n    // - Track FIFO counts\n    // - Generate status signals (almostFull/Empty)\n    // - Handle read/write control\n```\n\n4. Bypass Logic Block:\n```systemverilog\nmodule dut_bypass_logic #(parameters...);\n    // Purpose: Handle Depth=0 operation\n    // Tasks:\n    // - Direct signal forwarding\n    // - Generate appropriate status signals\n    // - Maintain protocol compliance\n```\n\n5. Output Interface Block:\n```systemverilog\nmodule dut_output_stage #(parameters...);\n    // Purpose: Handle output processing and unpacking\n    // Tasks:\n    // - Unpack FIFO data to AXI4-Stream format\n    // - Extract and forward Error/Extra signals\n    // - Handle output handshaking\n    // - Generate outAxi4St.tvalid\n```\n\n6. Status Generation Block:\n```systemverilog\nmodule dut_status_gen #(parameters...);\n    // Purpose: Generate status signals\n    // Tasks:\n    // - Calculate and output inCount/outCount\n    // - Generate almostFull/Empty signals\n    // - Track FIFO occupancy\n```\n\nTop-Level Integration:\n```systemverilog\nmodule dut #(parameters...) (\n    // System\n    input  logic        clock,\n    input  logic        reset,\n    \n    // Input interface\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    \n    // Output interface\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    \n    // Status\n    output logic [CountWidth-1:0] inCount,\n    output logic [CountWidth-1:0] outCount,\n    output logic                  almostFull,\n    output logic                  almostEmpty\n);\n\n    // Mode selection logic\n    logic bypass_mode;\n    assign bypass_mode = (Depth == 0);\n\n    // Interconnect signals\n    fifo_data_t packed_data;\n    logic       fifo_write;\n    logic       fifo_read;\n\n    // Instantiate submodules based on mode\n    generate\n        if (bypass_mode) begin : g_bypass\n            dut_bypass_logic bypass_inst (...);\n        end else begin : g_fifo\n            dut_input_stage input_inst (...);\n            dut_fifo_ctrl fifo_ctrl_inst (...);\n            dut_output_stage output_inst (...);\n            dut_status_gen status_inst (...);\n        end\n    endgenerate\n\nendmodule\n```\n\nAdvantages of This Modular Structure:\n1. Clear Separation of Concerns:\n   - Each block has a specific, well-defined function\n   - Easier to maintain and update individual components\n   - Simplified testing of each block\n\n2. Reusability:\n   - Blocks can be reused in other designs\n   - Common functionality is encapsulated\n\n3. Easier Verification:\n   - Can verify each block independently\n   - Simplified debugging\n   - Better coverage analysis\n\n4. Design Flexibility:\n   - Easy to modify individual blocks\n   - Can optimize critical paths\n   - Simpler to add new features\n\n5. Documentation:\n   - Clear structure makes design intent obvious\n   - Easier to understand and maintain\n   - Better for team collaboration\n\nThis modular approach helps manage complexity and makes the design more maintainable and verifiable.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide SystemVerilog code for each submodule and highlight their critical interfaces:\n\n1. Parameter Validation Block:\n```systemverilog\nmodule dut_param_check #(\n    parameter int Depth = 8,\n    parameter int unsigned AlmostFull = (Depth - 8),\n    parameter int unsigned AlmostEmpty = 0\n);\n    // Parameter validation using static assertions\n    initial begin\n        // Depth must be 0 or power of 2 > 1\n        assert ((Depth == 0) || ((Depth & (Depth-1)) == 0 && Depth > 1))\n        else $error(\"Invalid Depth parameter\");\n        \n        // Almost Full/Empty checks\n        assert (AlmostFull <= Depth)\n        else $error(\"AlmostFull must be <= Depth\");\n        \n        assert (AlmostEmpty <= AlmostFull)\n        else $error(\"AlmostEmpty must be <= AlmostFull\");\n    end\nendmodule\n```\n\n2. Input Interface Block:\n```systemverilog\nmodule dut_input_stage #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    input  logic                           clock,\n    input  logic                           reset,\n    // AXI Stream interface\n    input  AxiStreamType                   inAxi4St,\n    output logic                           inTready,\n    // Extra inputs\n    input  logic                           inError,\n    input  logic [ExtraDataWidth-1:0]      inExtra,\n    // FIFO interface\n    output fifo_data_t                     fifo_in_data,\n    output logic                           fifo_write,\n    input  logic                           fifo_ready\n);\n    // Pack input data\n    always_comb begin\n        fifo_in_data.tdata  = inAxi4St.tdata;\n        fifo_in_data.tkeep  = inAxi4St.tkeep;\n        fifo_in_data.tuser  = inAxi4St.tuser;\n        fifo_in_data.tlast  = inAxi4St.tlast;\n        fifo_in_data.error  = inError;\n        fifo_in_data.extra  = inExtra;\n        \n        fifo_write = inAxi4St.tvalid;\n        inTready   = fifo_ready;\n    end\nendmodule\n```\n\n3. FIFO Control Block:\n```systemverilog\nmodule dut_fifo_ctrl #(\n    parameter int Depth = 8,\n    parameter type DataType = fifo_data_t,\n    parameter int AlmostFull = (Depth - 8),\n    parameter int AlmostEmpty = 0\n) (\n    input  logic    clock,\n    input  logic    reset,\n    // FIFO data interface\n    input  DataType fifo_in_data,\n    input  logic    fifo_write,\n    output logic    fifo_ready,\n    output DataType fifo_out_data,\n    output logic    fifo_valid,\n    input  logic    fifo_read,\n    // Status outputs\n    output logic [CountWidth-1:0] inCount,\n    output logic [CountWidth-1:0] outCount,\n    output logic                  almostFull,\n    output logic                  almostEmpty\n);\n    // Instantiate local_fifo\n    local_fifo #(\n        .Width(DataType),\n        .Depth(Depth),\n        .DataType(DataType),\n        .AlmostFull(AlmostFull),\n        .AlmostEmpty(AlmostEmpty)\n    ) fifo_inst (\n        .clock(clock),\n        .reset(reset),\n        .inData(fifo_in_data),\n        .inValid(fifo_write),\n        .inReady(fifo_ready),\n        .outData(fifo_out_data),\n        .outValid(fifo_valid),\n        .outReady(fifo_read),\n        .inCount(inCount),\n        .outCount(outCount),\n        .almostFull(almostFull),\n        .almostEmpty(almostEmpty)\n    );\nendmodule\n```\n\n4. Output Interface Block:\n```systemverilog\nmodule dut_output_stage #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    input  logic                           clock,\n    input  logic                           reset,\n    // FIFO interface\n    input  fifo_data_t                     fifo_out_data,\n    input  logic                           fifo_valid,\n    output logic                           fifo_read,\n    // AXI Stream interface\n    output AxiStreamType                   outAxi4St,\n    input  logic                           outTready,\n    // Extra outputs\n    output logic                           outError,\n    output logic [ExtraDataWidth-1:0]      outExtra\n);\n    // Unpack output data\n    always_comb begin\n        outAxi4St.tdata  = fifo_out_data.tdata;\n        outAxi4St.tkeep  = fifo_out_data.tkeep;\n        outAxi4St.tuser  = fifo_out_data.tuser;\n        outAxi4St.tlast  = fifo_out_data.tlast;\n        outAxi4St.tvalid = fifo_valid;\n        \n        outError = fifo_out_data.error;\n        outExtra = fifo_out_data.extra;\n        \n        fifo_read = outTready && fifo_valid;\n    end\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Input Stage and FIFO Control:\n```systemverilog\ninterface fifo_write_if;\n    logic          write;\n    logic          ready;\n    fifo_data_t    data;\nendinterface\n```\n\n2. Between FIFO Control and Output Stage:\n```systemverilog\ninterface fifo_read_if;\n    logic          valid;\n    logic          read;\n    fifo_data_t    data;\nendinterface\n```\n\n3. Common Data Type Definition:\n```systemverilog\ntypedef struct packed {\n    logic [AxiStreamWidth-1:0] tdata;\n    logic                      tkeep;\n    logic                      tuser;\n    logic                      tlast;\n    logic                      error;\n    logic [ExtraDataWidth-1:0] extra;\n} fifo_data_t;\n```\n\n4. Status Interface:\n```systemverilog\ninterface fifo_status_if;\n    logic [CountWidth-1:0] inCount;\n    logic [CountWidth-1:0] outCount;\n    logic                  almostFull;\n    logic                  almostEmpty;\nendinterface\n```\n\nThese interfaces ensure:\n1. Clean separation between modules\n2. Well-defined data and control paths\n3. Easy to modify individual modules\n4. Clear protocol boundaries\n5. Simplified verification\n6. Reusable components\n\nWould you like me to provide more detail on any specific submodule or interface?\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a simple ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported.\n\nAdditionally, you must use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 8\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 0, or a power-of-2.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned AlmostFull = (Depth - 8)\n        -- Number of entries (less than or equal to Depth), that if this many entries or more are occupied in the FIFO, module output almostFull is set to 1.\n     -- parameter int unsigned AlmostEmpty = 0\n        -- Number of entries: that if fewer than this many entries are occupied in the FIFO, module output almostEmpty is set to 1.\n     -- parameter bit          PreferSrl = 0\n        -- Style of the underlying FIFO. This can be left at value 0 and not used internally, but must exist in the parameter list.\n     --  parameter int unsigned CountWidth     = $clog2(Depth + 1)\n        -- Width in bits for module outputs inCount and outCount.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n       -- All fields of inAxi4St, except tvalid, must be stored in the FIFO if DEPTH > 0.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: inCount\n       -- output logic [CountWidth - 1 : 0] inCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if inCount==Depth, then inTready should be 0, because the FIFO is full.\n    -- Output: outCount\n       -- output logic [CountWidth - 1 : 0] outCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if outCount==0, then outAxi4St.tvalid should be 0, because the FIFO is empty\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: almostFull\n       -- output logic almostFull\n       -- is 1 when inCount >= AlmostFull\n    -- Output: almostEmpty\n       -- output logic almostEmpty\n       -- is 1 when outCount <= AlmostEmpty\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_simple_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_simple_fifo\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_simple_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_3_test_sim/local_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = local_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = local_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_simple_fifo_3"
  },
  {
    "index": 14,
    "dut": "module dut #(\n    parameter type AxiStreamType = logic,\n    parameter int NumInputs = 4,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready\n);\n\n    // Internal signals\n    logic [NumInputs-1:0] grant;\n    logic [NumInputs-1:0] in_packet;\n    logic [$clog2(NumInputs)-1:0] grant_index;\n    logic [$clog2(NumInputs)-1:0] priority_ptr;\n    logic [NumInputs-1:0] requests;\n    logic [2*NumInputs-1:0] double_req, double_grant;\n\n    // Extract requests from input valid signals\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++)\n            requests[i] = inAxi4St[i].tvalid;\n    end\n\n    // Round Robin Priority Update\n    always_ff @(posedge clock) begin\n        if (reset)\n            priority_ptr <= '0;\n        else if (|grant)\n            priority_ptr <= grant_index + 1'b1;\n    end\n\n    // Round Robin Arbitration Logic\n    assign double_req = {requests, requests};\n\n    always_comb begin\n        double_grant = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            if (double_req[priority_ptr + i] && !in_packet[i])\n                double_grant[priority_ptr + i] = 1'b1;\n        end\n        \n        grant = double_grant[NumInputs-1:0] | double_grant[2*NumInputs-1:NumInputs];\n        if (|grant == 0 && |requests) begin\n            grant = requests & ~in_packet;\n        end\n        \n        grant = grant & ~(grant - 1);\n    end\n\n    // Grant Index Encoder\n    always_comb begin\n        grant_index = '0;\n        for (int i = 0; i < NumInputs; i++)\n            if (grant[i]) grant_index = i[$clog2(NumInputs)-1:0];\n    end\n\n    // Packet Tracking Logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_packet <= '0;\n        end else begin\n            for (int i = 0; i < NumInputs; i++) begin\n                if (inAxi4St[i].tvalid && grant[i] && inAxi4St[i].tlast)\n                    in_packet[i] <= 1'b0;\n                else if (inAxi4St[i].tvalid && grant[i])\n                    in_packet[i] <= 1'b1;\n            end\n        end\n    end\n\n    // Output Multiplexer\n    always_comb begin\n        outAxi4St = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            if (grant[i])\n                outAxi4St = inAxi4St[i];\n        end\n    end\n\n    // Ready Generation\n    assign inTready = grant & {NumInputs{outTready}};\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module is an AXI4-Stream Multiple-to-One Switch with Round-Robin Arbitration. Specifically:\n\n1. It takes multiple AXI4-Stream inputs (parameterized number, default=4) and multiplexes them to a single AXI4-Stream output\n2. Uses Round-Robin arbitration to ensure fair access among input ports requesting transfer\n3. Maintains packet/frame integrity by not switching inputs mid-packet\n4. Provides zero-latency data path from selected input to output\n5. Implements the AXI4-Stream handshaking protocol (tvalid/tready)\n\nHigh-Level Block Diagram:\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n inAxi4St[0] \u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                         \u2502\n                   \u2502                                         \u2502\n inAxi4St[1] \u2500\u2500\u2500\u2500\u2500\u25ba\u2502    Round-Robin                         \u251c\u2500\u2500\u2500\u2500\u25ba outAxi4St\n                   \u2502    Arbiter &         MUX                \u2502\n inAxi4St[2] \u2500\u2500\u2500\u2500\u2500\u25ba\u2502    Packet Tracker                      \u2502\n                   \u2502                                         \u2502\n inAxi4St[3] \u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                         \u2502\n                   \u2502                                         \u2502\n                   \u2502                                         \u2502\u25c4\u2500\u2500\u2500\u2500\u2500 outTready\n                   \u2502                                         \u2502\n clock \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                         \u2502\n                   \u2502                                         \u251c\u2500\u2500\u2500\u2500\u25ba inTready[3:0]\n reset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                         \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nKey Components:\n1. Round-Robin Arbiter: Keeps track of the last served input to ensure fair arbitration\n2. Packet Tracker: Monitors tlast signal to maintain packet integrity\n3. Multiplexer: Routes selected input to output\n4. Ready Logic: Generates appropriate tready signals for each input based on arbitration resultWhat aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let me outline the parameterizable aspects and their reasonable default values:\n\nRequired Parameters (as specified):\n1. `NumInputs` (Default = 4)\n   - Number of input AXI4-Stream ports\n   - Reasonable range: 2 to 16 (power of 2 values are common)\n\n2. `AxiStreamType` (Default = local_pkg::axi4st_8_s)\n   - Defines the structure of AXI4-Stream signals\n   - Default includes:\n     ```systemverilog\n     typedef struct packed {\n         logic [7:0] tdata;\n         logic       tkeep;\n         logic       tuser;\n         logic       tlast;\n         logic       tvalid;\n     } axi4st_8_s;\n     ```\n\n3. `AxiStreamWidth` (Default = 8)\n   - Width of tdata field\n   - Not used in implementation but must be included\n\n4. `FlopArbSel` (Default = 0)\n   - Not used in implementation but must be included\n   - Could potentially be used to add optional pipelining in arbitration logic\n\n5. `FlopOutput` (Default = 0)\n   - Not used in implementation but must be included\n   - Could potentially be used to add optional output registration\n\nReasonable Extensions (though not required):\n1. Arbitration Scheme Configuration\n   - Could allow switching between different arbitration schemes\n   - Default: Round Robin as specified\n\n2. Priority Levels\n   - Could add priority levels for different inputs\n   - Default: All inputs equal priority\n\nThe current parameter set is sufficient for the basic functionality while allowing future extensibility through the unused parameters if needed.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation requirements, and necessary logic elements:\n\nData Processing Flow:\n1. Input to Output Path:\n- Direct combinational path (zero latency requirement)\n- Selected input is multiplexed directly to output\n- No data transformation needed, just selection and routing\n\nRequired Registers:\n1. Round Robin State:\n```systemverilog\nlogic [$clog2(NumInputs)-1:0] current_priority;\n```\n- Tracks the last served input for fair arbitration\n\n2. Packet Tracking:\n```systemverilog\nlogic [NumInputs-1:0] in_packet;\n```\n- Tracks which inputs are currently transferring packets\n- Set when tvalid=1 after reset or tlast\n- Cleared when tlast=1 and transfer occurs\n\nRequired Combinational Logic:\n1. Request Detection:\n```systemverilog\nlogic [NumInputs-1:0] requests;\n// requests = inAxi4St[*].tvalid\n```\n\n2. Round Robin Arbitration:\n```systemverilog\nlogic [NumInputs-1:0] grant;\n// Determines next valid requester after current_priority\n```\n\n3. Output Multiplexer:\n```systemverilog\n// Selects winning input to route to output\nAxiStreamType outAxi4St;\n// outAxi4St = inAxi4St[grant_index]\n```\n\n4. Ready Generation:\n```systemverilog\nlogic [NumInputs-1:0] inTready;\n// inTready[i] = grant[i] && outTready\n```\n\nData Flow Diagram:\n```\nInputs                Processing                 Output\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         \u2502           \u2502              \u2502          \u2502\ninAxi4St \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   Mux &      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 outAxi4St\n[N-1:0]  \u2502          \u2502   Selection   \u2502          \u2502\n         \u2502          \u2502   Logic       \u2502          \u2502\n         \u2502          \u2502              \u2502          \u2502\n         \u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n         \u2502                 \u2502                   \u2502\n         \u2502          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n         \u2502          \u2502   Arbitration \u2502          \u2502\n         \u2502          \u2502   State &     \u2502          \u2502\n         \u2502          \u2502   Control     \u2502          \u2502\n         \u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n```\n\nThe design emphasizes combinational paths for zero-latency data transfer while maintaining proper arbitration and packet integrity through registered control logic.What verification considerations are important for this design? What corner cases should be tested?\n [NEW STEP]\n \nHere are the key verification considerations and corner cases that should be tested:\n\nBasic Functionality Tests:\n1. Single Transfer Verification\n- Basic single-cycle transfers from each input\n- Verify zero-latency requirement\n- Check correct data propagation\n\n2. Round Robin Arbitration\n- Verify fair rotation among active requests\n- Check that previously served input doesn't win immediately\n- Verify proper priority rotation after each packet\n\nPacket Integrity Tests:\n1. Multi-Cycle Packet Transfers\n- Verify complete packet transmission without interruption\n- Check tlast handling\n- Ensure no arbitration during packet transfer\n\n2. Back-to-Back Packets\n- Test consecutive packets from same input\n- Test consecutive packets from different inputs\n- Verify proper arbitration between packets\n\nCorner Cases:\n1. Reset Scenarios\n- Synchronous reset during packet transfer\n- Reset between packets\n- Reset with multiple active requests\n\n2. Backpressure Testing\n- outTready toggling during transfer\n- Long periods of outTready=0\n- Variable outTready patterns\n\n3. Multiple Simultaneous Requests\n- All inputs requesting simultaneously\n- Various combinations of active requests\n- Requests appearing/disappearing\n\n4. Boundary Conditions\n- Single-cycle packets (tvalid=1, tlast=1)\n- Maximum-length packets\n- Zero-length gaps between packets\n\n5. Protocol Edge Cases\n- tvalid deassertion mid-packet (protocol violation)\n- tlast without tvalid\n- Changing data while tvalid=1 but tready=0\n\nSuggested Testbench Features:\n```systemverilog\n// Scoreboarding\n- Track expected vs actual output packets\n- Verify Round Robin ordering\n- Check packet integrity\n\n// Coverage\n- Input combinations coverage\n- Arbitration state transitions\n- Backpressure scenarios\n- Packet length variations\n\n// Assertions\n- Protocol compliance checks\n- Packet integrity checks\n- Round Robin fairness checks\n- Zero-latency verification\n```\n\nAdditional Considerations:\n1. Performance Metrics\n- Measure arbitration fairness\n- Track latency statistics\n- Monitor bandwidth utilization\n\n2. Error Injection\n- Protocol violations\n- Timing violations\n- Reset during critical operations\n\n3. Configuration Testing\n- Different NumInputs values\n- Various data widths\n- Different packet sizes\n\nA comprehensive verification plan should include all these aspects to ensure robust design functionality.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the timing and reset requirements based on the problem description:\n\nClocking Requirements:\n1. Single Clock Domain\n- All logic operates on positive edge of 'clock' input\n- No clock domain crossing needed\n- Standard synchronous design\n\nLatency Requirements:\n1. Zero-Cycle Latency\n- Explicitly stated: \"zero cycles of latency from winning input to output\"\n- Implies combinational path for data\n```systemverilog\n// Must be combinational assignment\nassign outAxi4St = inAxi4St[selected_input];\n```\n\nThroughput Requirements:\n1. Back-to-Back Transfers\n- Must support consecutive transfers without bubbles\n- One transfer per clock cycle when tvalid=tready=1\n- Full throughput on packet transfers\n\nReset Requirements:\n1. Synchronous Reset\n- Explicitly stated: \"reset is a synchronous reset\"\n- Active-high reset assumed (not specified)\n\n2. Signals Requiring Reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Control registers\n        current_priority <= '0;\n        in_packet <= '0;\n        // Any other control state\n    end\nend\n```\n\nTiming Constraints:\n1. Critical Paths\n- Input to output multiplexing (combinational)\n- Arbitration logic to output selection\n```\nSetup/Hold Timing:\nInput \u2192 Output: Combinational\nInput \u2192 Arbitration Registers: 1 cycle\n```\n\n2. Non-Critical Paths\n- Round Robin priority update logic\n- Packet tracking logic\n\nTiming Diagram Example:\n```\nclock     : \u203e\\_/\u203e\\_/\u203e\\_/\u203e\\_/\u203e\\_/\u203e\\_/\u203e\nreset     : \u203e\u203e\u203e\\___________________\n           \ninAxi4St  : ===X=Valid=X=Valid=X===\ntvalid    : ___/\u203e\u203e\u203e\u203e\u203e\\___/\u203e\u203e\u203e\u203e\u203e\\___\ntlast     : ___/\u203e\u203e\u203e\u203e\u203e\\___/\u203e\u203e\u203e\u203e\u203e\\___\n           \noutAxi4St : ===X=Valid=X=Valid=X===\noutTready : \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n```\n\nKey Timing Considerations:\n1. Zero-Latency Path\n- Must meet timing for combinational path\n- May require careful synthesis constraints\n\n2. Control Logic\n- Single cycle for arbitration decisions\n- Must complete within clock period\n\n3. Handshaking\n- AXI4-Stream protocol timing must be maintained\n- tvalid/tready handshake must be clean\n\nThese requirements suggest a design that carefully balances combinational logic for data path with registered control logic for arbitration and packet tracking.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline comprehensive test scenarios and assertions needed for verification:\n\nTest Scenarios:\n1. Basic Protocol Testing\n```systemverilog\n// Single input active\nproperty single_input_transfer;\n  @(posedge clock) \n  $onehot(inAxi4St.tvalid) |-> ##1 outAxi4St.tvalid;\nendproperty\n\n// Basic handshaking\nsequence valid_ready_handshake;\n  outAxi4St.tvalid && outTready;\nendsequence\n```\n\n2. Round Robin Testing\n```systemverilog\n// Multiple requesting inputs\ntask test_round_robin;\n  // Activate multiple inputs\n  force inAxi4St[0].tvalid = 1;\n  force inAxi4St[1].tvalid = 1;\n  // Check rotation of grants\nendtask\n\n// Verify fair arbitration\nproperty round_robin_fairness;\n  @(posedge clock)\n  $onehot(grant) |=> !grant[$past(grant_index)];\nendproperty\n```\n\n3. Packet Integrity Testing\n```systemverilog\n// Single packet completion\nsequence packet_transfer;\n  first_beat ##[1:$] last_beat;\nendsequence\n\n// Back-to-back packets\ntask test_consecutive_packets;\n  // Send packet on input 0\n  // Immediately follow with packet on input 1\n  // Verify correct arbitration\nendtask\n```\n\n4. Corner Cases\n```systemverilog\ntask test_reset_during_packet;\n  // Start packet transfer\n  @(posedge clock);\n  reset <= 1;\n  // Verify proper recovery\nendtask\n\ntask test_backpressure;\n  // Toggle outTready during transfer\n  // Verify data integrity\nendtask\n```\n\nAssertions:\n1. Protocol Checks\n```systemverilog\n// Valid stable until ready\nassert property (@(posedge clock)\n  outAxi4St.tvalid && !outTready |=> $stable(outAxi4St))\nelse $error(\"AXI4-Stream protocol violation: valid data changed\");\n\n// No valid deassert mid-packet\nassert property (@(posedge clock)\n  (outAxi4St.tvalid && !outAxi4St.tlast) |=> outAxi4St.tvalid)\nelse $error(\"Valid deasserted mid-packet\");\n```\n\n2. Arbitration Checks\n```systemverilog\n// Verify zero latency\nassert property (@(posedge clock)\n  grant_changed |-> outAxi4St == inAxi4St[grant_index])\nelse $error(\"Zero latency requirement violated\");\n\n// Check round robin progression\nassert property (@(posedge clock)\n  $onehot(grant) |-> next_grant > current_grant)\nelse $error(\"Invalid round robin progression\");\n```\n\n3. Packet Integrity\n```systemverilog\n// No switching during packet\nassert property (@(posedge clock)\n  (outAxi4St.tvalid && !outAxi4St.tlast) |=> \n  $stable(grant))\nelse $error(\"Arbitration changed during packet\");\n\n// Packet completion\nassert property (@(posedge clock)\n  packet_start |-> eventually packet_end)\nelse $error(\"Packet never completed\");\n```\n\n4. Reset Behavior\n```systemverilog\n// Reset clears all control signals\nassert property (@(posedge clock)\n  reset |=> !outAxi4St.tvalid && current_priority == 0)\nelse $error(\"Incomplete reset\");\n```\n\nCoverage Points:\n```systemverilog\ncovergroup arb_cov @(posedge clock);\n  // Input combinations\n  cp_inputs: coverpoint inAxi4St.tvalid {\n    bins single_input[] = {8'b00000001, 8'b00000010, 8'b00000100};\n    bins multiple_inputs[] = {[8'b00000011:8'b11111111]};\n  }\n  \n  // Arbitration transitions\n  cp_arb: coverpoint grant {\n    bins transitions[] = ([0:NumInputs-1] => [0:NumInputs-1]);\n  }\n  \n  // Packet lengths\n  cp_packet_len: coverpoint packet_length {\n    bins short_packet = {[1:10]};\n    bins medium_packet = {[11:100]};\n    bins long_packet = {[101:$]};\n  }\nendgroup\n```\n\nThese verification elements should provide comprehensive coverage and catch potential issues early in the design cycle.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. Round Robin Arbiter Block\n```systemverilog\nmodule rr_arbiter (\n    input  logic clock,\n    input  logic reset,\n    input  logic [NumInputs-1:0] requests,\n    input  logic [NumInputs-1:0] in_packet,\n    output logic [NumInputs-1:0] grant,\n    output logic [$clog2(NumInputs)-1:0] grant_index\n);\n```\nTasks:\n- Maintains round robin priority\n- Generates grant signals based on requests\n- Ensures fair arbitration\n- Respects packet boundaries\n\n2. Packet Tracker\n```systemverilog\nmodule packet_tracker (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0] grant,\n    output logic [NumInputs-1:0] in_packet\n);\n```\nTasks:\n- Tracks active packets on each input\n- Detects packet boundaries (tlast)\n- Prevents arbitration during packet transmission\n\n3. Output Multiplexer\n```systemverilog\nmodule output_mux (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0] grant,\n    output AxiStreamType outAxi4St\n);\n```\nTasks:\n- Zero-latency multiplexing of selected input\n- Routes winner to output\n- Pure combinational logic\n\n4. Ready Generator\n```systemverilog\nmodule ready_gen (\n    input  logic [NumInputs-1:0] grant,\n    input  logic outTready,\n    output logic [NumInputs-1:0] inTready\n);\n```\nTasks:\n- Generates ready signals for inputs\n- Routes outTready to selected input\n- Handles backpressure\n\nTop-Level Integration:\n```systemverilog\nmodule dut (\n    // ... ports ...\n);\n    // Interconnect signals\n    logic [NumInputs-1:0] grant;\n    logic [NumInputs-1:0] in_packet;\n    logic [$clog2(NumInputs)-1:0] grant_index;\n\n    // Submodule instantiations\n    rr_arbiter arbiter (.*);\n    packet_tracker tracker (.*);\n    output_mux mux (.*);\n    ready_gen ready_logic (.*);\nendmodule\n```\n\nData Flow Between Blocks:\n```\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502  Packet Tracker \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502in_packet\n                       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Inputs  \u2502\u2500\u2500\u2500\u25ba\u2502   Arbiter   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502grant\n                       \u25bc\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502 Output Mux  \u2502\u2500\u2500\u2500\u25ba\u2502 Outputs \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u25b2\n                       \u2502\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502Ready Gen    \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThis modular approach provides several benefits:\n1. Clear separation of concerns\n2. Easier testing and verification\n3. Better maintainability\n4. Potential for reuse\n5. Simplified debugging\n\nEach block can be developed and verified independently before integration.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nLet me write SystemVerilog code for each submodule and identify critical interfaces:\n\n1. Round Robin Arbiter:\n```systemverilog\nmodule rr_arbiter #(\n    parameter int NumInputs = 4\n) (\n    input  logic clock,\n    input  logic reset,\n    input  logic [NumInputs-1:0] requests,\n    input  logic [NumInputs-1:0] in_packet,\n    output logic [NumInputs-1:0] grant,\n    output logic [$clog2(NumInputs)-1:0] grant_index\n);\n    logic [$clog2(NumInputs)-1:0] priority_ptr;\n    logic [2*NumInputs-1:0] double_req, double_grant;\n    \n    // Priority pointer update\n    always_ff @(posedge clock) begin\n        if (reset)\n            priority_ptr <= '0;\n        else if (|grant)\n            priority_ptr <= grant_index + 1'b1;\n    end\n    \n    // Double vector for wrap-around\n    assign double_req = {requests, requests};\n    \n    // Mask requests based on priority and in_packet\n    always_comb begin\n        double_grant = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            if (double_req[priority_ptr + i] && !in_packet[i])\n                double_grant[priority_ptr + i] = 1'b1;\n        end\n        \n        // Select first requester after priority pointer\n        grant = double_grant[NumInputs-1:0] | double_grant[2*NumInputs-1:NumInputs];\n        if (|grant == 0 && |requests) begin\n            // If no eligible request after priority, take first available\n            grant = requests & ~in_packet;\n        end\n        \n        // Force one-hot\n        grant = grant & ~(grant - 1);\n    end\n    \n    // Encode grant to index\n    always_comb begin\n        grant_index = '0;\n        for (int i = 0; i < NumInputs; i++)\n            if (grant[i]) grant_index = i[$clog2(NumInputs)-1:0];\n    end\nendmodule\n```\n\n2. Packet Tracker:\n```systemverilog\nmodule packet_tracker #(\n    parameter type AxiStreamType = logic\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0] grant,\n    output logic [NumInputs-1:0] in_packet\n);\n    // Track packet state for each input\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_packet <= '0;\n        end else begin\n            for (int i = 0; i < NumInputs; i++) begin\n                if (inAxi4St[i].tvalid && grant[i] && inAxi4St[i].tlast)\n                    in_packet[i] <= 1'b0;\n                else if (inAxi4St[i].tvalid && grant[i])\n                    in_packet[i] <= 1'b1;\n            end\n        end\n    end\nendmodule\n```\n\n3. Output Multiplexer:\n```systemverilog\nmodule output_mux #(\n    parameter type AxiStreamType = logic\n) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0] grant,\n    output AxiStreamType outAxi4St\n);\n    // Zero-latency multiplexing\n    always_comb begin\n        outAxi4St = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            if (grant[i])\n                outAxi4St = inAxi4St[i];\n        end\n    end\nendmodule\n```\n\n4. Ready Generator:\n```systemverilog\nmodule ready_gen #(\n    parameter int NumInputs = 4\n) (\n    input  logic [NumInputs-1:0] grant,\n    input  logic outTready,\n    output logic [NumInputs-1:0] inTready\n);\n    // Generate ready signals\n    assign inTready = grant & {NumInputs{outTready}};\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Arbiter and Packet Tracker:\n```systemverilog\n// Packet tracker informs arbiter of active packets\nlogic [NumInputs-1:0] in_packet;\n// Arbiter informs tracker of granted requests\nlogic [NumInputs-1:0] grant;\n```\n\n2. Between Arbiter and Multiplexer:\n```systemverilog\n// Arbiter controls mux selection\nlogic [NumInputs-1:0] grant;\n```\n\n3. Between Arbiter and Ready Generator:\n```systemverilog\n// Arbiter controls ready generation\nlogic [NumInputs-1:0] grant;\n```\n\nTop-level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = logic,\n    parameter int NumInputs = 4,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready\n);\n\n    logic [NumInputs-1:0] grant;\n    logic [NumInputs-1:0] in_packet;\n    logic [$clog2(NumInputs)-1:0] grant_index;\n    logic [NumInputs-1:0] requests;\n\n    // Extract requests\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++)\n            requests[i] = inAxi4St[i].tvalid;\n    end\n\n    // Instantiate submodules\n    rr_arbiter #(.NumInputs(NumInputs)) arbiter (.*);\n    packet_tracker #(.AxiStreamType(AxiStreamType)) tracker (.*);\n    output_mux #(.AxiStreamType(AxiStreamType)) mux (.*);\n    ready_gen #(.NumInputs(NumInputs)) ready_logic (.*);\n\nendmodule\n```\n\nThis implementation ensures proper interaction between submodules while maintaining the required zero-latency data path and round-robin arbitration.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rrarb_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb_test.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb_test;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  oclib_axist_rrarb\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : oclib_axist_rrarb_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : tb\n",
    "name": "test_axist_rrarb_2"
  },
  {
    "index": 15,
    "dut": "module rate_calculator (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        transfer_valid,\n    output logic        rate_exceeded\n);\n    logic [7:0] rate_counter;\n    logic [7:0] cycle_counter;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            rate_counter  <= '0;  \n            cycle_counter <= '0;\n        end\n        else begin\n            if (transfer_valid) begin\n                rate_counter <= rate_counter + i_rate_numerator;\n            end\n\n            if (cycle_counter == i_rate_denominator - 1) begin\n                cycle_counter <= '0;\n                rate_counter  <= '0;\n            end\n            else begin\n                cycle_counter <= cycle_counter + 1;\n            end\n        end\n    end\n\n    assign rate_exceeded = (rate_counter >= i_rate_denominator);\n\nendmodule\n\nmodule frame_tracker (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        tready, \n    input  logic        tlast,\n    output logic        in_frame\n);\n    \n    logic valid_transfer;\n    assign valid_transfer = tvalid && tready;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_frame <= 1'b0;\n        end\n        else if (valid_transfer) begin\n            if (tlast) begin\n                in_frame <= 1'b0;\n            end\n            else begin\n                in_frame <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule flow_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        rate_exceeded,\n    input  logic        in_frame,\n    input  logic        i_rate_by_frame,\n    input  logic        outTready,\n    output logic        inTready,\n    output logic        out_valid\n);\n\n    logic allow_transfer;\n\n    always_comb begin\n        if (i_rate_by_frame) begin\n            allow_transfer = !rate_exceeded || in_frame;\n        end\n        else begin\n            allow_transfer = !rate_exceeded;\n        end\n    end\n\n    assign inTready = allow_transfer && outTready;\n    assign out_valid = allow_transfer;\n\nendmodule\n\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    input  logic                         clock,\n    input  logic                         reset,\n    \n    input  AxiStreamType                 inAxi4St,\n    output logic                         inTready,\n    input  logic [ExtraDataWidth-1:0]    inExtra,\n    \n    output AxiStreamType                 outAxi4St,\n    input  logic                         outTready,\n    output logic [ExtraDataWidth-1:0]    outExtra,\n    \n    input  logic [7:0]                   i_rate_numerator,\n    input  logic [7:0]                   i_rate_denominator,\n    input  logic                         i_rate_by_frame\n);\n\n    logic        rate_exceeded;\n    logic        in_frame;\n    logic        valid_transfer;\n    logic        internal_valid;\n    AxiStreamType pipe_data;\n\n    local_axist_pipe #(\n        .NumStages(1),\n        .AxiStreamType(AxiStreamType)\n    ) u_pipe (\n        .clock,\n        .reset,\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .outAxi4St(pipe_data),\n        .outTready(outTready)\n    );\n\n    rate_calculator u_rate_calc (\n        .clock,\n        .reset,\n        .i_rate_numerator,\n        .i_rate_denominator,\n        .transfer_valid(valid_transfer),\n        .rate_exceeded\n    );\n\n    frame_tracker u_frame_track (\n        .clock,\n        .reset,\n        .tvalid(inAxi4St.tvalid),\n        .tready(inTready),\n        .tlast(inAxi4St.tlast),\n        .in_frame\n    );\n\n    flow_controller u_flow_ctrl (\n        .clock,\n        .reset,\n        .rate_exceeded,\n        .in_frame,\n        .i_rate_by_frame,\n        .outTready,\n        .inTready,\n        .out_valid(internal_valid)\n    );\n\n    assign valid_transfer = inAxi4St.tvalid && inTready;\n    \n    always_comb begin\n        outAxi4St = pipe_data;\n        outAxi4St.tvalid = internal_valid && pipe_data.tvalid;\n        outExtra = valid_transfer ? inExtra : '0;\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\nAddiotnally, please use the following module instance of axis_rate_limit:\n\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n\n\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nThe main functionality of this hardware module is to implement an AXI4-Stream Rate Limiter, which controls the data flow rate between an input AXI4-Stream interface and an output AXI4-Stream interface. Here's a breakdown of its key functions:\n\n1. Rate Limiting Control:\n- Takes input parameters rate_numerator and rate_denominator to calculate the desired throughput rate\n- Can operate in two modes based on rate_by_frame:\n  * Per-phit mode (rate_by_frame=0): Can throttle data at any time\n  * Frame mode (rate_by_frame=1): Only throttles between complete frames/packets\n\n2. AXI4-Stream Protocol Handling:\n- Maintains AXI4-Stream handshaking (ready/valid) protocol\n- Preserves packet boundaries using tlast signal\n- Passes through additional metadata (tuser, tkeep, etc.)\n\nHigh-level block diagram:\n```\n                    +-------------------------+\n                    |    Rate Limit Module    |\n                    |                         |\nInput AXI4-Stream   |  +-----------------+   |   Output AXI4-Stream\n------------------>|--|  Rate Control    |---|------------------>\n    inAxi4St       |  |    Logic        |   |    outAxi4St\n                    |  +-----------------+   |\n                    |          ^            |\nRate Control        |          |            |\nParameters     ---->|          |            |\n(num/denom/mode)    |  +-----------------+  |\n                    |  |   Rate Monitor   |  |\n                    |  +-----------------+  |\n                    |                         |\n                    +-------------------------+\n```\n\nThe module uses an existing local_axist_pipe component for sequential storage and includes support for extra data bits (inExtra/outExtra) that can be passed alongside the main data stream.\n\nThe rate limiting is achieved by controlling the ready/valid signals to create backpressure when needed to maintain the desired data rate.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\n1. Core AXI Stream Parameters:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n// Default structure contains:\n// - tdata[7:0]  (8-bit data)\n// - tkeep       (1-bit)\n// - tuser       (1-bit)\n// - tlast       (1-bit)\n// - tvalid      (1-bit)\n```\n\n2. Data Width Parameters:\n```systemverilog\nparameter int AxiStreamWidth = 8      // Width of tdata field\nparameter int unsigned ExtraDataWidth = 1  // Width of additional data\n```\n\n3. Optional Features (from axis_rate_limit module):\n```systemverilog\nparameter KEEP_ENABLE = (DATA_WIDTH>8)  // Enable tkeep signal\nparameter LAST_ENABLE = 1               // Enable tlast signal\nparameter ID_ENABLE = 0                 // Enable tid signal\nparameter DEST_ENABLE = 0               // Enable tdest signal\nparameter USER_ENABLE = 1               // Enable tuser signal\n\n// Associated Width Parameters\nparameter KEEP_WIDTH = ((DATA_WIDTH+7)/8)\nparameter ID_WIDTH = 8\nparameter DEST_WIDTH = 8\nparameter USER_WIDTH = 1\n```\n\nReasonable Default Values:\n1. Data Width:\n   - 8-bit is a good default for simple applications\n   - Common wider options: 16, 32, 64, 128 bits\n\n2. Control Signals:\n   - LAST_ENABLE = 1 (almost always needed for packet boundaries)\n   - USER_ENABLE = 1 (commonly used for metadata)\n   - ID_ENABLE, DEST_ENABLE = 0 (optional routing features)\n\n3. ExtraDataWidth:\n   - Default = 1 (minimum useful size)\n   - Can be increased based on application needs\n\n4. Buffer Depth (if using local_axist_pipe):\n   - NumStages = 1 (minimum pipeline depth)\n   - Can be increased for timing/throughput requirements\n\nThese parameters allow the module to be configured for:\n- Different data widths\n- Various metadata requirements\n- Additional data sideband signals\n- Pipeline depth optimization\n- Optional routing capabilities\n\nThe defaults represent a minimal but functional configuration suitable for basic streaming applications.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nFor this rate limiting module, here's the analysis of data processing, transformation, and required logic:\n\nData Path Components:\n\n1. Pipeline Storage (using local_axist_pipe):\n```systemverilog\nlocal_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n) u_pipe (\n    .clock,\n    .reset,\n    .inAxi4St,\n    .inTready,\n    .outAxi4St,\n    .outTready\n);\n```\n\n2. Rate Control Logic:\n```systemverilog\n// Registers needed\nlogic [7:0] rate_counter;      // Tracks current rate\nlogic [7:0] cycle_counter;     // Counts cycles for rate calculation\nlogic       rate_exceeded;     // Indicates if rate limit reached\nlogic       in_frame;          // Tracks if we're in middle of frame\n\n// Combinational logic\nlogic allow_transfer;  // Determines if transfer can proceed\n```\n\n3. Flow Control Logic:\n```systemverilog\n// Ready/Valid control\nassign inTready = !rate_exceeded && outTready;\nassign outAxi4St.tvalid = inAxi4St.tvalid && !rate_exceeded;\n\n// Data passthrough (no transformation needed)\nassign outAxi4St.tdata = inAxi4St.tdata;\nassign outAxi4St.tkeep = inAxi4St.tkeep;\nassign outAxi4St.tlast = inAxi4St.tlast;\nassign outAxi4St.tuser = inAxi4St.tuser;\nassign outExtra = inExtra;\n```\n\nRequired Logic Blocks:\n\n1. Rate Calculation:\n```systemverilog\n// Rate tracking\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        rate_counter <= '0;\n        cycle_counter <= '0;\n    end\n    else begin\n        // Update counters based on transfers\n        if (inAxi4St.tvalid && inTready) begin\n            rate_counter <= rate_counter + i_rate_numerator;\n        end\n        \n        if (cycle_counter == i_rate_denominator) begin\n            rate_counter <= '0;\n            cycle_counter <= '0;\n        end\n        else begin\n            cycle_counter <= cycle_counter + 1;\n        end\n    end\nend\n```\n\n2. Frame Tracking:\n```systemverilog\n// Track frame boundaries\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        in_frame <= 1'b0;\n    end\n    else if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n            in_frame <= 1'b0;\n        end\n        else begin\n            in_frame <= 1'b1;\n        end\n    end\nend\n```\n\n3. Rate Limiting Control:\n```systemverilog\n// Determine if rate is exceeded\nalways_comb begin\n    if (i_rate_by_frame) begin\n        rate_exceeded = (rate_counter >= i_rate_denominator) && !in_frame;\n    end\n    else begin\n        rate_exceeded = (rate_counter >= i_rate_denominator);\n    end\nend\n```\n\nKey Aspects:\n1. No data transformation is needed - this is a rate control module\n2. Main function is controlling ready/valid signals\n3. Uses pipeline module for buffering\n4. Maintains frame integrity based on i_rate_by_frame\n5. Tracks rate using counter-based approach\n6. Preserves AXI-Stream protocol requirements\n\nThe logic is primarily focused on:\n- Rate calculation and tracking\n- Frame boundary detection\n- Flow control signal generation\n- Data and control signal passthroughWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description, here are the clocking, timing, and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock   // Primary system clock\n```\n- All logic operates in single clock domain\n- No clock domain crossing required\n- All flip-flops should be positive edge triggered\n\nReset Requirements:\n1. Synchronous Reset:\n```systemverilog\ninput logic reset   // Synchronous reset, active high\n```\n- Problem explicitly states reset should be synchronous\n- All registers should be reset synchronously\n\nSignals Requiring Reset:\n```systemverilog\n// Core control registers\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        rate_counter   <= '0;\n        cycle_counter  <= '0;\n        in_frame       <= 1'b0;\n        rate_exceeded  <= 1'b0;\n    end\n    // ...\nend\n```\n\nLatency Requirements:\n1. Minimum Latency:\n- One clock cycle through local_axist_pipe (NumStages=1)\n- One additional cycle for rate limiting logic\n- Total expected latency: 2 clock cycles\n\n2. Pipeline Stages:\n```systemverilog\nlocal_axist_pipe #(\n    .NumStages(1)    // Minimum required stages\n) u_pipe (\n    // ...\n);\n```\n\nThroughput Requirements:\n1. Rate-Limited Throughput:\n- Maximum rate = i_rate_numerator / i_rate_denominator\n- Must maintain specified rate when enabled\n- Frame-based or continuous based on i_rate_by_frame\n\n2. AXI-Stream Protocol Timing:\n```systemverilog\n// Ready-Valid Handshaking\nassign valid_transfer = inAxi4St.tvalid && inTready;\n// Must maintain protocol timing requirements:\n// - tvalid cannot depend on tready\n// - data/control signals must be stable when tvalid=1\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n- All inputs should meet setup/hold relative to positive clock edge\n- All outputs should be registered to improve timing\n\n2. Critical Paths:\n```systemverilog\n// Rate calculation path\nalways_comb begin\n    next_rate = rate_counter + \n                (valid_transfer ? i_rate_numerator : '0);\n    rate_exceeded = (next_rate >= i_rate_denominator);\nend\n```\n\n3. Performance Considerations:\n- Ready/valid signals should have minimal combinatorial logic\n- Rate calculation should complete within one clock cycle\n- Pipeline additional stages if timing cannot be met\n\nSummary:\n- Synchronous design with single clock domain\n- Synchronous reset for all registers\n- 2-cycle minimum latency\n- Throughput controlled by rate parameters\n- Must maintain AXI-Stream protocol timing\n- Critical paths in rate calculation logic\n\nThe timing is primarily constrained by:\n1. Clock-to-Q of input registers\n2. Rate calculation combinatorial delay\n3. Setup time of output registers\n4. AXI-Stream protocol requirementsWhat verification approach would you recommend? What test scenarios should be checked?\n [NEW STEP]\n \nHere's a comprehensive verification approach for the AXI4-Stream Rate Limiter:\n\n1. Testbench Architecture:\n```systemverilog\nmodule tb_axis_rate_limit;\n    // Clock and Reset Generation\n    logic clock = 0;\n    logic reset;\n    \n    // Test Stimulus and Response\n    AxiStreamType inAxi4St;\n    logic        inTready;\n    AxiStreamType outAxi4St;\n    logic        outTready;\n    \n    // Rate Control\n    logic [7:0] i_rate_numerator;\n    logic [7:0] i_rate_denominator;\n    logic       i_rate_by_frame;\n    \n    // DUT Instance\n    dut #(\n        .AxiStreamType(AxiStreamType)\n    ) u_dut (.*);\n    \n    // Clock Generation\n    always #5 clock = ~clock;\n```\n\n2. Test Scenarios:\n\nA. Basic Functionality:\n```systemverilog\n// Test basic data transfer\ntask test_basic_transfer();\n    // Send single data word\n    drive_axi_data(8'hAA, 1'b1);\n    check_output(8'hAA, 1'b1);\nendtask\n\n// Test backpressure handling\ntask test_backpressure();\n    outTready <= 0;\n    drive_axi_data(8'hBB, 1'b0);\n    #20;\n    outTready <= 1;\nendtask\n```\n\nB. Rate Limiting Tests:\n```systemverilog\n// Test different rate configurations\ntask test_rate_limiting();\n    // Test 50% rate\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    \n    // Test 25% rate\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    \n    // Test 75% rate\n    i_rate_numerator   = 8'd3;\n    i_rate_denominator = 8'd4;\nendtask\n```\n\nC. Frame Mode Testing:\n```systemverilog\n// Test frame-based rate limiting\ntask test_frame_mode();\n    i_rate_by_frame = 1'b1;\n    \n    // Send complete frame\n    drive_frame_start();\n    drive_frame_data(8'hCC);\n    drive_frame_data(8'hDD);\n    drive_frame_end();\n    \n    // Verify rate limiting between frames\n    check_rate_pause();\nendtask\n```\n\n3. Coverage Points:\n\nA. Functional Coverage:\n```systemverilog\ncovergroup rate_cg;\n    rate_cp: coverpoint {i_rate_numerator, i_rate_denominator} {\n        bins low_rate    = {[0:25]};\n        bins med_rate    = {[26:75]};\n        bins high_rate   = {[76:100]};\n    }\n    \n    frame_mode_cp: coverpoint i_rate_by_frame;\nendgroup\n```\n\nB. Protocol Coverage:\n```systemverilog\ncovergroup axi_protocol_cg;\n    ready_valid_cp: coverpoint {inAxi4St.tvalid, inTready};\n    frame_cp: coverpoint {inAxi4St.tvalid, inAxi4St.tlast};\nendgroup\n```\n\n4. Assertions:\n\nA. Protocol Checks:\n```systemverilog\n// Valid/Ready Protocol\nproperty valid_stable;\n    @(posedge clock)\n    inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\nendproperty\n\n// Frame Integrity\nproperty frame_complete;\n    @(posedge clock)\n    $rose(inAxi4St.tvalid) |-> \n    eventually (inAxi4St.tlast && inAxi4St.tvalid && inTready);\nendproperty\n```\n\nB. Rate Limiting Checks:\n```systemverilog\n// Rate Compliance\nproperty rate_limit_check;\n    @(posedge clock)\n    transfer_count <= (total_cycles * i_rate_numerator / i_rate_denominator);\nendproperty\n```\n\n5. Corner Cases:\n- Minimum/maximum rates\n- Back-to-back frames\n- Single-cycle frames\n- Maximum frame sizes\n- Rate changes during transfer\n- Reset during transfer\n\n6. Performance Metrics:\n```systemverilog\n// Monitor actual throughput\ntask monitor_throughput();\n    int transfer_count;\n    int cycle_count;\n    real achieved_rate;\n    \n    // Calculate and compare with expected rate\nendtask\n```\n\n7. Recommended Test Flow:\n1. Basic connectivity tests\n2. Protocol compliance tests\n3. Rate limiting functionality\n4. Frame mode operation\n5. Corner cases\n6. Long-running stress tests\n7. Performance verification\n\n8. Additional Considerations:\n- Random stimulus generation\n- Error injection\n- Timing violation tests\n- Reset recovery tests\n- Performance analysis\n- Coverage closure\n- Regression testing\n\nThis verification approach ensures:\n- Functional correctness\n- Protocol compliance\n- Rate limiting accuracy\n- Frame integrity\n- Performance requirements\n- Corner case handling\n- Comprehensive coverageWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nHere's a detailed breakdown of test scenarios and assertions for the AXI4-Stream Rate Limiter:\n\n1. Basic Protocol Test Scenarios:\n```systemverilog\n// Basic handshaking assertions\nproperty axi_handshake_valid;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\nendproperty\nassert property (axi_handshake_valid) else\n    $error(\"AXI4-Stream valid dropped without ready\");\n\n// Test scenarios\ntask test_basic_protocol();\n    // Single transfer\n    drive_single_transfer(8'hAA);\n    \n    // Back-to-back transfers\n    drive_consecutive_transfers(8'hBB, 8'hCC);\n    \n    // Backpressure testing\n    drive_with_backpressure();\nendtask\n```\n\n2. Rate Limiting Test Scenarios:\n```systemverilog\n// Rate limiting assertions\nproperty rate_limit_check;\n    @(posedge clock) disable iff (reset)\n    transfer_count <= (cycle_count * i_rate_numerator / i_rate_denominator);\nendproperty\nassert property (rate_limit_check) else\n    $error(\"Rate limit exceeded\");\n\n// Test scenarios\ntask test_rate_limiting();\n    // Test different rates\n    test_rate(8'd1, 8'd2);  // 50%\n    test_rate(8'd1, 8'd4);  // 25%\n    test_rate(8'd3, 8'd4);  // 75%\n    \n    // Edge cases\n    test_rate(8'd1, 8'd1);  // 100%\n    test_rate(8'd0, 8'd1);  // 0%\nendtask\n```\n\n3. Frame Mode Test Scenarios:\n```systemverilog\n// Frame integrity assertions\nproperty frame_integrity;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St.tvalid) |-> \n    eventually (inAxi4St.tlast && inAxi4St.tvalid && inTready);\nendproperty\n\n// Test scenarios\ntask test_frame_mode();\n    // Short frame\n    drive_frame({8'hAA, 8'hBB});\n    \n    // Long frame\n    drive_long_frame(100);\n    \n    // Back-to-back frames\n    drive_consecutive_frames();\nendtask\n```\n\n4. Corner Case Scenarios:\n```systemverilog\n// Reset during transfer assertion\nproperty reset_recovery;\n    @(posedge clock)\n    reset |=> !outAxi4St.tvalid;\nendproperty\n\n// Test scenarios\ntask test_corner_cases();\n    // Reset during transfer\n    test_reset_during_transfer();\n    \n    // Rate change during frame\n    test_rate_change_mid_frame();\n    \n    // Minimum frame size\n    test_single_beat_frame();\n    \n    // Maximum frame size\n    test_max_size_frame();\nendtask\n```\n\n5. Error Injection Scenarios:\n```systemverilog\n// Protocol violation detection\nproperty valid_before_ready;\n    @(posedge clock) disable iff (reset)\n    !$stable(inAxi4St.tdata) |-> !inAxi4St.tvalid;\nendproperty\n\n// Test scenarios\ntask test_error_conditions();\n    // Invalid protocol sequences\n    test_invalid_handshake();\n    \n    // Invalid rate parameters\n    test_invalid_rate_params();\n    \n    // Incomplete frames\n    test_incomplete_frame();\nendtask\n```\n\n6. Performance Test Scenarios:\n```systemverilog\n// Latency checking\nproperty max_latency_check;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid |-> ##[1:3] outAxi4St.tvalid;\nendproperty\n\n// Test scenarios\ntask test_performance();\n    // Maximum throughput test\n    test_sustained_transfers();\n    \n    // Latency measurement\n    measure_transfer_latency();\n    \n    // Backpressure recovery\n    test_backpressure_recovery();\nendtask\n```\n\n7. Random Test Scenarios:\n```systemverilog\nclass random_stimulus;\n    rand bit [7:0] data;\n    rand bit       last;\n    rand int       delay;\n    \n    constraint valid_delays { delay inside {[0:10]}; }\nendclass\n\ntask test_random_scenarios();\n    random_stimulus stim = new();\n    repeat(1000) begin\n        assert(stim.randomize());\n        drive_random_transfer(stim);\n    end\nendtask\n```\n\n8. Coverage Points:\n```systemverilog\ncovergroup rate_coverage;\n    rate_cp: coverpoint {i_rate_numerator, i_rate_denominator} {\n        bins rates[] = {\n            {8'd1, 8'd2},  // 50%\n            {8'd1, 8'd4},  // 25%\n            {8'd3, 8'd4},  // 75%\n            {8'd1, 8'd1},  // 100%\n            {8'd0, 8'd1}   // 0%\n        };\n    }\nendgroup\n```\n\n9. Comprehensive System Test:\n```systemverilog\ntask run_full_test_suite();\n    // Initialize\n    reset_dut();\n    \n    // Run all test scenarios\n    test_basic_protocol();\n    test_rate_limiting();\n    test_frame_mode();\n    test_corner_cases();\n    test_error_conditions();\n    test_performance();\n    test_random_scenarios();\n    \n    // Check coverage\n    check_coverage();\n    \n    // Report results\n    report_test_results();\nendtask\n```\n\nThese test scenarios and assertions provide:\n- Comprehensive protocol verification\n- Rate limiting functionality validation\n- Frame handling verification\n- Corner case coverage\n- Performance validation\n- Error detection\n- Random testing\n- Coverage-driven verification completenessWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nHere's a logical breakdown of the design into functional blocks/submodules:\n\n1. AXI Stream Pipeline Block (Using local_axist_pipe):\n```systemverilog\nmodule axi_pipeline_stage (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    // Handles data buffering and flow control\n    // Provides pipeline stages for timing\n```\n\n2. Rate Calculator Block:\n```systemverilog\nmodule rate_calculator (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        transfer_valid,\n    output logic        rate_exceeded\n);\n    // Tracks current rate\n    // Calculates if rate limit is exceeded\n    // Maintains rate counters\n```\n\n3. Frame Tracker:\n```systemverilog\nmodule frame_tracker (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        tready,\n    input  logic        tlast,\n    output logic        in_frame\n);\n    // Tracks frame boundaries\n    // Maintains frame state\n    // Indicates active frame status\n```\n\n4. Flow Controller:\n```systemverilog\nmodule flow_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        rate_exceeded,\n    input  logic        in_frame,\n    input  logic        i_rate_by_frame,\n    input  logic        outTready,\n    output logic        inTready,\n    output logic        out_valid\n);\n    // Controls ready/valid signals\n    // Implements rate limiting logic\n    // Handles frame vs continuous mode\n```\n\n5. Extra Data Handler:\n```systemverilog\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic                      valid_transfer,\n    output logic [ExtraDataWidth-1:0] outExtra\n);\n    // Manages extra data signals\n    // Maintains alignment with main data\n```\n\n6. Top-Level Integration (dut):\n```systemverilog\nmodule dut (\n    // ... ports ...\n);\n    // Interconnections\n    logic        rate_exceeded;\n    logic        in_frame;\n    logic        valid_transfer;\n\n    // Submodule instantiations\n    rate_calculator u_rate_calc (\n        .clock,\n        .reset,\n        .i_rate_numerator,\n        .i_rate_denominator,\n        .transfer_valid(valid_transfer),\n        .rate_exceeded\n    );\n\n    frame_tracker u_frame_track (\n        .clock,\n        .reset,\n        .tvalid(inAxi4St.tvalid),\n        .tready(inTready),\n        .tlast(inAxi4St.tlast),\n        .in_frame\n    );\n\n    flow_controller u_flow_ctrl (\n        .clock,\n        .reset,\n        .rate_exceeded,\n        .in_frame,\n        .i_rate_by_frame,\n        .outTready,\n        .inTready,\n        .out_valid(outAxi4St.tvalid)\n    );\n    \n    // ... other submodules\nendmodule\n```\n\nFunctional Responsibilities:\n\n1. AXI Stream Pipeline:\n- Provides data buffering\n- Maintains AXI handshaking\n- Ensures timing requirements\n\n2. Rate Calculator:\n- Tracks transfer counts\n- Implements rate calculation\n- Determines when rate limit is exceeded\n- Maintains rate counters\n\n3. Frame Tracker:\n- Detects frame boundaries\n- Maintains frame state\n- Supports frame-based rate limiting\n- Tracks packet integrity\n\n4. Flow Controller:\n- Generates ready/valid signals\n- Implements rate limiting logic\n- Handles mode selection\n- Controls data flow\n\n5. Extra Data Handler:\n- Manages sideband data\n- Maintains data alignment\n- Handles extra data buffering\n\n6. Top-Level Integration:\n- Connects all submodules\n- Manages global signals\n- Provides external interface\n- Coordinates overall operation\n\nThis modular structure provides:\n- Clear functional separation\n- Simplified testing\n- Easy maintenance\n- Reusable components\n- Scalable design\n- Better debugging capabilitiesWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll break down each submodule with its code and then highlight the critical interfaces between them.\n\n1. Rate Calculator:\n```systemverilog\nmodule rate_calculator (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [7:0]  i_rate_numerator,\n    input  logic [7:0]  i_rate_denominator,\n    input  logic        transfer_valid,\n    output logic        rate_exceeded\n);\n    logic [7:0] rate_counter;\n    logic [7:0] cycle_counter;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            rate_counter  <= '0;\n            cycle_counter <= '0;\n        end\n        else begin\n            // Update rate counter on valid transfer\n            if (transfer_valid) begin\n                rate_counter <= rate_counter + i_rate_numerator;\n            end\n\n            // Reset counters when denominator reached\n            if (cycle_counter == i_rate_denominator - 1) begin\n                cycle_counter <= '0;\n                rate_counter  <= '0;\n            end\n            else begin\n                cycle_counter <= cycle_counter + 1;\n            end\n        end\n    end\n\n    assign rate_exceeded = (rate_counter >= i_rate_denominator);\n\nendmodule\n```\n\n2. Frame Tracker:\n```systemverilog\nmodule frame_tracker (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        tready,\n    input  logic        tlast,\n    output logic        in_frame\n);\n    \n    logic valid_transfer;\n    assign valid_transfer = tvalid && tready;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_frame <= 1'b0;\n        end\n        else if (valid_transfer) begin\n            if (tlast) begin\n                in_frame <= 1'b0;\n            end\n            else begin\n                in_frame <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n```\n\n3. Flow Controller:\n```systemverilog\nmodule flow_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        rate_exceeded,\n    input  logic        in_frame,\n    input  logic        i_rate_by_frame,\n    input  logic        outTready,\n    output logic        inTready,\n    output logic        out_valid\n);\n\n    logic allow_transfer;\n\n    always_comb begin\n        if (i_rate_by_frame) begin\n            allow_transfer = !rate_exceeded || in_frame;\n        end\n        else begin\n            allow_transfer = !rate_exceeded;\n        end\n    end\n\n    assign inTready  = allow_transfer && outTready;\n    assign out_valid = allow_transfer;\n\nendmodule\n```\n\n4. Extra Data Handler:\n```systemverilog\nmodule extra_data_handler #(\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic                      valid_transfer,\n    output logic [ExtraDataWidth-1:0] outExtra\n);\n\n    // Simple passthrough with valid transfer\n    assign outExtra = valid_transfer ? inExtra : '0;\n\nendmodule\n```\n\n5. Top-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1\n) (\n    input  logic                          clock,\n    input  logic                          reset,\n    \n    input  AxiStreamType                  inAxi4St,\n    output logic                          inTready,\n    input  logic [ExtraDataWidth-1:0]     inExtra,\n    \n    output AxiStreamType                  outAxi4St,\n    input  logic                          outTready,\n    output logic [ExtraDataWidth-1:0]     outExtra,\n    \n    input  logic [7:0]                    i_rate_numerator,\n    input  logic [7:0]                    i_rate_denominator,\n    input  logic                          i_rate_by_frame\n);\n\n    // Internal signals\n    logic        rate_exceeded;\n    logic        in_frame;\n    logic        valid_transfer;\n    logic        internal_valid;\n\n    // Submodule instantiations\n    rate_calculator u_rate_calc (\n        .clock,\n        .reset,\n        .i_rate_numerator,\n        .i_rate_denominator,\n        .transfer_valid(valid_transfer),\n        .rate_exceeded\n    );\n\n    frame_tracker u_frame_track (\n        .clock,\n        .reset,\n        .tvalid(inAxi4St.tvalid),\n        .tready(inTready),\n        .tlast(inAxi4St.tlast),\n        .in_frame\n    );\n\n    flow_controller u_flow_ctrl (\n        .clock,\n        .reset,\n        .rate_exceeded,\n        .in_frame,\n        .i_rate_by_frame,\n        .outTready,\n        .inTready,\n        .out_valid(internal_valid)\n    );\n\n    extra_data_handler #(\n        .ExtraDataWidth(ExtraDataWidth)\n    ) u_extra_data (\n        .inExtra,\n        .valid_transfer,\n        .outExtra\n    );\n\n    // Data path connections\n    assign valid_transfer = inAxi4St.tvalid && inTready;\n    \n    // Output assignments\n    always_comb begin\n        outAxi4St.tdata  = inAxi4St.tdata;\n        outAxi4St.tkeep  = inAxi4St.tkeep;\n        outAxi4St.tuser  = inAxi4St.tuser;\n        outAxi4St.tlast  = inAxi4St.tlast;\n        outAxi4St.tvalid = internal_valid && inAxi4St.tvalid;\n    end\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Rate Calculator and Flow Controller:\n- rate_exceeded: Indicates when rate limit is reached\n- transfer_valid: Signals successful transfers\n\n2. Between Frame Tracker and Flow Controller:\n- in_frame: Indicates active frame status\n- Valid/ready handshaking signals\n\n3. Between Flow Controller and Top Level:\n- inTready/outTready: Flow control signals\n- internal_valid: Rate-limited valid signal\n\n4. Global Interfaces:\n- clock and reset: Synchronization signals\n- Rate control parameters\n- AXI Stream protocol signals\n\nKey Interface Considerations:\n1. Timing alignment between modules\n2. Handshaking protocol compliance\n3. Frame boundary preservation\n4. Rate limiting coordination\n5. Data path integrity\n6. Control signal synchronization\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\nAddiotnally, please use the following module instance of axis_rate_limit:\n\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n\n\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_4_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_4"
  },
  {
    "index": 18,
    "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int unsigned AxiStreamWidth = 128,\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n) (\n    input  logic                    clock,\n    input  logic                    reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic        [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic        [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // Internal signals\n    logic [47:0] src_mac;\n    logic [47:0] dst_mac;\n    logic [$clog2(NumPorts)-1:0] src_port;\n    logic [$clog2(NumPorts)-1:0] dst_port;\n    logic dst_found;\n    logic is_broadcast;\n    logic is_multicast;\n    logic frame_valid;\n    logic [NumPorts-1:0] forward_mask;\n\n    // State definitions\n    typedef enum logic [2:0] {\n        IDLE,\n        PARSE_HEADER,\n        LOOKUP_MAC,\n        FORWARD\n    } state_t;\n\n    state_t current_state;\n\n    // MAC Table Entry definition\n    typedef struct packed {\n        logic [47:0] mac_addr;\n        logic [$clog2(NumPorts)-1:0] port_num;\n        logic valid;\n        logic [31:0] age_counter;\n    } mac_entry_t;\n\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n\n    // MAC Table Management\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_table <= '{default: '0};\n        end else begin\n            // Learning logic\n            if (frame_valid) begin\n                for (int i = 0; i < MacTableDepth; i++) begin\n                    if (!mac_table[i].valid || mac_table[i].mac_addr == src_mac) begin\n                        mac_table[i].mac_addr <= src_mac;\n                        mac_table[i].port_num <= src_port;\n                        mac_table[i].valid <= 1'b1;\n                        mac_table[i].age_counter <= '0;\n                        break;\n                    end\n                end\n            end\n\n            // Aging logic\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                        mac_table[i].valid <= 1'b0;\n                    else\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                end\n            end\n        end\n    end\n\n    // MAC Lookup Logic\n    always_comb begin\n        dst_found = 1'b0;\n        dst_port = '0;\n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (mac_table[i].valid && mac_table[i].mac_addr == dst_mac) begin\n                dst_found = 1'b1;\n                dst_port = mac_table[i].port_num;\n            end\n        end\n    end\n\n    // Frame parsing and control\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            current_state <= IDLE;\n            src_mac <= '0;\n            dst_mac <= '0;\n            src_port <= '0;\n            frame_valid <= 1'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    if (|inAxi4St.tvalid) begin\n                        current_state <= PARSE_HEADER;\n                        for (int i = 0; i < NumPorts; i++) begin\n                            if (inAxi4St[i].tvalid) begin\n                                src_port <= i;\n                                dst_mac <= inAxi4St[i].tdata[47:0];\n                                src_mac <= inAxi4St[i].tdata[95:48];\n                            end\n                        end\n                    end\n                end\n\n                PARSE_HEADER: begin\n                    current_state <= LOOKUP_MAC;\n                    frame_valid <= 1'b1;\n                    is_broadcast <= &dst_mac;\n                    is_multicast <= dst_mac[0];\n                end\n\n                LOOKUP_MAC: begin\n                    current_state <= FORWARD;\n                    frame_valid <= 1'b0;\n                end\n\n                FORWARD: begin\n                    current_state <= IDLE;\n                end\n\n                default: current_state <= IDLE;\n            endcase\n        end\n    end\n\n    // Forwarding logic\n    always_comb begin\n        forward_mask = '0;\n        if (current_state == FORWARD) begin\n            if (is_broadcast || is_multicast) begin\n                forward_mask = ~(1 << src_port);\n            end else if (dst_found) begin\n                forward_mask = (1 << dst_port);\n            end else begin\n                forward_mask = ~(1 << src_port);\n            end\n        end\n    end\n\n    // Output assignments\n    always_comb begin\n        inTready = '{default: '1};\n        outAxi4St = '{default: '0};\n        egressFifoDropEvents = '0;\n\n        for (int i = 0; i < NumPorts; i++) begin\n            if (forward_mask[i] && current_state == FORWARD) begin\n                outAxi4St[i] = inAxi4St[src_port];\n            end\n        end\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module can assume the following: it can drive output inTready with '1, and input outTready will be tied to '1 ('1 is a vector all all 1's for all ports in NumPorts).\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module is a 4-port Layer-2 Ethernet Switch that:\n1. Receives Ethernet frames on any of its 4 ports via AXI4-Stream interfaces\n2. Maintains a 16-entry MAC address learning table\n3. Makes forwarding decisions based on destination MAC addresses\n4. Forwards frames to appropriate output port(s) using these rules:\n   - No loopback (never forward to receiving port)\n   - Forward to specific port if destination MAC is known\n   - Forward to all other ports if destination MAC is unknown (flooding)\n   - Forward to all other ports for broadcast/multicast frames\n5. Ages out MAC table entries that haven't been used for a specified time\n\nHigh-Level Block Diagram would consist of:\n1. Input Interface Block (4 ports)\n   - AXI4-Stream receivers\n   - Frame buffering/processing\n\n2. MAC Learning Table\n   - 16 entries storing MAC addresses and associated ports\n   - Aging mechanism (counter per entry)\n   - Learning logic for source MAC addresses\n\n3. Forwarding Decision Logic\n   - MAC address lookup\n   - Port selection logic\n   - Broadcast/multicast detection\n\n4. Output Interface Block (4 ports)\n   - AXI4-Stream transmitters\n   - Frame forwarding logic\n\n5. Control Logic\n   - Reset handling\n   - Clock domain management\n   - Table management\n\nThe data flow would be:\nInput Ports \u2192 Frame Processing \u2192 MAC Table Lookup \u2192 Forwarding Decision \u2192 Output Port Selection \u2192 Output Ports\n\nThis creates a non-blocking switch architecture where multiple simultaneous transmissions can occur as long as they don't conflict on output ports.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their default values:\n\nAlready Specified Parameters:\n1. NumPorts (Default = 4)\n   - Number of input/output ports\n   - Reasonable range might be 2-8 ports for typical applications\n\n2. AxiStreamType (Default = local_pkg::axi4st_128_s)\n   - Defines the AXI4-Stream interface structure\n   - 128-bit data width is reasonable for Gigabit Ethernet\n\n3. AxiStreamWidth (Default = 128)\n   - Matches tdata width in AxiStreamType\n   - Common values: 32, 64, 128, 256, 512 bits\n\n4. MacTableDepth (Default = 16)\n   - Size of MAC address table\n   - 16 entries is reasonable for small networks\n\n5. MacTableCyclesPerEpoch (Default = 32'd1_750_000_000)\n   - Aging timeout for MAC table entries\n   - About 1.75 seconds at 1GHz clock\n\nAdditional Parameters That Could Be Useful:\n1. FIFO Depths\n   - For input/output buffering\n   - Reasonable default: 2048 bytes (largest frame + margin)\n\n2. MAC Address Width\n   - Currently fixed at 48 bits\n   - Could be parameterized for different protocols\n\n3. Frame Size Limits\n   - Min: 60 bytes\n   - Max: 1504 bytes\n   - Could be parameterized for jumbo frames\n\n4. Priority Levels\n   - For future QoS support\n   - Default: 1 (no priorities)\n\n5. Clock Frequency\n   - For timing calculations\n   - Default: 125MHz (typical for GigE)\n\nThese parameters allow the module to be configured for different:\n- Network sizes\n- Performance requirements\n- Memory constraints\n- Protocol variations\n- Bandwidth requirementsHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing flow and required logic elements:\n\nData Processing Flow:\n1. Input Processing\n   Registers/Logic needed:\n   - Input frame buffers (FIFOs) for each port\n   - Source MAC address extraction logic\n   - Destination MAC address extraction logic\n   - Frame length counters\n   - Frame validity checking logic\n\n2. MAC Table Management\n   Registers/Logic needed:\n   - MAC Address Table (16 entries)\n     * MAC address (48 bits)\n     * Port number (2 bits for 4 ports)\n     * Valid bit\n     * Age counter (matching MacTableCyclesPerEpoch)\n   - MAC learning combinational logic\n   - Age-out counter logic\n   - MAC lookup comparison logic\n\n3. Forwarding Decision\n   Combinational Logic needed:\n   - MAC address comparators\n   - Broadcast/multicast detection\n   - Port mapping logic\n   - Output port selection matrix\n\n4. Output Processing\n   Registers/Logic needed:\n   - Output frame buffers (FIFOs) per port\n   - Output multiplexing logic\n   - Frame forwarding state machines\n\nKey Registers:\n1. MAC Table Registers:\n```systemverilog\ntypedef struct packed {\n    logic [47:0] mac_addr;\n    logic [$clog2(NumPorts)-1:0] port_num;\n    logic valid;\n    logic [$clog2(MacTableCyclesPerEpoch)-1:0] age_counter;\n} mac_table_entry_t;\n\nmac_table_entry_t [MacTableDepth-1:0] mac_table;\n```\n\n2. Frame Processing Registers:\n```systemverilog\nlogic [47:0] curr_src_mac;\nlogic [47:0] curr_dst_mac;\nlogic [$clog2(NumPorts)-1:0] curr_rx_port;\nlogic [NumPorts-1:0] forward_mask;\n```\n\n3. State Machine Registers:\n```systemverilog\ntypedef enum logic [2:0] {\n    IDLE,\n    RECEIVE_HEADER,\n    MAC_LOOKUP,\n    FORWARD_FRAME,\n    UPDATE_TABLE\n} state_t;\n\nstate_t current_state;\n```\n\nCombinational Logic:\n1. MAC Address Learning:\n   - Compare incoming source MAC with table\n   - Find empty table entry if needed\n   - Update port mapping\n\n2. Forwarding Decision:\n   - MAC address lookup\n   - Broadcast/multicast detection\n   - Output port selection\n\n3. Age-out Logic:\n   - Counter comparisons\n   - Valid bit clearing\n\n4. Port Mapping:\n   - Input to output routing\n   - Loopback prevention\n   - Multiple destination handling\n\nThe design will need to handle multiple frames simultaneously across different ports, requiring careful state management and pipeline staging to maintain throughput.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nBased on the problem description and typical Ethernet switch requirements, let's analyze the timing aspects:\n\nClocking Requirements:\n1. Single Clock Domain\n- Clock input is specified\n- Must handle AXI4-Stream protocol timing\n- For GigE speeds, typical clock frequency would be 125MHz or higher\n\nReset Requirements:\n1. Synchronous Reset (explicitly specified)\n- All state elements should be reset including:\n  * MAC address table entries\n  * State machines\n  * Frame buffers\n  * Counters\n  * Control registers\n  * AXI4-Stream interface signals\n\nLatency Considerations:\n1. MAC Table Lookup\n- Should complete within 1-2 clock cycles\n- Parallel comparison for all 16 entries\n\n2. Frame Processing Pipeline\n- Header extraction: 1-2 cycles\n- MAC lookup: 1-2 cycles\n- Forwarding decision: 1 cycle\n- Total latency: ~4-6 cycles minimum\n\nThroughput Requirements:\n1. AXI4-Stream Interface\n- Must handle full line rate on all ports\n- With 128-bit tdata:\n  * Can transfer 16 bytes per clock\n  * At 125MHz = 2Gbps per port\n\n2. Concurrent Operations\n- Multiple ports can receive/transmit simultaneously\n- No blocking between independent paths\n\nTiming Constraints:\n1. AXI4-Stream Protocol\n- tvalid to tready setup time\n- tlast alignment with data\n- tkeep alignment with last byte\n\n2. Critical Paths\n- MAC table lookup (parallel comparisons)\n- Forwarding decision logic\n- Output port selection\n\nSignals Requiring Reset:\n1. Control Logic\n```systemverilog\n// Synchronous reset\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        current_state <= IDLE;\n        mac_table <= '{default: '0};  // Clear MAC table\n        forward_mask <= '0;\n    end\nend\n```\n\n2. Interface Signals\n```systemverilog\n// Reset AXI4-Stream signals\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        inTready <= '{default: '1};  // As specified\n        outAxi4St <= '{default: '0};\n    end\nend\n```\n\n3. Counters and Status\n```systemverilog\n// Reset counters and status\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        age_counters <= '{default: '0};\n        egressFifoDropEvents <= '0;\n    end\nend\n```\n\nKey Timing Considerations:\n1. MAC Table Access\n- Single cycle read for forwarding\n- Single cycle write for learning\n\n2. Pipeline Stages\n- Register outputs of each stage\n- Maintain AXI4-Stream backpressure\n\n3. Performance Metrics\n- Zero blocking for independent paths\n- Minimum latency for known MAC addresses\n- Maximum throughput for all ports\n\nThe design should prioritize maintaining line rate throughput while meeting latency requirements within the synchronous reset framework.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nHere's a comprehensive test strategy and assertion plan:\n\nTest Scenarios:\n\n1. Basic Functionality\n```systemverilog\n// Single frame forwarding\n- Known MAC address routing\n- Unknown MAC address flooding\n- Broadcast/multicast handling\n- No loopback verification\n\n// MAC Learning\n- New MAC address learning\n- MAC table updates\n- Port reassignment for moved MAC\n```\n\n2. Edge Cases\n```systemverilog\n// MAC Table\n- Full table handling\n- Age-out behavior\n- Simultaneous learning/forwarding\n- MAC address collisions\n\n// Frame Sizes\n- Minimum size frames (60 bytes)\n- Maximum size frames (1504 bytes)\n- Back-to-back frames\n```\n\n3. Stress Testing\n```systemverilog\n// Multi-port Activity\n- All ports receiving simultaneously\n- All ports transmitting simultaneously\n- Mixed Rx/Tx patterns\n- Maximum throughput testing\n```\n\nAssertions:\n\n1. Protocol Compliance\n```systemverilog\n// AXI4-Stream Protocol\nproperty axi_valid_ready;\n    @(posedge clock) disable iff (reset)\n    $stable(inAxi4St[*].tvalid) |-> ##[1:$] inTready;\nendproperty\nassert property(axi_valid_ready);\n\n// Frame Integrity\nproperty frame_size_check;\n    @(posedge clock) disable iff (reset)\n    $rose(inAxi4St[*].tvalid) |-> \n    (frame_counter >= 60 && frame_counter <= 1504);\nendproperty\n```\n\n2. Functional Correctness\n```systemverilog\n// No Loopback\nproperty no_loopback;\n    @(posedge clock) disable iff (reset)\n    forward_mask[curr_rx_port] == 0;\nendproperty\nassert property(no_loopback);\n\n// MAC Learning\nproperty mac_learn_valid;\n    @(posedge clock) disable iff (reset)\n    (new_mac_learned) |-> \n    mac_table[learn_index].valid && \n    mac_table[learn_index].mac_addr == curr_src_mac;\nendproperty\n```\n\n3. Timing and Control\n```systemverilog\n// Age Counter\nproperty age_counter_valid;\n    @(posedge clock) disable iff (reset)\n    mac_table[*].valid |-> \n    mac_table[*].age_counter <= MacTableCyclesPerEpoch;\nendproperty\n\n// Reset Behavior\nproperty reset_check;\n    @(posedge clock)\n    reset |-> ##1 (mac_table == '0 && current_state == IDLE);\nendproperty\n```\n\n4. Coverage Points:\n```systemverilog\ncovergroup switch_coverage;\n    // Port Activity\n    cp_ports: coverpoint curr_rx_port {\n        bins ports[] = {[0:NumPorts-1]};\n    }\n    \n    // MAC Table Usage\n    cp_table_usage: coverpoint mac_table_usage {\n        bins empty = {0};\n        bins partial = {[1:MacTableDepth-1]};\n        bins full = {MacTableDepth};\n    }\n    \n    // Forwarding Types\n    cp_forward_type: coverpoint forward_type {\n        bins unicast = {1};\n        bins broadcast = {2};\n        bins multicast = {3};\n        bins unknown = {4};\n    }\nendgroup\n```\n\n5. Error Checking:\n```systemverilog\n// Concurrent Assertions\nassert property (\n    @(posedge clock) disable iff (reset)\n    !$stable(inAxi4St[*].tvalid) |-> \n    $stable(inAxi4St[*].tdata)\n);\n\n// Immediate Assertions\nalways_comb begin\n    assert (forward_mask != '0) else\n        $error(\"No forward port selected\");\nend\n```\n\nTest Environment Components:\n1. Frame Generator\n- Random MAC addresses\n- Various frame sizes\n- Protocol-compliant frames\n\n2. Response Checker\n- Verify correct forwarding\n- Check MAC table contents\n- Monitor aging behavior\n\n3. Scoreboard\n- Track expected vs actual forwarding\n- Verify MAC learning\n- Monitor performance metrics\n\n4. Test Sequences\n```systemverilog\ntask automatic test_mac_learning();\n    // Send frame with new MAC\n    send_frame(random_mac);\n    // Verify MAC table update\n    check_mac_table(random_mac);\n    // Verify correct forwarding\n    check_forwarding();\nendtask\n```\n\nThese test scenarios and assertions help ensure:\n- Protocol compliance\n- Functional correctness\n- Performance requirements\n- Error handling\n- Edge case coverage\n- System robustnessWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nHere's a logical breakdown of the design into functional submodules:\n\n1. MAC Table Manager\n```systemverilog\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16\n) (\n    // Manages MAC address learning and aging\n    input  logic [47:0] src_mac,\n    input  logic [1:0]  src_port,\n    output logic [1:0]  dst_port,\n    output logic        dst_found\n);\n```\nTasks:\n- MAC address storage\n- Learning new MAC addresses\n- Aging out old entries\n- MAC address lookups\n- Port mapping maintenance\n\n2. Frame Parser\n```systemverilog\nmodule frame_parser #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n) (\n    // Extracts MAC addresses from incoming frames\n    input  AxiStreamType rx_frame,\n    output logic [47:0]  dst_mac,\n    output logic [47:0]  src_mac,\n    output logic         is_broadcast,\n    output logic         is_multicast\n);\n```\nTasks:\n- Frame header extraction\n- MAC address parsing\n- Broadcast/multicast detection\n- Frame validation\n\n3. Port Controller (one per port)\n```systemverilog\nmodule port_controller #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n) (\n    // Manages individual port Rx/Tx\n    input  AxiStreamType rx_axi4st,\n    output AxiStreamType tx_axi4st,\n    input  logic        rx_ready,\n    output logic        tx_valid\n);\n```\nTasks:\n- AXI4-Stream protocol handling\n- Frame buffering\n- Flow control\n- Port status management\n\n4. Forwarding Engine\n```systemverilog\nmodule forwarding_engine #(\n    parameter int NumPorts = 4\n) (\n    // Makes forwarding decisions\n    input  logic [47:0]      dst_mac,\n    input  logic [1:0]       src_port,\n    input  logic            dst_found,\n    input  logic            is_broadcast,\n    output logic [NumPorts-1:0] forward_mask\n);\n```\nTasks:\n- Forwarding decision logic\n- Output port selection\n- Loopback prevention\n- Multicast/broadcast handling\n\n5. Switch Crossbar\n```systemverilog\nmodule switch_crossbar #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int NumPorts = 4\n) (\n    // Routes frames between ports\n    input  AxiStreamType [NumPorts-1:0] in_frames,\n    output AxiStreamType [NumPorts-1:0] out_frames,\n    input  logic [NumPorts-1:0][NumPorts-1:0] routing_matrix\n);\n```\nTasks:\n- Frame routing\n- Port interconnection\n- Concurrent transfer handling\n\n6. Control Unit\n```systemverilog\nmodule control_unit #(\n    parameter int NumPorts = 4\n) (\n    // Overall control and synchronization\n    input  logic        clock,\n    input  logic        reset,\n    output logic [2:0]  state,\n    output logic        learning_enable,\n    output logic        forwarding_enable\n);\n```\nTasks:\n- State machine management\n- Reset handling\n- Control signal generation\n- Operation synchronization\n\nTop-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n) (\n    // Main switch module\n    input  logic                    clock,\n    input  logic                    reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic        [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic        [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n```\n\nInterconnections:\n1. Data Path\n```systemverilog\n- Frame Parser \u2192 MAC Table Manager\n- MAC Table Manager \u2192 Forwarding Engine\n- Forwarding Engine \u2192 Switch Crossbar\n- Switch Crossbar \u2192 Port Controllers\n```\n\n2. Control Path\n```systemverilog\nControl Unit \u2192 All submodules:\n- State coordination\n- Enable signals\n- Reset distribution\n```\n\nThis modular approach provides:\n- Clear functional separation\n- Simplified testing\n- Easier maintenance\n- Parallel development\n- Reusable components\n- Better scalabilityWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide SystemVerilog code for each submodule and specify their interfaces. Let's start with the core submodules:\n\n1. MAC Table Manager:\n```systemverilog\nmodule mac_table_manager #(\n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n) (\n    input  logic        clock,\n    input  logic        reset,\n    // Learning interface\n    input  logic [47:0] src_mac,\n    input  logic [1:0]  src_port,\n    input  logic        learn_valid,\n    // Lookup interface\n    input  logic [47:0] dst_mac,\n    output logic [1:0]  dst_port,\n    output logic        dst_found\n);\n\n    typedef struct packed {\n        logic [47:0] mac_addr;\n        logic [1:0]  port_num;\n        logic        valid;\n        logic [31:0] age_counter;\n    } mac_entry_t;\n\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n    \n    // MAC Learning Logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            mac_table <= '{default: '0};\n        end else if (learn_valid) begin\n            // Find empty or matching entry\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (!mac_table[i].valid || mac_table[i].mac_addr == src_mac) begin\n                    mac_table[i].mac_addr <= src_mac;\n                    mac_table[i].port_num <= src_port;\n                    mac_table[i].valid <= 1'b1;\n                    mac_table[i].age_counter <= '0;\n                    break;\n                end\n            end\n        end\n    end\n\n    // MAC Lookup Logic\n    always_comb begin\n        dst_found = 1'b0;\n        dst_port = '0;\n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (mac_table[i].valid && mac_table[i].mac_addr == dst_mac) begin\n                dst_found = 1'b1;\n                dst_port = mac_table[i].port_num;\n            end\n        end\n    end\n\n    // Aging Logic\n    always_ff @(posedge clock) begin\n        if (!reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_counter >= MacTableCyclesPerEpoch)\n                        mac_table[i].valid <= 1'b0;\n                    else\n                        mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n                end\n            end\n        end\n    end\nendmodule\n```\n\n2. Frame Parser:\n```systemverilog\nmodule frame_parser #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType rx_frame,\n    output logic [47:0] dst_mac,\n    output logic [47:0] src_mac,\n    output logic        is_broadcast,\n    output logic        is_multicast,\n    output logic        frame_valid\n);\n\n    // Extract MAC addresses from first 12 bytes of frame\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            dst_mac <= '0;\n            src_mac <= '0;\n            frame_valid <= 1'b0;\n        end else if (rx_frame.tvalid) begin\n            dst_mac <= rx_frame.tdata[47:0];\n            src_mac <= rx_frame.tdata[95:48];\n            frame_valid <= 1'b1;\n        end else begin\n            frame_valid <= 1'b0;\n        end\n    end\n\n    // Detect broadcast/multicast\n    always_comb begin\n        is_broadcast = &dst_mac;  // All 1's\n        is_multicast = dst_mac[0];  // LSB set\n    end\nendmodule\n```\n\n3. Forwarding Engine:\n```systemverilog\nmodule forwarding_engine #(\n    parameter int NumPorts = 4\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [1:0]  src_port,\n    input  logic [1:0]  dst_port,\n    input  logic        dst_found,\n    input  logic        is_broadcast,\n    input  logic        is_multicast,\n    output logic [NumPorts-1:0] forward_mask\n);\n\n    always_comb begin\n        forward_mask = '0;\n        \n        if (is_broadcast || is_multicast) begin\n            // Forward to all ports except source\n            forward_mask = ~(1 << src_port);\n        end else if (dst_found) begin\n            // Forward to specific port\n            forward_mask = (1 << dst_port);\n        end else begin\n            // Unknown destination - flood\n            forward_mask = ~(1 << src_port);\n        end\n    end\nendmodule\n```\n\n4. Switch Crossbar:\n```systemverilog\nmodule switch_crossbar #(\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int NumPorts = 4\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType [NumPorts-1:0] in_frames,\n    output AxiStreamType [NumPorts-1:0] out_frames,\n    input  logic [NumPorts-1:0][NumPorts-1:0] routing_matrix\n);\n\n    // Crossbar switching logic\n    always_comb begin\n        for (int i = 0; i < NumPorts; i++) begin\n            out_frames[i] = '0;\n            for (int j = 0; j < NumPorts; j++) begin\n                if (routing_matrix[i][j]) begin\n                    out_frames[i] = in_frames[j];\n                    break;\n                end\n            end\n        end\n    end\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between MAC Table Manager and Frame Parser:\n```systemverilog\n// Source MAC learning\nlogic [47:0] src_mac;\nlogic [1:0]  src_port;\nlogic        learn_valid;\n\n// Destination MAC lookup\nlogic [47:0] dst_mac;\nlogic [1:0]  dst_port;\nlogic        dst_found;\n```\n\n2. Between Frame Parser and Forwarding Engine:\n```systemverilog\nlogic        is_broadcast;\nlogic        is_multicast;\nlogic [47:0] dst_mac;\n```\n\n3. Between Forwarding Engine and Crossbar:\n```systemverilog\nlogic [NumPorts-1:0][NumPorts-1:0] routing_matrix;\n```\n\n4. AXI4-Stream Interfaces:\n```systemverilog\ninterface axi4_stream_if;\n    logic [127:0] tdata;\n    logic [15:0]  tkeep;\n    logic         tuser;\n    logic         tlast;\n    logic         tvalid;\n    logic         tready;\nendinterface\n```\n\nThese interfaces need careful consideration for:\n- Timing closure\n- Handshaking protocols\n- Data validity\n- Flow control\n- Error handling\n\nWould you like me to continue with the remaining submodules or provide more detail on any particular aspect?\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module can assume the following: it can drive output inTready with '1, and input outTready will be tied to '1 ('1 is a vector all all 1's for all ports in NumPorts).\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_6_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/test_l2_switch_lite_6/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule custom_tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 100; // For this custom_tb.sv, drive it at 100%\n      u_drv.m_out_tvalid_pct = 100;  // Similarly, stream out at 100% (assume upstream store/forward FIFO too)\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_6_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 100; // For this tb.sv, drive it at 100%\n      u_drv.m_out_tvalid_pct = 100;  // Similarly, stream out at 100% (assume upstream store/forward FIFO too)\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n",
    "name": "test_l2_switch_lite_6"
  },
  {
    "index": 16,
    "dut": "module packet_end_detector (\n    input  logic tvalid,\n    input  logic tlast, \n    input  logic tready,\n    output logic packet_end\n);\n    assign packet_end = tvalid && tlast && tready;\nendmodule\n\nmodule tfirst_generator (\n    input  logic clock,\n    input  logic reset,\n    input  logic packet_end,\n    input  logic tvalid,\n    input  logic tready,\n    output logic tfirst\n);\n    logic tfirst_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            tfirst_reg <= 1'b1;\n        end\n        else begin\n            if (packet_end) begin\n                tfirst_reg <= 1'b1;\n            end\n            else if (tvalid && tready) begin\n                tfirst_reg <= 1'b0;\n            end\n        end\n    end\n\n    assign tfirst = tfirst_reg;\nendmodule\n\nmodule in_packet_controller (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic packet_end,\n    output logic in_packet\n);\n    logic in_packet_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_packet_reg <= 1'b0;\n        end\n        else begin\n            if (packet_end) begin\n                in_packet_reg <= 1'b0;\n            end\n            else if (tvalid) begin\n                in_packet_reg <= 1'b1;\n            end\n        end\n    end\n\n    assign in_packet = in_packet_reg;\nendmodule\n\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        tfirst,\n    output logic        in_packet\n);\n\n    logic packet_end;\n\n    packet_end_detector u_end_detect (\n        .tvalid     (inAxi4St.tvalid),\n        .tlast      (inAxi4St.tlast),\n        .tready     (inTready),\n        .packet_end (packet_end)\n    );\n\n    tfirst_generator u_tfirst_gen (\n        .clock      (clock),\n        .reset      (reset),\n        .packet_end (packet_end),\n        .tvalid     (inAxi4St.tvalid),\n        .tready     (inTready),\n        .tfirst     (tfirst)\n    );\n\n    in_packet_controller u_in_packet_ctrl (\n        .clock      (clock),\n        .reset      (reset),\n        .tvalid     (inAxi4St.tvalid),\n        .packet_end (packet_end),\n        .in_packet  (in_packet)\n    );\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that outputs two new 1-bit flags from AXI4 Stream protocol input.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module name should be: dut\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- Module parameters:\n        -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n                -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n-- Other module inputs and outputs:\n    -- Input: inAxi4St\n       -- input AxiStreamType inAxi4St\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: inTready\n       -- input logic inTready\n       -- inTready is also an input to this module (this module acts as a passive monitor on an existing AXI4 Stream protocol, where ready is\n          \"inTready\" and valid is part of the AXI4 Stream input inAxi4St.tvalid).\n    -- Output: tfirst\n       -- output logic tfirst\n       -- is a 1 on the first valid data after reset=1, or the first valid data after inAxi4St.tvalid=1 && inTready=1 && inAxi4St.tlast=1.\n    -- Output: in_packet\n       -- output logic in_packet\n       -- is a 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. It is held at 1 until packet end\n          (inAxi4St.tvalid=1 && inAxi4St.tlast=1 && inTready=1) and is 0 the cycle after this data phit before the next inAxi4St.tvalid=1.\n       -- Note that in_packet must be 1 whenever inAxi4St.tvalid=1.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level understanding of this module:\n\nMain Functionality:\n1. The module monitors an AXI4 Stream interface and generates two control flags (tfirst and in_packet) based on the stream's behavior.\n2. It tracks packet boundaries in an AXI4 Stream protocol, where a packet starts with the first valid data and ends with tvalid=1 and tlast=1.\n3. The module doesn't modify the AXI4 Stream data; it acts as a passive monitor.\n\nHigh-level block diagram:\n```\n                   +------------------------+\n                   |         dut           |\nclock ------------>|                       |\nreset ------------>|                       |\n                   |                       |\ninAxi4St -------->|                       |-----> tfirst\n[AXI4 Stream]     |                       |\n                   |                       |-----> in_packet\ninTready -------->|                       |\n                   |                       |\n                   +------------------------+\n\n```\n\nKey Features:\n1. tfirst flag: \n   - Indicates the start of a new packet\n   - Set to 1 on first valid data after reset or after previous packet end\n\n2. in_packet flag:\n   - Indicates active packet transmission\n   - Goes high with tfirst and valid data\n   - Stays high until packet end condition\n   - Must be 1 whenever tvalid is 1\n\nThe module essentially helps track packet boundaries in an AXI4 Stream interface by providing these two status signals that can be used by other logic for packet-level processing.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let's analyze the parameterization aspects:\n\nMain Parameterizable Aspects:\n\n1. AXI4 Stream Interface Type (Already specified):\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n```\nThis is the main parameter that defines the AXI4 Stream interface structure. The default value provided includes:\n- 8-bit tdata\n- 1-bit tkeep\n- 1-bit tuser\n- 1-bit tlast\n- 1-bit tvalid\n\nPotential Additional Parameters (though not required by the specification):\n\n2. Data Width:\n   - Could be parameterized if supporting different data widths\n   - Default: 8 bits (as given in the struct)\n\n3. Clock Properties:\n   - Clock edge selection (positive/negative)\n   - Default: positive edge (standard practice)\n\n4. Reset Polarity:\n   - Active high/low reset\n   - Default: active high (as per common practice)\n\nThe current specification only requires the AxiStreamType parameter, and the default values are reasonable because:\n1. 8-bit data width is common for many applications\n2. The included control signals (tkeep, tuser, tlast, tvalid) are the standard minimum set needed for AXI4-Stream operation\n3. The struct format allows for easy extension if needed\n\nNo additional parameters are strictly necessary for this implementation as the core functionality (generating tfirst and in_packet signals) works independently of data width or other potential parameters.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet's analyze the required data processing, registers, and combinational logic:\n\nRequired Registers:\n1. tfirst_reg: To store the tfirst state\n```systemverilog\nlogic tfirst_reg;    // Register for tfirst output\n```\n\n2. in_packet_reg: To store the in_packet state\n```systemverilog\nlogic in_packet_reg; // Register for in_packet output\n```\n\nLogic Processing:\n\n1. tfirst Logic:\n```systemverilog\n// tfirst is 1 in these cases:\n// - First valid data after reset\n// - First valid data after previous packet end\nwire packet_end = inAxi4St.tvalid && inAxi4St.tlast && inTready;\nwire next_tfirst = \n    (reset) ? 1'b1 :                  // Set after reset\n    (packet_end) ? 1'b1 :             // Set after packet end\n    (inAxi4St.tvalid && inTready) ? 1'b0 : // Clear after first data\n    tfirst_reg;                       // Hold value\n```\n\n2. in_packet Logic:\n```systemverilog\n// in_packet is:\n// - Set when valid data and tfirst\n// - Held high until packet end\n// - Must be 1 when tvalid is 1\nwire next_in_packet =\n    (reset) ? 1'b0 :                  // Clear on reset\n    (packet_end) ? 1'b0 :             // Clear at packet end\n    (inAxi4St.tvalid) ? 1'b1 :        // Set when valid\n    in_packet_reg;                    // Hold value\n```\n\nBlock Diagram of Internal Logic:\n```\n                          +----------------+\ninAxi4St.tvalid -------->|                |\ninAxi4St.tlast  -------->|  Combinational |-----> next_tfirst\ninTready        -------->|     Logic      |-----> next_in_packet\nreset           -------->|                |\n                          +----------------+\n                                |\n                          +----------------+\nclock          -------->|                |\nreset          -------->|   Registers    |-----> tfirst\n                          |                |-----> in_packet\n                          +----------------+\n```\n\nThe logic needs to:\n1. Track packet boundaries\n2. Generate appropriate flags\n3. Maintain proper timing relationships\n4. Handle reset conditions\n5. Ensure in_packet is 1 whenever tvalid is 1\n\nThe combination of registers and combinational logic allows the module to properly track and indicate packet boundaries while maintaining the required timing relationships.What timing and reset conditions need to be considered? What are the clock domain requirements?\n [NEW STEP]\n \nLet's analyze the timing and reset conditions:\n\nTiming Considerations:\n\n1. Clock Domain:\n- Single clock domain operation (input 'clock')\n- All logic is synchronous to this clock\n- No clock domain crossing required\n\n2. Reset Behavior:\n```systemverilog\n// Synchronous reset (as specified)\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        tfirst_reg    <= 1'b1;    // Set to 1 after reset\n        in_packet_reg <= 1'b0;    // Clear after reset\n    end\n    else begin\n        tfirst_reg    <= next_tfirst;\n        in_packet_reg <= next_in_packet;\n    end\nend\n```\n\n3. Critical Timing Requirements:\n- tfirst must be 1 on:\n  * First valid data after reset\n  * First valid data after packet end\n```systemverilog\n// Example timing sequence\n// clock    : |^|^|^|^|^|^|^|\n// reset    : |1|0|0|0|0|0|0|\n// tvalid   : |0|1|1|1|0|1|1|\n// tlast    : |0|0|0|1|0|0|0|\n// tfirst   : |1|1|0|0|1|1|0|\n// in_packet: |0|1|1|1|0|1|1|\n```\n\n4. AXI4-Stream Protocol Timing:\n- Valid handshake occurs when tvalid=1 and inTready=1\n- Data transfer only occurs during valid handshake\n- tlast indicates end of packet\n- No backpressure handling required (passive monitor)\n\n5. Edge Cases:\n```systemverilog\n// Must handle:\n- Reset during packet transmission\n- Back-to-back packets\n- Single-cycle packets (tvalid=1, tlast=1)\n- Gaps between packets (tvalid=0)\n```\n\nImportant Requirements:\n1. Synchronous Reset:\n   - All registers clear on reset\n   - tfirst must be 1 after reset\n   - in_packet must be 0 after reset\n\n2. Protocol Compliance:\n   - in_packet must be 1 whenever tvalid is 1\n   - tfirst must correctly indicate packet boundaries\n   - Proper handling of tvalid/tlast/ready handshaking\n\n3. Setup and Hold Times:\n   - All inputs must meet setup/hold requirements relative to clock\n   - Outputs must be registered for clean timing\n\nClock Domain Requirements:\n1. Single clock domain\n2. All inputs synchronized to clock\n3. All outputs registered\n4. No asynchronous inputs except clock\n5. Reset is synchronousWhat verification considerations are there? What test scenarios should be checked?\n [NEW STEP]\n \nLet's analyze the verification considerations and test scenarios:\n\nTest Scenarios:\n\n1. Reset Conditions:\n```systemverilog\n// Test reset behavior\n- Initial reset\n- Reset during packet transmission\n- Reset between packets\n- Multiple reset pulses\n```\n\n2. Basic Packet Operations:\n```systemverilog\n// Single packet transfers\n- Minimum packet (1 data beat)\n- Standard packet (multiple beats)\n- Maximum packet length\n- Back-to-back packets\n```\n\n3. Handshake Variations:\n```systemverilog\n// Test various handshake patterns\n- Continuous transfers (ready always high)\n- Ready toggling during transfer\n- Valid toggling between packets\n- Gaps between packets\n```\n\n4. Corner Cases:\n```systemverilog\n- Single-cycle packets (tvalid=tlast=1)\n- Zero-gap between packets\n- Long gaps between packets\n- Ready deasserted during packet\n- Valid deasserted during packet\n```\n\nVerification Methodology:\n\n1. Assertions:\n```systemverilog\n// Protocol checks\nassert property (@(posedge clock) \n    inAxi4St.tvalid |-> in_packet);  // in_packet must be 1 when tvalid is 1\n\nassert property (@(posedge clock)\n    tfirst |-> inAxi4St.tvalid);     // tfirst only with valid data\n\n// Sequence checks\nassert property (@(posedge clock)\n    $rose(in_packet) |-> tfirst);    // packet start requires tfirst\n```\n\n2. Coverage Points:\n```systemverilog\n// Cover important scenarios\ncovergroup packet_cg;\n    cp_tfirst: coverpoint tfirst;\n    cp_in_packet: coverpoint in_packet;\n    cp_tvalid: coverpoint inAxi4St.tvalid;\n    cp_tlast: coverpoint inAxi4St.tlast;\n    cp_ready: coverpoint inTready;\n    \n    // Cross coverage\n    cx_handshake: cross cp_tvalid, cp_ready;\n    cx_packet_end: cross cp_tvalid, cp_tlast, cp_ready;\nendgroup\n```\n\n3. Test Environment:\n- UVM/SystemVerilog testbench\n- Random stimulus generation\n- Protocol checker\n- Scoreboard for flag verification\n- Coverage collection\n\n4. Test Cases:\n\n```systemverilog\n// Functional tests\n- Basic packet transfer\n- Multiple packet transfers\n- Reset during transfer\n- Backpressure testing\n\n// Corner case tests\n- Minimum packet size\n- Maximum packet size\n- Back-to-back packets\n- Invalid protocol sequences\n\n// Stress tests\n- Continuous operation\n- Random ready/valid patterns\n- Random packet sizes\n```\n\n5. Verification Goals:\n- 100% code coverage\n- 100% functional coverage\n- All assertions passing\n- All corner cases verified\n- Protocol compliance verified\n\n6. Error Injection:\n```systemverilog\n// Test error conditions\n- Invalid protocol sequences\n- Violation of timing requirements\n- Reset during critical operations\n```\n\n7. Performance Verification:\n- Latency measurement\n- Throughput verification\n- Protocol timing compliance\n\nThis comprehensive verification approach ensures:\n1. Correct functionality\n2. Protocol compliance\n3. Robust operation\n4. Corner case handling\n5. Error-free operation\n6. Complete coverageWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet's analyze the timing, latency, throughput, and reset requirements:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\n// All logic synchronous to 'clock'\nalways_ff @(posedge clock) begin\n    // Sequential logic\nend\n```\n\n2. Reset Requirements:\n- Synchronous reset (explicitly specified)\n- Reset values:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        tfirst_reg    <= 1'b1;    // Set after reset\n        in_packet_reg <= 1'b0;    // Clear after reset\n    end\nend\n```\n\nLatency Analysis:\n1. Output Generation:\n- tfirst: 1 clock cycle latency\n- in_packet: 1 clock cycle latency\n```systemverilog\n// Timing diagram showing latency\n// clock     : |^|^|^|^|\n// tvalid    : |0|1|1|1|\n// next_tfirst: |x|1|0|0| // Combinational\n// tfirst    : |0|1|0|0| // Registered (1 cycle)\n```\n\n2. Response Requirements:\n- Must respond to input changes on next clock cycle\n- No multi-cycle paths required\n- Single-cycle response to protocol changes\n\nThroughput Characteristics:\n1. No Throughput Limitation:\n- Module is a passive monitor\n- Does not affect AXI4-Stream throughput\n- Can handle back-to-back transfers\n\n2. Continuous Operation:\n```systemverilog\n// Can handle continuous transfers\n// clock     : |^|^|^|^|^|\n// tvalid    : |1|1|1|1|1|\n// tready    : |1|1|1|1|1|\n// in_packet : |1|1|1|1|1|\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n```systemverilog\n// All inputs relative to clock\nset_input_delay -clock clock -max 1.0 inAxi4St\nset_input_delay -clock clock -max 1.0 inTready\n```\n\n2. Output Requirements:\n```systemverilog\n// Registered outputs\nset_output_delay -clock clock -max 1.0 tfirst\nset_output_delay -clock clock -max 1.0 in_packet\n```\n\nReset Strategy:\n1. Synchronous Reset (as specified):\n- All registers reset synchronously\n- No async reset paths\n```systemverilog\nmodule dut (\n    input  logic        clock,\n    input  logic        reset,    // Synchronous reset\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        tfirst,\n    output logic        in_packet\n);\n\n    // Register reset logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            tfirst_reg    <= 1'b1;\n            in_packet_reg <= 1'b0;\n        end\n        else begin\n            tfirst_reg    <= next_tfirst;\n            in_packet_reg <= next_in_packet;\n        end\n    end\n```\n\nSignals Requiring Reset:\n1. Must Reset:\n- tfirst_reg (to 1)\n- in_packet_reg (to 0)\n\n2. Combinational Logic:\n- No reset required\n- Derived from registered signals\n\nCritical Timing Paths:\n1. Input to Register:\n```systemverilog\ninAxi4St.tvalid/tlast/tready -> next_tfirst/next_in_packet\n```\n\n2. Register to Output:\n```systemverilog\ntfirst_reg -> tfirst\nin_packet_reg -> in_packet\n```\n\nThese requirements ensure:\n1. Proper protocol monitoring\n2. Clean timing behavior\n3. Predictable reset response\n4. No throughput bottlenecks\n5. Reliable operation\n6. Correct protocol trackingWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet's detail the test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n\n1. Basic Protocol Tests:\n```systemverilog\n// Single packet transfers\ntask test_single_packet;\n    // Send packet with multiple beats\n    drive_packet(\n        .length(4),\n        .continuous_ready(1'b1)\n    );\n    // Check flags\n    check_flags();\nendtask\n```\n\n2. Reset Tests:\n```systemverilog\ntask test_reset_scenarios;\n    // Reset during packet\n    @(posedge clock);\n    drive_packet_start();\n    @(posedge clock);\n    reset <= 1'b1;\n    @(posedge clock);\n    reset <= 1'b0;\n    // Verify tfirst=1, in_packet=0\n    \n    // Reset between packets\n    complete_packet();\n    @(posedge clock);\n    reset <= 1'b1;\nendtask\n```\n\n3. Corner Cases:\n```systemverilog\ntask test_corner_cases;\n    // Single-beat packet\n    drive_packet(.length(1));\n    \n    // Back-to-back packets\n    drive_packet(.length(2));\n    drive_packet(.length(2));\n    \n    // Gaps between packets\n    drive_packet(.length(2));\n    repeat(3) @(posedge clock);\n    drive_packet(.length(2));\nendtask\n```\n\nAssertions:\n\n1. Protocol Compliance:\n```systemverilog\n// Basic Protocol Checks\nproperty valid_in_packet;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid |-> in_packet;\nendproperty\nassert property (valid_in_packet) else\n    $error(\"in_packet must be 1 when tvalid is 1\");\n\n// tfirst Behavior\nproperty tfirst_valid;\n    @(posedge clock) disable iff (reset)\n    tfirst |-> inAxi4St.tvalid;\nendproperty\nassert property (tfirst_valid);\n```\n\n2. Packet Boundary Checks:\n```systemverilog\n// Packet Start\nproperty packet_start;\n    @(posedge clock) disable iff (reset)\n    $rose(in_packet) |-> tfirst;\nendproperty\nassert property (packet_start);\n\n// Packet End\nproperty packet_end;\n    @(posedge clock) disable iff (reset)\n    (inAxi4St.tvalid && inAxi4St.tlast && inTready) |-> \n        ##1 (!in_packet || reset);\nendproperty\nassert property (packet_end);\n```\n\n3. Reset Behavior:\n```systemverilog\n// Reset Values\nproperty reset_values;\n    @(posedge clock)\n    reset |-> ##1 (tfirst && !in_packet);\nendproperty\nassert property (reset_values);\n```\n\n4. Temporal Checks:\n```systemverilog\n// tfirst Duration\nproperty tfirst_single_cycle;\n    @(posedge clock) disable iff (reset)\n    tfirst && inAxi4St.tvalid && inTready |-> ##1 !tfirst;\nendproperty\nassert property (tfirst_single_cycle);\n\n// No Gaps in Packet\nproperty no_packet_gaps;\n    @(posedge clock) disable iff (reset)\n    in_packet && !inAxi4St.tvalid |-> ##1 in_packet;\nendproperty\nassert property (no_packet_gaps);\n```\n\nCoverage Groups:\n\n```systemverilog\ncovergroup protocol_cg @(posedge clock);\n    packet_flags: coverpoint {tfirst, in_packet, \n                             inAxi4St.tvalid, inAxi4St.tlast};\n    \n    handshake: cross inAxi4St.tvalid, inTready {\n        bins valid_transfers[] = binsof(inAxi4St.tvalid) &&\n                                binsof(inTready);\n    }\n    \n    packet_sizes: coverpoint packet_size {\n        bins small  = {[1:4]};\n        bins medium = {[5:16]};\n        bins large  = {[17:32]};\n    }\nendgroup\n```\n\nTest Environment:\n\n```systemverilog\nclass test_env;\n    // Random stimulus\n    task random_packets;\n        repeat(100) begin\n            int len = $urandom_range(1, 32);\n            drive_packet(.length(len));\n        end\n    endtask\n    \n    // Directed tests\n    task directed_tests;\n        test_single_packet();\n        test_reset_scenarios();\n        test_corner_cases();\n    endtask\n    \n    // Checker\n    task check_flags;\n        // Verify flag behavior\n        check_tfirst_timing();\n        check_in_packet_behavior();\n    endtask\nendclass\n```\n\nThis verification approach:\n1. Covers all functional requirements\n2. Verifies protocol compliance\n3. Checks corner cases\n4. Ensures reset behavior\n5. Monitors timing relationships\n6. Provides coverage metrics\n7. Catches potential issues earlyWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nFor this design, while it's relatively compact, we can logically divide it into functional blocks. Here's the breakdown:\n\n1. Packet End Detector:\n```systemverilog\nmodule packet_end_detector (\n    input  logic tvalid,\n    input  logic tlast,\n    input  logic tready,\n    output logic packet_end\n);\n    assign packet_end = tvalid && tlast && tready;\nendmodule\n```\nTask: Detects the end of a packet based on protocol signals\n\n2. TFirst Generator:\n```systemverilog\nmodule tfirst_generator (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        packet_end,\n    input  logic        tvalid,\n    input  logic        tready,\n    output logic        tfirst\n);\n    // Generate tfirst flag\n    logic tfirst_reg;\n    \n    always_ff @(posedge clock) begin\n        if (reset)\n            tfirst_reg <= 1'b1;\n        else if (packet_end)\n            tfirst_reg <= 1'b1;\n        else if (tvalid && tready)\n            tfirst_reg <= 1'b0;\n    end\n    \n    assign tfirst = tfirst_reg;\nendmodule\n```\nTask: Manages the tfirst flag generation and timing\n\n3. In-Packet Controller:\n```systemverilog\nmodule in_packet_controller (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        tvalid,\n    input  logic        packet_end,\n    output logic        in_packet\n);\n    // Generate in_packet flag\n    logic in_packet_reg;\n    \n    always_ff @(posedge clock) begin\n        if (reset)\n            in_packet_reg <= 1'b0;\n        else if (packet_end)\n            in_packet_reg <= 1'b0;\n        else if (tvalid)\n            in_packet_reg <= 1'b1;\n    end\n    \n    assign in_packet = in_packet_reg;\nendmodule\n```\nTask: Manages the in_packet flag state\n\n4. Top-level Integration (dut):\n```systemverilog\nmodule dut (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        tfirst,\n    output logic        in_packet\n);\n    // Internal signals\n    logic packet_end;\n    \n    // Instantiate submodules\n    packet_end_detector u_end_detect (\n        .tvalid     (inAxi4St.tvalid),\n        .tlast      (inAxi4St.tlast),\n        .tready     (inTready),\n        .packet_end (packet_end)\n    );\n    \n    tfirst_generator u_tfirst_gen (\n        .clock      (clock),\n        .reset      (reset),\n        .packet_end (packet_end),\n        .tvalid     (inAxi4St.tvalid),\n        .tready     (inTready),\n        .tfirst     (tfirst)\n    );\n    \n    in_packet_controller u_in_packet_ctrl (\n        .clock      (clock),\n        .reset      (reset),\n        .tvalid     (inAxi4St.tvalid),\n        .packet_end (packet_end),\n        .in_packet  (in_packet)\n    );\n    \nendmodule\n```\nTask: Integrates all submodules and provides the main interface\n\nBenefits of this modular approach:\n1. Easier to test individual components\n2. Better code organization\n3. Simplified debugging\n4. Reusable components\n5. Clearer functionality separation\n6. More maintainable code\n\nEach submodule:\n- Has a single, well-defined purpose\n- Can be verified independently\n- Has clear interfaces\n- Is self-contained\n- Follows single-responsibility principle\n\nThis modular structure makes the design:\n1. More maintainable\n2. Easier to verify\n3. More reusable\n4. Better organized\n5. Easier to understandWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll provide the SystemVerilog code for each submodule and analyze their interfaces:\n\n1. Packet End Detector:\n```systemverilog\nmodule packet_end_detector (\n    input  logic tvalid,\n    input  logic tlast,\n    input  logic tready,\n    output logic packet_end\n);\n    // Detect end of packet condition\n    assign packet_end = tvalid && tlast && tready;\n\nendmodule\n```\n\n2. TFirst Generator:\n```systemverilog\nmodule tfirst_generator (\n    input  logic clock,\n    input  logic reset,\n    input  logic packet_end,\n    input  logic tvalid,\n    input  logic tready,\n    output logic tfirst\n);\n    logic tfirst_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            tfirst_reg <= 1'b1;  // Set to 1 after reset\n        end\n        else begin\n            if (packet_end) begin\n                tfirst_reg <= 1'b1;  // Set for next packet\n            end\n            else if (tvalid && tready) begin\n                tfirst_reg <= 1'b0;  // Clear after first transfer\n            end\n        end\n    end\n\n    assign tfirst = tfirst_reg;\n\nendmodule\n```\n\n3. In-Packet Controller:\n```systemverilog\nmodule in_packet_controller (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic packet_end,\n    output logic in_packet\n);\n    logic in_packet_reg;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            in_packet_reg <= 1'b0;\n        end\n        else begin\n            if (packet_end) begin\n                in_packet_reg <= 1'b0;\n            end\n            else if (tvalid) begin\n                in_packet_reg <= 1'b1;\n            end\n        end\n    end\n\n    assign in_packet = in_packet_reg;\n\nendmodule\n```\n\n4. Top-level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        tfirst,\n    output logic        in_packet\n);\n\n    // Internal signals\n    logic packet_end;\n\n    // Instantiate packet end detector\n    packet_end_detector u_end_detect (\n        .tvalid     (inAxi4St.tvalid),\n        .tlast      (inAxi4St.tlast),\n        .tready     (inTready),\n        .packet_end (packet_end)\n    );\n\n    // Instantiate tfirst generator\n    tfirst_generator u_tfirst_gen (\n        .clock      (clock),\n        .reset      (reset),\n        .packet_end (packet_end),\n        .tvalid     (inAxi4St.tvalid),\n        .tready     (inTready),\n        .tfirst     (tfirst)\n    );\n\n    // Instantiate in_packet controller\n    in_packet_controller u_in_packet_ctrl (\n        .clock      (clock),\n        .reset      (reset),\n        .tvalid     (inAxi4St.tvalid),\n        .packet_end (packet_end),\n        .in_packet  (in_packet)\n    );\n\nendmodule\n```\n\nCritical Interfaces Between Submodules:\n\n1. Packet End Detector to Other Modules:\n```systemverilog\n// Critical signal: packet_end\n// Used by both tfirst_generator and in_packet_controller\n// Timing requirement: Combinational output\n```\n\n2. TFirst Generator Interface:\n```systemverilog\n// Inputs from AXI4-Stream: tvalid, tready\n// Input from packet_end_detector: packet_end\n// Output: tfirst (used by downstream logic)\n// Timing: Registered output\n```\n\n3. In-Packet Controller Interface:\n```systemverilog\n// Inputs from AXI4-Stream: tvalid\n// Input from packet_end_detector: packet_end\n// Output: in_packet (used by downstream logic)\n// Timing: Registered output\n```\n\nInterface Considerations:\n1. Synchronization:\n   - All registered outputs sync to same clock\n   - Common reset signal\n\n2. Timing Dependencies:\n```systemverilog\n// packet_end -> tfirst_generator\n// packet_end -> in_packet_controller\n// All outputs registered for clean timing\n```\n\n3. Critical Paths:\n```systemverilog\n// packet_end detection -> next state calculation\n// tvalid -> in_packet state update\n```\n\n4. Signal Dependencies:\n```systemverilog\n// All modules depend on AXI4-Stream signals\n// All sequential logic depends on clock/reset\n```\n\nThis modular design ensures:\n1. Clear signal flow\n2. Well-defined interfaces\n3. Synchronized operation\n4. Clean timing boundaries\n5. Easy maintenance and debugging\n6. Independent testingWrite the testbench code for verifying the functionality of each submodule and the complete module.\n [NEW STEP]\n \nI'll provide a comprehensive testbench structure for both individual submodules and the complete design:\n\n1. First, let's create a base test package:\n\n```systemverilog\npackage test_pkg;\n    // Define test transaction class\n    class axi_transaction;\n        rand bit [7:0] tdata;\n        rand bit       tkeep;\n        rand bit       tuser;\n        rand bit       tlast;\n        bit           tvalid;\n        \n        // Constraints\n        constraint valid_c {\n            tkeep == 1'b1;\n        }\n    endclass\n\n    // Define scoreboard class\n    class scoreboard;\n        virtual function void check_tfirst(logic tfirst, logic expected);\n            assert(tfirst == expected) else\n                $error(\"tfirst mismatch: got %b, expected %b\", tfirst, expected);\n        endfunction\n\n        virtual function void check_in_packet(logic in_packet, logic expected);\n            assert(in_packet == expected) else\n                $error(\"in_packet mismatch: got %b, expected %b\", in_packet, expected);\n        endfunction\n    endclass\nendpackage\n```\n\n2. Testbench for Packet End Detector:\n\n```systemverilog\nmodule packet_end_detector_tb;\n    logic tvalid, tlast, tready, packet_end;\n    \n    // DUT instantiation\n    packet_end_detector dut (.*);\n    \n    // Test stimulus\n    initial begin\n        // Test case 1: No packet end\n        tvalid = 1'b1;\n        tlast = 1'b0;\n        tready = 1'b1;\n        #10;\n        assert(packet_end == 1'b0) else $error(\"Test 1 failed\");\n        \n        // Test case 2: Packet end\n        tvalid = 1'b1;\n        tlast = 1'b1;\n        tready = 1'b1;\n        #10;\n        assert(packet_end == 1'b1) else $error(\"Test 2 failed\");\n        \n        $display(\"Packet End Detector tests completed\");\n        $finish;\n    end\nendmodule\n```\n\n3. Testbench for TFirst Generator:\n\n```systemverilog\nmodule tfirst_generator_tb;\n    logic clock, reset;\n    logic packet_end, tvalid, tready, tfirst;\n    \n    // DUT instantiation\n    tfirst_generator dut (.*);\n    \n    // Clock generation\n    always #5 clock = ~clock;\n    \n    // Test stimulus\n    initial begin\n        // Initialize\n        clock = 0;\n        reset = 1;\n        packet_end = 0;\n        tvalid = 0;\n        tready = 0;\n        \n        // Reset test\n        @(posedge clock);\n        reset = 0;\n        assert(tfirst == 1'b1) else $error(\"Reset test failed\");\n        \n        // Normal operation test\n        @(posedge clock);\n        tvalid = 1;\n        tready = 1;\n        @(posedge clock);\n        assert(tfirst == 1'b0) else $error(\"Clear tfirst test failed\");\n        \n        $display(\"TFirst Generator tests completed\");\n        $finish;\n    end\nendmodule\n```\n\n4. Testbench for In-Packet Controller:\n\n```systemverilog\nmodule in_packet_controller_tb;\n    logic clock, reset;\n    logic tvalid, packet_end, in_packet;\n    \n    // DUT instantiation\n    in_packet_controller dut (.*);\n    \n    // Clock generation\n    always #5 clock = ~clock;\n    \n    // Test stimulus\n    initial begin\n        // Initialize\n        clock = 0;\n        reset = 1;\n        tvalid = 0;\n        packet_end = 0;\n        \n        // Reset test\n        @(posedge clock);\n        reset = 0;\n        assert(in_packet == 1'b0) else $error(\"Reset test failed\");\n        \n        // Packet start test\n        @(posedge clock);\n        tvalid = 1;\n        @(posedge clock);\n        assert(in_packet == 1'b1) else $error(\"Packet start test failed\");\n        \n        $display(\"In-Packet Controller tests completed\");\n        $finish;\n    end\nendmodule\n```\n\n5. Complete Module Testbench:\n\n```systemverilog\nmodule dut_tb;\n    import test_pkg::*;\n    \n    logic clock, reset;\n    local_pkg::axi4st_8_s inAxi4St;\n    logic inTready;\n    logic tfirst;\n    logic in_packet;\n    \n    // DUT instantiation\n    dut dut (.*);\n    \n    // Test components\n    scoreboard sb;\n    axi_transaction tx;\n    \n    // Clock generation\n    always #5 clock = ~clock;\n    \n    // Main test process\n    initial begin\n        // Initialize\n        clock = 0;\n        reset = 1;\n        inTready = 1;\n        sb = new();\n        tx = new();\n        \n        // Reset test\n        @(posedge clock);\n        reset = 0;\n        sb.check_tfirst(tfirst, 1'b1);\n        sb.check_in_packet(in_packet, 1'b0);\n        \n        // Single packet test\n        send_packet(4);\n        \n        // Back-to-back packets test\n        send_packet(2);\n        send_packet(2);\n        \n        $display(\"All tests completed successfully\");\n        $finish;\n    end\n    \n    // Task to send a packet\n    task automatic send_packet(int length);\n        for (int i = 0; i < length; i++) begin\n            void'(tx.randomize());\n            inAxi4St.tdata  = tx.tdata;\n            inAxi4St.tkeep  = tx.tkeep;\n            inAxi4St.tuser  = tx.tuser;\n            inAxi4St.tlast  = (i == length-1);\n            inAxi4St.tvalid = 1'b1;\n            \n            @(posedge clock);\n            if (i == 0) begin\n                sb.check_tfirst(tfirst, 1'b1);\n            end\n            sb.check_in_packet(in_packet, 1'b1);\n        end\n        \n        // End packet\n        inAxi4St.tvalid = 1'b0;\n        @(posedge clock);\n        sb.check_in_packet(in_packet, 1'b0);\n    endtask\n    \n    // Coverage\n    covergroup protocol_cg @(posedge clock);\n        cp_tfirst: coverpoint tfirst;\n        cp_in_packet: coverpoint in_packet;\n        cp_tvalid: coverpoint inAxi4St.tvalid;\n        cp_tlast: coverpoint inAxi4St.tlast;\n        \n        cross_valid_last: cross cp_tvalid, cp_tlast;\n    endgroup\n    \n    protocol_cg cg = new();\n    \n    // Assertions\n    property valid_in_packet_p;\n        @(posedge clock) disable iff (reset)\n        inAxi4St.tvalid |-> in_packet;\n    endproperty\n    \n    assert property (valid_in_packet_p);\n    \nendmodule\n```\n\nThis testbench structure provides:\n1. Individual submodule testing\n2. Complete system testing\n3. Transaction-based stimulus\n4. Scoreboard checking\n5. Coverage collection\n6. Protocol assertions\n7. Reusable components\n8. Comprehensive verification\n\nEach level of testing ensures:\n- Correct submodule functionality\n- Proper integration\n- Protocol compliance\n- Complete feature coverage\n- Error detection\n- Performance verification\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that outputs two new 1-bit flags from AXI4 Stream protocol input.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module name should be: dut\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- Module parameters:\n        -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n                -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n-- Other module inputs and outputs:\n    -- Input: inAxi4St\n       -- input AxiStreamType inAxi4St\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: inTready\n       -- input logic inTready\n       -- inTready is also an input to this module (this module acts as a passive monitor on an existing AXI4 Stream protocol, where ready is\n          \"inTready\" and valid is part of the AXI4 Stream input inAxi4St.tvalid).\n    -- Output: tfirst\n       -- output logic tfirst\n       -- is a 1 on the first valid data after reset=1, or the first valid data after inAxi4St.tvalid=1 && inTready=1 && inAxi4St.tlast=1.\n    -- Output: in_packet\n       -- output logic in_packet\n       -- is a 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. It is held at 1 until packet end\n          (inAxi4St.tvalid=1 && inAxi4St.tlast=1 && inTready=1) and is 0 the cycle after this data phit before the next inAxi4St.tvalid=1.\n       -- Note that in_packet must be 1 whenever inAxi4St.tvalid=1.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_tfirst_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_tfirst.sv), and confirm DUT outputs\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n\n  logic                   tfirst;\n  logic                   in_packet;\n\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(inAxi4St),\n     .inError(),\n     .inTready(inTready), // <-- we drive the signal inTready\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_tfirst\n    #(\n      .AxiStreamType(AxiStreamType)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n\n     .tfirst,\n     .in_packet\n     );\n\n\n  // Simple confirm DUT behavior.\n  logic                   tb_in_packet;\n  logic                   next_phit_should_be_tfirst, tb_in_packet_held;\n  always @(posedge clock) begin\n    if (reset) begin\n      next_phit_should_be_tfirst <= 1'b1;\n      tb_in_packet_held          <= '0;\n    end else begin\n      if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n          next_phit_should_be_tfirst <= 1'b1;\n          tb_in_packet_held          <= '0;\n        end else begin\n          next_phit_should_be_tfirst <= 1'b0;\n          tb_in_packet_held          <= '1;\n        end\n      end\n    end\n  end\n\n  assign tb_in_packet = tb_in_packet_held || (inAxi4St.tvalid && next_phit_should_be_tfirst);\n\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || (tfirst === next_phit_should_be_tfirst), (\"tvalid=1 means tfirst must be expected\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, tb_in_packet === in_packet, (\"DUT and TB don't agree with 'in_packet'\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || in_packet, (\"tvalid=1 implies we should be in-packet\"));\n\n  // count tfirsts, should match total packets.\n  int tb_stats__tfirst = 0;\n  int tb_stats__in_packet_at_tlast = 0;\n  int tb_stats__in_packet_starts = 0;\n\n  // count new in_packet events\n  always @(posedge clock) begin\n    if (inAxi4St.tvalid && inTready) begin\n\n      if (tfirst)\n        tb_stats__tfirst++;\n\n      if (inAxi4St.tlast && in_packet)\n        tb_stats__in_packet_at_tlast++;\n\n      if (next_phit_should_be_tfirst)\n        tb_stats__in_packet_starts++;\n\n    end\n  end\n\n\n\n\n  import ocsim_packet_pkg::packet_t;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // disable monitoring the packets:\n    u_mon.m_monitor_queue_enable = 0;\n    u_drv.m_out_tvalid_pct = 65;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    while (u_mon.busy()) repeat(100) @(posedge clock);\n\n    `OC_ASSERT(tb_in_packet === 0);\n\n    `OC_ASSERT(tb_stats__tfirst == 100);\n    `OC_ASSERT(tb_stats__in_packet_at_tlast == 100);\n    `OC_ASSERT(tb_stats__in_packet_starts == 100);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_tfirst_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_tfirst_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_tfirst_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_tfirst.sv), and confirm DUT outputs\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n\n  logic                   tfirst;\n  logic                   in_packet;\n\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(inAxi4St),\n     .inError(),\n     .inTready(inTready), // <-- we drive the signal inTready\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n\n     .tfirst,\n     .in_packet\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // Simple confirm DUT behavior.\n  logic                   tb_in_packet;\n  logic                   next_phit_should_be_tfirst, tb_in_packet_held;\n  always @(posedge clock) begin\n    if (reset) begin\n      next_phit_should_be_tfirst <= 1'b1;\n      tb_in_packet_held          <= '0;\n    end else begin\n      if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n          next_phit_should_be_tfirst <= 1'b1;\n          tb_in_packet_held          <= '0;\n        end else begin\n          next_phit_should_be_tfirst <= 1'b0;\n          tb_in_packet_held          <= '1;\n        end\n      end\n    end\n  end\n\n  assign tb_in_packet = tb_in_packet_held || (inAxi4St.tvalid && next_phit_should_be_tfirst);\n\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || (tfirst === next_phit_should_be_tfirst), (\"tvalid=1 means tfirst must be expected\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, tb_in_packet === in_packet, (\"DUT and TB don't agree with 'in_packet'\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || in_packet, (\"tvalid=1 implies we should be in-packet\"));\n\n  // count tfirsts, should match total packets.\n  int tb_stats__tfirst = 0;\n  int tb_stats__in_packet_at_tlast = 0;\n  int tb_stats__in_packet_starts = 0;\n\n  // count new in_packet events\n  always @(posedge clock) begin\n    if (inAxi4St.tvalid && inTready) begin\n\n      if (tfirst)\n        tb_stats__tfirst++;\n\n      if (inAxi4St.tlast && in_packet)\n        tb_stats__in_packet_at_tlast++;\n\n      if (next_phit_should_be_tfirst)\n        tb_stats__in_packet_starts++;\n\n    end\n  end\n\n\n\n\n  import ocsim_packet_pkg::packet_t;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // disable monitoring the packets:\n    u_mon.m_monitor_queue_enable = 0;\n    u_drv.m_out_tvalid_pct = 65;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    while (u_mon.busy()) repeat(100) @(posedge clock);\n\n    `OC_ASSERT(tb_in_packet === 0);\n\n    `OC_ASSERT(tb_stats__tfirst == 100);\n    `OC_ASSERT(tb_stats__in_packet_at_tlast == 100);\n    `OC_ASSERT(tb_stats__in_packet_starts == 100);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_tfirst_2"
  },
  {
    "index": 17,
    "dut": "module dut #(\n    parameter int Depth = 8,\n    parameter type AxiStreamType = logic,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1,\n    parameter int unsigned AlmostFull = (Depth - 8),\n    parameter int unsigned AlmostEmpty = 0,\n    parameter bit PreferSrl = 0,\n    parameter int unsigned CountWidth = $clog2(Depth + 1)\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic inError,\n    input  logic outTready,\n    output AxiStreamType outAxi4St,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic outError,\n    output logic inTready,\n    output logic [CountWidth-1:0] inCount,\n    output logic [CountWidth-1:0] outCount,\n    output logic almostFull,\n    output logic almostEmpty\n);\n\n    // Parameter validation\n    initial begin\n        assert(Depth == 0 || (Depth > 1 && (Depth & (Depth-1)) == 0)) \n            else $error(\"FIFO Depth must be 0 or power of 2 greater than 1\");\n    end\n\n    // Bypass mode when Depth = 0\n    generate\n        if (Depth == 0) begin : bypass_gen\n            always_comb begin\n                outAxi4St = inAxi4St;\n                outExtra = inExtra;\n                outError = inError;\n                inTready = outTready;\n                inCount = '0;\n                outCount = '0;\n                almostFull = 1'b0;\n                almostEmpty = 1'b1;\n            end\n        end else begin : fifo_gen\n            // Internal signals\n            logic write_enable, read_enable;\n            logic [$clog2(Depth)-1:0] write_ptr, read_ptr;\n            logic fifo_full, fifo_empty;\n            \n            // Storage arrays\n            AxiStreamType [Depth-1:0] data_array;\n            logic [ExtraDataWidth-1:0] [Depth-1:0] extra_array;\n            logic [Depth-1:0] error_array;\n\n            // Write pointer logic\n            always_ff @(posedge clock) begin\n                if (reset) begin\n                    write_ptr <= '0;\n                end else if (write_enable) begin\n                    write_ptr <= (write_ptr == Depth-1) ? '0 : write_ptr + 1'b1;\n                end\n            end\n\n            // Read pointer logic\n            always_ff @(posedge clock) begin\n                if (reset) begin\n                    read_ptr <= '0;\n                end else if (read_enable) begin\n                    read_ptr <= (read_ptr == Depth-1) ? '0 : read_ptr + 1'b1;\n                end\n            end\n\n            // Counter logic\n            always_ff @(posedge clock) begin\n                if (reset) begin\n                    inCount <= '0;\n                    outCount <= '0;\n                end else begin\n                    case ({write_enable, read_enable})\n                        2'b10: begin\n                            inCount <= inCount + 1'b1;\n                            outCount <= outCount + 1'b1;\n                        end\n                        2'b01: begin\n                            inCount <= inCount - 1'b1;\n                            outCount <= outCount - 1'b1;\n                        end\n                        default: begin\n                            inCount <= inCount;\n                            outCount <= outCount;\n                        end\n                    endcase\n                end\n            end\n\n            // Storage write\n            always_ff @(posedge clock) begin\n                if (write_enable) begin\n                    data_array[write_ptr] <= inAxi4St;\n                    extra_array[write_ptr] <= inExtra;\n                    error_array[write_ptr] <= inError;\n                end\n            end\n\n            // Output registration\n            always_ff @(posedge clock) begin\n                if (reset) begin\n                    outAxi4St.tvalid <= 1'b0;\n                end else if (read_enable) begin\n                    outAxi4St <= data_array[read_ptr];\n                    outExtra <= extra_array[read_ptr];\n                    outError <= error_array[read_ptr];\n                end\n            end\n\n            // Control signals\n            assign fifo_full = (inCount == Depth);\n            assign fifo_empty = (outCount == 0);\n            assign write_enable = inAxi4St.tvalid && !fifo_full;\n            assign read_enable = !fifo_empty && outTready;\n            assign inTready = !fifo_full;\n            assign almostFull = (inCount >= AlmostFull);\n            assign almostEmpty = (outCount <= AlmostEmpty);\n        end\n    endgenerate\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that acts as a simple ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 8\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 0, or a power-of-2.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned AlmostFull = (Depth - 8)\n        -- Number of entries (less than or equal to Depth), that if this many entries or more are occupied in the FIFO, module output almostFull is set to 1.\n     -- parameter int unsigned AlmostEmpty = 0\n        -- Number of entries: that if fewer than this many entries are occupied in the FIFO, module output almostEmpty is set to 1.\n     -- parameter bit          PreferSrl = 0\n        -- Style of the underlying FIFO. This can be left at value 0 and not used internally, but must exist in the parameter list.\n     --  parameter int unsigned CountWidth     = $clog2(Depth + 1)\n        -- Width in bits for module outputs inCount and outCount.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n       -- All fields of inAxi4St, except tvalid, must be stored in the FIFO if DEPTH > 0.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: inCount\n       -- output logic [CountWidth - 1 : 0] inCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if inCount==Depth, then inTready should be 0, because the FIFO is full.\n    -- Output: outCount\n       -- output logic [CountWidth - 1 : 0] outCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if outCount==0, then outAxi4St.tvalid should be 0, because the FIFO is empty\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: almostFull\n       -- output logic almostFull\n       -- is 1 when inCount >= AlmostFull\n    -- Output: almostEmpty\n       -- output logic almostEmpty\n       -- is 1 when outCount <= AlmostEmpty\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\nThis module implements a FIFO (First-In-First-Out) buffer specifically designed for AXI4-Stream protocol with additional features. The key functions are:\n\n1. Buffering AXI4-Stream data:\n   - Stores incoming AXI4-Stream packets (tdata, tkeep, tuser, tlast) when valid\n   - Maintains ready/valid handshaking protocol\n   - Supports configurable depth (must be power of 2 or 0)\n   - Bypass mode when Depth=0\n\n2. Additional Data Storage:\n   - Stores extra data (inExtra) and error flags (inError) alongside the main data\n   - These are forwarded with the corresponding AXI4-Stream data\n\n3. Status Monitoring:\n   - Tracks FIFO occupancy (inCount, outCount)\n   - Provides almost full/empty flags\n   - Implements backpressure through ready signals\n\nHigh-Level Block Diagram:\n```\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502              FIFO Module               \u2502\n inAxi4St \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                                        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outAxi4St\n inExtra  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outExtra\n inError  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502     \u2502  Storage Array   \u2502              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outError\n                    \u2502     \u2502  (When Depth>0)   \u2502              \u2502\n outTready \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba inTready\n                    \u2502                                        \u2502\n                    \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n clock    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502     \u2502 Control Logic &  \u2502              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba almostFull\n reset    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502     \u2502 Status Tracking  \u2502              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba almostEmpty\n                    \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba inCount\n                    \u2502                                        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba outCount\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nWhen Depth=0, the storage array is bypassed, and inputs are directly connected to outputs with appropriate handshaking logic maintained.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nFrom the problem description, here are the key parameterizable aspects and their reasonable default values:\n\n1. FIFO Depth (Depth)\n- Default value: 8\n- Must be either 0 (bypass mode) or a power of 2\n- Reasonable range: 0, 2, 4, 8, 16, 32, etc.\n- Depth=1 is explicitly not supported\n\n2. AXI Stream Data Type (AxiStreamType)\n- Default: local_pkg::axi4st_8_s\n- Contains:\n  ```systemverilog\n  typedef struct packed {\n    logic [7:0] tdata;\n    logic       tkeep;\n    logic       tuser;\n    logic       tlast;\n    logic       tvalid;\n  } axi4st_8_s;\n  ```\n\n3. AXI Stream Width (AxiStreamWidth)\n- Default: 8\n- Should match tdata width in AxiStreamType\n- Common values: 8, 16, 32, 64, 128, 256\n\n4. Extra Data Width (ExtraDataWidth)\n- Default: 1\n- For additional side-channel data\n- Reasonable range: 1-32 bits\n\n5. Almost Full Threshold (AlmostFull)\n- Default: Depth - 8\n- Must be \u2264 Depth\n- Used for early warning of FIFO filling\n\n6. Almost Empty Threshold (AlmostEmpty)\n- Default: 0\n- Must be \u2264 Depth\n- Used for early warning of FIFO emptying\n\n7. Implementation Style (PreferSrl)\n- Default: 0\n- Binary parameter for FIFO implementation style\n\n8. Count Width (CountWidth)\n- Default: $clog2(Depth + 1)\n- Automatically calculated based on Depth\n- Used for count signals\n\nThese parameters allow the module to be:\n1. Sized appropriately for different applications\n2. Configured for different data widths\n3. Optimized for different use cases (bypass vs. buffering)\n4. Monitored with appropriate thresholds\n5. Implemented in different styles based on technology\n\nThe defaults represent a reasonable starting point for a small FIFO with basic functionality.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n1. When Depth = 0 (Bypass Mode):\n```systemverilog\n// Direct connection with handshaking\noutAxi4St = inAxi4St;\noutExtra  = inExtra;\noutError  = inError;\ninTready  = outTready;\n```\n\n2. When Depth > 0 (FIFO Mode):\n\nRequired Registers:\n1. Storage Elements:\n```systemverilog\n// Main storage arrays\nAxiStreamType [Depth-1:0] fifo_data;  // Stores AXI stream data\nlogic [ExtraDataWidth-1:0] [Depth-1:0] extra_data;  // Stores extra data\nlogic [Depth-1:0] error_flags;  // Stores error flags\n\n// Pointers\nlogic [$clog2(Depth)-1:0] write_ptr;  // Points to next write location\nlogic [$clog2(Depth)-1:0] read_ptr;   // Points to next read location\n\n// Counters\nlogic [CountWidth-1:0] entry_count;    // Number of valid entries\n```\n\n2. Control Registers:\n```systemverilog\nlogic full;    // FIFO full flag\nlogic empty;   // FIFO empty flag\n```\n\nCombinational Logic:\n1. Write Control:\n```systemverilog\n// Write enable when valid input and not full\nwrite_enable = inAxi4St.tvalid && inTready;\n\n// Next write pointer\nnext_write_ptr = (write_ptr + write_enable) % Depth;\n```\n\n2. Read Control:\n```systemverilog\n// Read enable when valid output and downstream ready\nread_enable = outAxi4St.tvalid && outTready;\n\n// Next read pointer\nnext_read_ptr = (read_ptr + read_enable) % Depth;\n```\n\n3. Status Logic:\n```systemverilog\n// Full/Empty conditions\nfull  = (entry_count == Depth);\nempty = (entry_count == 0);\n\n// Almost full/empty flags\nalmostFull  = (entry_count >= AlmostFull);\nalmostEmpty = (entry_count <= AlmostEmpty);\n\n// Ready/Valid generation\ninTready = !full;\noutAxi4St.tvalid = !empty;\n```\n\n4. Counter Logic:\n```systemverilog\n// Count tracking\nnext_count = entry_count + write_enable - read_enable;\n\n// Output counts\ninCount  = entry_count;\noutCount = entry_count;\n```\n\nData Path:\n```systemverilog\n// Write path\nif (write_enable) begin\n    fifo_data[write_ptr]  <= inAxi4St;\n    extra_data[write_ptr] <= inExtra;\n    error_flags[write_ptr] <= inError;\nend\n\n// Read path\noutAxi4St <= fifo_data[read_ptr];\noutExtra  <= extra_data[read_ptr];\noutError  <= error_flags[read_ptr];\n```\n\nSpecial Considerations:\n1. Synchronous Reset:\n- Clear all counters and control flags\n- Initialize pointers to 0\n- Clear valid bits in stored data\n\n2. AXI4-Stream Protocol:\n- Maintain packet integrity (tvalid/tlast relationship)\n- Proper handshaking with ready/valid signals\n\n3. Overflow/Underflow Protection:\n- Prevent writes when full\n- Prevent reads when empty\n- Maintain correct counting\n\nThis implementation ensures proper FIFO functionality while maintaining AXI4-Stream protocol compliance and providing necessary status information.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nFrom the problem description and typical FIFO requirements, let me break down these aspects:\n\nClocking Requirements:\n1. Single Clock Domain\n- All operations are synchronous to the input 'clock'\n- No clock domain crossing is required\n- Rising edge triggered operations\n\nReset Requirements:\n1. Synchronous Reset (explicitly specified)\n- Reset signal name: 'reset'\n- Active high reset\n- Synchronized to the rising edge of clock\n\nSignals to Reset:\n1. Control Signals:\n```systemverilog\n// Reset to initial values\nwrite_ptr    <= '0;\nread_ptr     <= '0;\nentry_count  <= '0;\n```\n\n2. Status Signals:\n```systemverilog\noutAxi4St.tvalid <= '0;\nalmostFull       <= '0;\nalmostEmpty      <= '1;  // True when empty\n```\n\nLatency:\n1. Bypass Mode (Depth = 0):\n- Zero latency\n- Direct combinational path from input to output\n\n2. FIFO Mode (Depth > 0):\n- Write to Read: Minimum 1 clock cycle\n- Status Updates: 1 clock cycle\n- Ready/Valid signals: Combinational\n\nThroughput:\n1. Maximum Throughput:\n- One transaction per clock cycle when:\n  * Input: inAxi4St.tvalid && inTready\n  * Output: outAxi4St.tvalid && outTready\n\n2. Handshaking:\n```systemverilog\n// Input side\ninTready = !full;  // Combinational\n\n// Output side\noutAxi4St.tvalid = !empty;  // Combinational\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n```systemverilog\n// All inputs must be stable before clock edge\ninAxi4St\ninExtra\ninError\noutTready\n```\n\n2. Critical Paths:\n- FIFO full/empty detection\n- Almost full/empty calculation\n- Ready/valid generation\n\nExample Timing Diagram:\n```\nClock      __|\u203e|__|\u203e|__|\u203e|__|\u203e|__|\u203e|__|\u203e|__\nReset      \u203e\u203e\u203e\u203e|____________________________\n           \ninValid    _____|\u203e\u203e\u203e\u203e|______|\u203e\u203e\u203e\u203e|________\ninTready   \u203e\u203e\u203e\u203e\u203e|____|\u203e\u203e\u203e\u203e\u203e\u203e|____|\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n           \noutValid   __________|\u203e\u203e\u203e\u203e|______|\u203e\u203e\u203e\u203e|___\noutTready  \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e|____|\u203e\u203e\u203e\u203e\u203e\u203e|____|\u203e\u203e\n```\n\nPerformance Considerations:\n1. Back-to-Back Transfers:\n- Support consecutive transfers when not full/empty\n- No bubbles in the pipeline\n\n2. Flow Control:\n- Immediate backpressure when full\n- Immediate data availability indication when not empty\n\n3. Reset Recovery:\n- All signals stable within 1 clock cycle after reset\n- FIFO ready for operation immediately after reset\n\nThese timing and reset requirements ensure reliable operation while maintaining AXI4-Stream protocol compliance and proper FIFO functionality.What test scenarios should be created to verify the design? What aspects are most important to test or might be likely to have bugs?\n [NEW STEP]\n \nHere are the key test scenarios and verification aspects that should be considered:\n\n1. Basic Functionality Tests:\n```systemverilog\n// Test FIFO operations\na) Write/Read single data\nb) Write multiple/Read multiple\nc) Simultaneous write/read\nd) Write burst/Read burst\n```\n\n2. Corner Cases:\n```systemverilog\n// Empty FIFO conditions\na) Read from empty FIFO\nb) Multiple reads when empty\n\n// Full FIFO conditions\nc) Write to full FIFO\nd) Multiple writes when full\n\n// Threshold conditions\ne) Almost full threshold crossing\nf) Almost empty threshold crossing\n```\n\n3. AXI4-Stream Protocol Tests:\n```systemverilog\n// Packet integrity\na) Single packet transfer (tvalid to tlast)\nb) Multiple packet transfers\nc) Back-to-back packets\nd) Packets with gaps\n\n// Handshaking\ne) Valid/Ready interactions\nf) Backpressure scenarios\n```\n\n4. Parameter Testing:\n```systemverilog\n// Different FIFO depths\na) Depth = 0 (bypass mode)\nb) Depth = power of 2 values (2,4,8,16,...)\nc) Invalid Depth values (should be caught)\n\n// Data widths\nd) Different AxiStreamWidth values\ne) Different ExtraDataWidth values\n```\n\n5. Error Handling:\n```systemverilog\n// Error propagation\na) inError with tlast\nb) Multiple errors in sequence\nc) Error with different packet sizes\n```\n\n6. Reset Behavior:\n```systemverilog\n// Reset scenarios\na) Reset during idle\nb) Reset during transfer\nc) Reset when FIFO full\nd) Reset when FIFO empty\ne) Reset in middle of packet\n```\n\n7. Counter Verification:\n```systemverilog\n// Count accuracy\na) inCount increment/decrement\nb) outCount tracking\nc) Maximum count value\nd) Zero count value\n```\n\nLikely Bug Areas (High Priority Tests):\n\n1. Pointer Management:\n```systemverilog\n// Critical edge cases\na) Write pointer wraparound\nb) Read pointer wraparound\nc) Pointer synchronization\n```\n\n2. Valid/Ready Timing:\n```systemverilog\n// Handshaking edge cases\na) Ready deassert during transfer\nb) Valid deassert during transfer\nc) Single-cycle pulses\n```\n\n3. Packet Boundary Handling:\n```systemverilog\n// Packet integrity\na) tlast alignment with data\nb) tuser/tkeep consistency\nc) Error flag alignment with tlast\n```\n\n4. Counter Edge Cases:\n```systemverilog\n// Counter accuracy\na) Simultaneous increment/decrement\nb) Maximum/minimum transitions\nc) Almost full/empty threshold accuracy\n```\n\nTest Environment Requirements:\n\n1. Self-Checking Testbench:\n```systemverilog\n// Verification components\na) AXI4-Stream driver\nb) AXI4-Stream monitor\nc) Scoreboard for data checking\nd) Coverage collection\n```\n\n2. Coverage Metrics:\n```systemverilog\n// Coverage points\na) FIFO fill levels\nb) All parameter combinations\nc) Protocol transitions\nd) Reset scenarios\n```\n\n3. Performance Measurements:\n```systemverilog\n// Timing aspects\na) Latency measurements\nb) Throughput calculations\nc) Backpressure response\n```\n\n4. Randomization:\n```systemverilog\n// Random scenarios\na) Random data patterns\nb) Random delays\nc) Random packet sizes\nd) Random backpressure\n```\n\nSpecial Considerations:\n\n1. Long-term Testing:\n- Extended runs to catch corner cases\n- Stress testing with maximum traffic\n\n2. Protocol Compliance:\n- Verify all AXI4-Stream rules\n- Check timing requirements\n\n3. Performance Verification:\n- Maximum throughput achievement\n- Latency requirements met\n\nThese test scenarios should provide good coverage and confidence in the design's functionality and robustness.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the key test scenarios and assertions needed for comprehensive verification:\n\nTest Scenarios:\n\n1. Functional Tests:\n```systemverilog\n// Basic operations\ntask test_basic_operations();\n    // Single transfers\n    test_single_write_read();\n    // Burst transfers\n    test_continuous_transfers();\n    // Alternating write/read\n    test_interleaved_operations();\nendtask\n```\n\n2. Protocol Tests:\n```systemverilog\n// AXI4-Stream specific\ntask test_protocol_compliance();\n    // Valid-Ready handshake\n    test_handshaking();\n    // Packet boundaries\n    test_packet_integrity();\n    // Backpressure handling\n    test_backpressure_scenarios();\nendtask\n```\n\n3. Corner Cases:\n```systemverilog\ntask test_corner_cases();\n    // Full/Empty conditions\n    test_full_fifo();\n    test_empty_fifo();\n    // Threshold crossing\n    test_almost_full_threshold();\n    test_almost_empty_threshold();\nendtask\n```\n\nKey Assertions:\n\n1. Protocol Assertions:\n```systemverilog\n// Valid-Ready Protocol\nproperty valid_ready_handshake;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |=> $stable(inAxi4St);\nendproperty\nassert property(valid_ready_handshake);\n\n// TLAST handling\nproperty tlast_with_valid;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tlast |-> inAxi4St.tvalid;\nendproperty\nassert property(tlast_with_valid);\n```\n\n2. FIFO Behavior Assertions:\n```systemverilog\n// Full/Empty conditions\nproperty full_behavior;\n    @(posedge clock) disable iff (reset)\n    (inCount == Depth) |-> !inTready;\nendproperty\nassert property(full_behavior);\n\nproperty empty_behavior;\n    @(posedge clock) disable iff (reset)\n    (outCount == 0) |-> !outAxi4St.tvalid;\nendproperty\nassert property(empty_behavior);\n\n// Counter consistency\nproperty counter_consistency;\n    @(posedge clock) disable iff (reset)\n    inCount == outCount;\nendproperty\nassert property(counter_consistency);\n```\n\n3. Data Integrity Assertions:\n```systemverilog\n// Data ordering\nproperty data_ordering;\n    logic [AxiStreamWidth-1:0] data_in;\n    @(posedge clock) disable iff (reset)\n    (inAxi4St.tvalid && inTready, data_in = inAxi4St.tdata) |-> \n    ##[1:$] (outAxi4St.tvalid && outTready && outAxi4St.tdata == data_in);\nendproperty\nassert property(data_ordering);\n\n// Extra data consistency\nproperty extra_data_consistency;\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && outTready) |-> \n    (outExtra inside {[0:(2**ExtraDataWidth)-1]});\nendproperty\nassert property(extra_data_consistency);\n```\n\n4. Reset Assertions:\n```systemverilog\n// Reset behavior\nproperty reset_clears_counts;\n    @(posedge clock)\n    reset |=> (inCount == 0) && (outCount == 0);\nendproperty\nassert property(reset_clears_counts);\n\nproperty reset_clears_valid;\n    @(posedge clock)\n    reset |=> !outAxi4St.tvalid;\nendproperty\nassert property(reset_clears_valid);\n```\n\n5. Threshold Assertions:\n```systemverilog\n// Almost full/empty flags\nproperty almost_full_assertion;\n    @(posedge clock) disable iff (reset)\n    (inCount >= AlmostFull) |-> almostFull;\nendproperty\nassert property(almost_full_assertion);\n\nproperty almost_empty_assertion;\n    @(posedge clock) disable iff (reset)\n    (outCount <= AlmostEmpty) |-> almostEmpty;\nendproperty\nassert property(almost_empty_assertion);\n```\n\nCoverage Points:\n\n1. Functional Coverage:\n```systemverilog\ncovergroup fifo_coverage;\n    // FIFO fill levels\n    fifo_fill: coverpoint inCount {\n        bins empty = {0};\n        bins full  = {Depth};\n        bins almost_full = {[AlmostFull:Depth-1]};\n        bins almost_empty = {[1:AlmostEmpty]};\n    }\n    \n    // Simultaneous operations\n    operations: cross (inAxi4St.tvalid, outTready);\n    \n    // Packet sizes\n    packet_size: coverpoint packet_counter {\n        bins small  = {[1:4]};\n        bins medium = {[5:16]};\n        bins large  = {[17:32]};\n    }\nendgroup\n```\n\nTest Methodology:\n1. Use a systematic approach:\n   - Start with basic functionality\n   - Add corner cases\n   - Include random scenarios\n   - Stress test with maximum loading\n\n2. Verification Environment:\n   - Use constrained random stimulus\n   - Implement comprehensive scoreboarding\n   - Monitor protocol compliance\n   - Track coverage metrics\n\n3. Performance Verification:\n   - Measure throughput\n   - Verify latency requirements\n   - Check backpressure response times\n\nThese assertions and test scenarios will help catch common issues and ensure robust operation of the FIFO.What distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. Write Control Module:\n```systemverilog\nmodule write_control #(parameter int Depth) (\n    // Manages write operations\n    input  logic clock, reset,\n    input  AxiStreamType inAxi4St,\n    output logic inTready,\n    output logic write_enable,\n    output logic [$clog2(Depth)-1:0] write_ptr\n);\n    // Tasks:\n    // - Generate write enable signals\n    // - Manage write pointer\n    // - Generate input ready signal\n    // - Check for full condition\n```\n\n2. Read Control Module:\n```systemverilog\nmodule read_control #(parameter int Depth) (\n    // Manages read operations\n    input  logic clock, reset,\n    input  logic outTready,\n    output logic read_enable,\n    output logic [$clog2(Depth)-1:0] read_ptr\n);\n    // Tasks:\n    // - Generate read enable signals\n    // - Manage read pointer\n    // - Check for empty condition\n```\n\n3. Storage Array Module:\n```systemverilog\nmodule storage_array #(\n    parameter int Depth,\n    parameter type AxiStreamType,\n    parameter int ExtraDataWidth\n) (\n    // Manages data storage\n    input  AxiStreamType inAxi4St,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic inError,\n    output AxiStreamType outAxi4St,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic outError\n);\n    // Tasks:\n    // - Store AXI4-Stream data\n    // - Store extra data\n    // - Store error flags\n    // - Manage data output selection\n```\n\n4. Counter Module:\n```systemverilog\nmodule fifo_counter #(\n    parameter int Depth,\n    parameter int CountWidth\n) (\n    // Manages occupancy tracking\n    input  logic write_enable, read_enable,\n    output logic [CountWidth-1:0] inCount, outCount,\n    output logic almostFull, almostEmpty\n);\n    // Tasks:\n    // - Track FIFO occupancy\n    // - Generate almost full/empty flags\n    // - Maintain count consistency\n```\n\n5. Bypass Logic Module:\n```systemverilog\nmodule bypass_logic #(\n    parameter type AxiStreamType,\n    parameter int ExtraDataWidth\n) (\n    // Handles Depth=0 case\n    input  AxiStreamType inAxi4St,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic inError,\n    input  logic outTready,\n    output AxiStreamType outAxi4St,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic outError,\n    output logic inTready\n);\n    // Tasks:\n    // - Direct connection when Depth=0\n    // - Maintain protocol compliance\n```\n\n6. Top-Level Control Module:\n```systemverilog\nmodule control_logic (\n    // Overall control and coordination\n    input  logic clock, reset,\n    output logic write_en, read_en,\n    output logic bypass_sel\n);\n    // Tasks:\n    // - Coordinate between submodules\n    // - Handle reset distribution\n    // - Mode selection (bypass vs. FIFO)\n```\n\nIntegration Architecture:\n```\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u250c\u2500\u2500\u2500\u25ba\u2502  Write Control  \u2502\n                     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              \u2502     \u2502    \u2502  Storage Array  \u2502\n\u2502 Top Control  \u251c\u2500\u2500\u2500\u2500\u2500\u2524    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502              \u2502     \u2502            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502    \u2502  Read Control   \u2502\n                     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502             \u2502\n                     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2514\u2500\u2500\u2500\u25ba\u2502    Counter      \u2502\n                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nAdvantages of this Modular Approach:\n\n1. Separation of Concerns:\n- Each module has a specific responsibility\n- Easier to test and verify\n- Simplified maintenance\n\n2. Reusability:\n- Modules can be used in other designs\n- Easy to modify individual components\n- Scalable for different configurations\n\n3. Verifiability:\n- Individual module testing\n- Clear interface boundaries\n- Simplified debugging\n\n4. Maintainability:\n- Localized changes\n- Clear documentation\n- Easy to understand structure\n\nThis modular approach makes the design more manageable, testable, and maintainable while keeping the complexity under control.Write a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll create SystemVerilog code for each submodule and highlight their critical interfaces. Let's start with each module:\n\n1. Write Control Module:\n```systemverilog\nmodule write_control #(\n    parameter int Depth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        fifo_full,\n    output logic        inTready,\n    output logic        write_enable,\n    output logic [$clog2(Depth)-1:0] write_ptr\n);\n    // Write pointer logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            write_ptr <= '0;\n            write_enable <= 1'b0;\n        end else begin\n            write_enable <= inAxi4St.tvalid && !fifo_full;\n            if (write_enable)\n                write_ptr <= (write_ptr == Depth-1) ? '0 : write_ptr + 1'b1;\n        end\n    end\n\n    // Ready signal generation\n    assign inTready = !fifo_full;\n\nendmodule\n```\n\n2. Read Control Module:\n```systemverilog\nmodule read_control #(\n    parameter int Depth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        outTready,\n    input  logic        fifo_empty,\n    output logic        read_enable,\n    output logic [$clog2(Depth)-1:0] read_ptr\n);\n    // Read pointer logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            read_ptr <= '0;\n            read_enable <= 1'b0;\n        end else begin\n            read_enable <= !fifo_empty && outTready;\n            if (read_enable)\n                read_ptr <= (read_ptr == Depth-1) ? '0 : read_ptr + 1'b1;\n        end\n    end\n\nendmodule\n```\n\n3. Storage Array Module:\n```systemverilog\nmodule storage_array #(\n    parameter int Depth = 8,\n    parameter type AxiStreamType = logic,\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic        inError,\n    input  logic [$clog2(Depth)-1:0] write_ptr,\n    input  logic [$clog2(Depth)-1:0] read_ptr,\n    input  logic        write_enable,\n    input  logic        read_enable,\n    output AxiStreamType outAxi4St,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic        outError\n);\n    // Storage arrays\n    AxiStreamType [Depth-1:0] data_array;\n    logic [ExtraDataWidth-1:0] [Depth-1:0] extra_array;\n    logic [Depth-1:0] error_array;\n\n    // Write operation\n    always_ff @(posedge clock) begin\n        if (write_enable) begin\n            data_array[write_ptr]  <= inAxi4St;\n            extra_array[write_ptr] <= inExtra;\n            error_array[write_ptr] <= inError;\n        end\n    end\n\n    // Read operation\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outAxi4St.tvalid <= 1'b0;\n        end else if (read_enable) begin\n            outAxi4St <= data_array[read_ptr];\n            outExtra  <= extra_array[read_ptr];\n            outError  <= error_array[read_ptr];\n        end\n    end\n\nendmodule\n```\n\n4. Counter Module:\n```systemverilog\nmodule fifo_counter #(\n    parameter int Depth = 8,\n    parameter int AlmostFull = Depth - 8,\n    parameter int AlmostEmpty = 0,\n    parameter int CountWidth = $clog2(Depth + 1)\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic        write_enable,\n    input  logic        read_enable,\n    output logic [CountWidth-1:0] inCount,\n    output logic [CountWidth-1:0] outCount,\n    output logic        almostFull,\n    output logic        almostEmpty,\n    output logic        fifo_full,\n    output logic        fifo_empty\n);\n    // Counter logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            inCount <= '0;\n            outCount <= '0;\n        end else begin\n            case ({write_enable, read_enable})\n                2'b10: begin // Write only\n                    inCount <= inCount + 1'b1;\n                    outCount <= outCount + 1'b1;\n                end\n                2'b01: begin // Read only\n                    inCount <= inCount - 1'b1;\n                    outCount <= outCount - 1'b1;\n                end\n                // Both or neither: no change\n            endcase\n        end\n    end\n\n    // Status flags\n    assign fifo_full = (inCount == Depth);\n    assign fifo_empty = (outCount == 0);\n    assign almostFull = (inCount >= AlmostFull);\n    assign almostEmpty = (outCount <= AlmostEmpty);\n\nendmodule\n```\n\n5. Top-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter int Depth = 8,\n    parameter type AxiStreamType = logic,\n    parameter int ExtraDataWidth = 1\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic [ExtraDataWidth-1:0] inExtra,\n    input  logic        inError,\n    input  logic        outTready,\n    output AxiStreamType outAxi4St,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic        outError,\n    output logic        inTready,\n    output logic        almostFull,\n    output logic        almostEmpty\n);\n\n    // Internal signals\n    logic write_enable, read_enable;\n    logic [$clog2(Depth)-1:0] write_ptr, read_ptr;\n    logic fifo_full, fifo_empty;\n    \n    // Instantiate submodules\n    write_control write_ctrl_inst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .fifo_full(fifo_full),\n        .inTready(inTready),\n        .write_enable(write_enable),\n        .write_ptr(write_ptr)\n    );\n\n    read_control read_ctrl_inst (\n        .clock(clock),\n        .reset(reset),\n        .outTready(outTready),\n        .fifo_empty(fifo_empty),\n        .read_enable(read_enable),\n        .read_ptr(read_ptr)\n    );\n\n    storage_array storage_inst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inExtra(inExtra),\n        .inError(inError),\n        .write_ptr(write_ptr),\n        .read_ptr(read_ptr),\n        .write_enable(write_enable),\n        .read_enable(read_enable),\n        .outAxi4St(outAxi4St),\n        .outExtra(outExtra),\n        .outError(outError)\n    );\n\n    fifo_counter counter_inst (\n        .clock(clock),\n        .reset(reset),\n        .write_enable(write_enable),\n        .read_enable(read_enable),\n        .fifo_full(fifo_full),\n        .fifo_empty(fifo_empty),\n        .almostFull(almostFull),\n        .almostEmpty(almostEmpty)\n    );\n\nendmodule\n```\n\nCritical Interfaces:\n1. Control Signals:\n- write_enable/read_enable between control and storage\n- fifo_full/fifo_empty between counter and controls\n\n2. Data Path:\n- write_ptr/read_ptr between controls and storage\n- Data/Extra/Error signals between modules\n\n3. Status Signals:\n- Counter outputs to generate status flags\n- Ready/Valid handshaking signals\n\nThese interfaces need careful timing consideration and proper synchronization.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a simple ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 8\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 0, or a power-of-2.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned AlmostFull = (Depth - 8)\n        -- Number of entries (less than or equal to Depth), that if this many entries or more are occupied in the FIFO, module output almostFull is set to 1.\n     -- parameter int unsigned AlmostEmpty = 0\n        -- Number of entries: that if fewer than this many entries are occupied in the FIFO, module output almostEmpty is set to 1.\n     -- parameter bit          PreferSrl = 0\n        -- Style of the underlying FIFO. This can be left at value 0 and not used internally, but must exist in the parameter list.\n     --  parameter int unsigned CountWidth     = $clog2(Depth + 1)\n        -- Width in bits for module outputs inCount and outCount.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n       -- All fields of inAxi4St, except tvalid, must be stored in the FIFO if DEPTH > 0.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: inCount\n       -- output logic [CountWidth - 1 : 0] inCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if inCount==Depth, then inTready should be 0, because the FIFO is full.\n    -- Output: outCount\n       -- output logic [CountWidth - 1 : 0] outCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if outCount==0, then outAxi4St.tvalid should be 0, because the FIFO is empty\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: almostFull\n       -- output logic almostFull\n       -- is 1 when inCount >= AlmostFull\n    -- Output: almostEmpty\n       -- output logic almostEmpty\n       -- is 1 when outCount <= AlmostEmpty\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_simple_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_simple_fifo\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_simple_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_simple_fifo_2"
  },
  {
    "index": 19,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready,\n    output logic        outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    // Internal signals\n    logic [47:0] dest_mac_reg, source_mac_reg;\n    logic [$clog2(12):0] byte_counter;\n    logic frame_active, frame_start;\n    logic parsing_enable;\n    logic parse_complete;\n    \n    // Calculate required pipeline stages based on data width\n    localparam int unsigned NumStages = (AxiStreamWidth == 8) ? 11 :\n                                      (AxiStreamWidth == 16) ? 5 :\n                                      (AxiStreamWidth == 32) ? 2 :\n                                      (AxiStreamWidth == 64) ? 1 : 0;\n\n    // Frame control logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_active <= 1'b0;\n            frame_start <= 1'b1;\n            parsing_enable <= 1'b0;\n        end\n        else if (inAxi4St.tvalid && inTready) begin\n            if (inAxi4St.tlast) begin\n                frame_active <= 1'b0;\n                frame_start <= 1'b1;\n                parsing_enable <= 1'b0;\n            end\n            else begin\n                frame_active <= 1'b1;\n                frame_start <= 1'b0;\n                parsing_enable <= !frame_active;\n            end\n        end\n    end\n\n    // MAC address parsing logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            dest_mac_reg <= '0;\n            source_mac_reg <= '0;\n            parse_complete <= 1'b0;\n        end\n        else if (inAxi4St.tvalid && inTready && parsing_enable) begin\n            case (AxiStreamWidth)\n                8: begin\n                    if (byte_counter < 6) begin\n                        dest_mac_reg <= {dest_mac_reg[39:0], inAxi4St.tdata};\n                    end\n                    else if (byte_counter < 12) begin\n                        source_mac_reg <= {source_mac_reg[39:0], inAxi4St.tdata};\n                    end\n                    byte_counter <= byte_counter + 1;\n                    parse_complete <= (byte_counter == 11);\n                end\n                \n                16: begin\n                    if (byte_counter < 6) begin\n                        dest_mac_reg <= {dest_mac_reg[31:0], inAxi4St.tdata};\n                    end\n                    else if (byte_counter < 12) begin\n                        source_mac_reg <= {source_mac_reg[31:0], inAxi4St.tdata};\n                    end\n                    byte_counter <= byte_counter + 2;\n                    parse_complete <= (byte_counter == 10);\n                end\n                \n                default: begin\n                    // For wider data paths, implement similar logic\n                    parse_complete <= 1'b0;\n                end\n            endcase\n        end\n        else if (inAxi4St.tvalid && inTready && !parsing_enable) begin\n            byte_counter <= '0;\n            parse_complete <= 1'b0;\n        end\n    end\n\n    // Pipeline delay instance\n    local_axist_pipe #(\n        .NumStages(NumStages),\n        .AxiStreamType(AxiStreamType)\n    ) pipe_inst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\n\n    // Output alignment and valid generation\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n            outParsedValid <= 1'b0;\n        end\n        else begin\n            if (parse_complete) begin\n                outParsedDestMac <= dest_mac_reg;\n                outParsedSourceMac <= source_mac_reg;\n            end\n            outParsedValid <= outAxi4St.tvalid && frame_start;\n        end\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram description:\n\nMain Functionality:\n1. The module extracts Destination MAC (6 bytes) and Source MAC (6 bytes) addresses from an Ethernet frame received over an AXI4-Stream interface\n2. It must maintain the original data stream, outputting it with appropriate delay to align the extracted MAC addresses with the first data beat\n3. The MAC addresses should be presented as 48-bit values (outParsedDestMac[47:0] and outParsedSourceMac[47:0]) along with a valid signal on the first beat of the output frame\n\nHigh-Level Block Diagram:\n```\n                                                    +------------------------+\n                                                    |   MAC Address Parser   |\n                                                    |                        |\ninAxi4St    ----------------------------+          | +------------------+   |\n                                        |          | |  Address Extract  |   |\n                                        +--------->| |    Logic         |   |-----> outParsedDestMac[47:0]\n                                                  | +------------------+   |-----> outParsedSourceMac[47:0]\n                                                  |                        |-----> outParsedValid\n                                                  |          |            |\n                                                  | +------------------+   |\n                                                  | |local_axist_pipe  |   |\n                                                  | |(Delay Pipeline)  |   |\n                                                  | +------------------+   |\n                                                  |          |            |\n                                                  +----------+------------+\n                                                             |\n                                                             +------------> outAxi4St\n```\n\nKey Components:\n1. Address Extract Logic\n   - Captures and assembles the MAC addresses from incoming data stream\n   - Supports variable width data paths (from 8-bit to wider)\n   - Maintains byte order (Big Endian)\n\n2. Delay Pipeline (local_axist_pipe)\n   - Delays the output stream to align with extracted MAC addresses\n   - Number of delay stages depends on input data width\n   - Preserves AXI4-Stream protocol integrity\n\n3. Control Logic\n   - Manages frame boundaries\n   - Generates outParsedValid signal\n   - Handles AXI4-Stream handshaking (tready/tvalid)\n\nThe design must be flexible to handle different AXI Stream data widths while maintaining proper protocol timing and data alignment.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, let me identify the key parameterizable aspects and their reasonable default values:\n\nKey Parameterizable Aspects:\n\n1. AXI Stream Interface Type:\n```systemverilog\nparameter type AxiStreamType = local_pkg::axi4st_8_s\n```\n- This is the primary parameter defining the AXI4-Stream interface structure\n- Default is 8-bit data width structure (axi4st_8_s)\n- Should contain tdata, tkeep, tuser, tlast, and tvalid fields\n\n2. Data Width:\n```systemverilog\nparameter int unsigned AxiStreamWidth = 8\n```\n- Defines the width of the tdata field\n- Default is 8 bits (1 byte)\n- Common values: 8, 16, 32, 64, 128 bits\n- Must match the tdata width in AxiStreamType\n\n3. Pipeline Depth:\n- For local_axist_pipe module:\n```systemverilog\nparameter int unsigned NumStages\n```\n- Should be calculated based on AxiStreamWidth\n- For 8-bit: needs 11 stages minimum (to capture 12 bytes)\n- For wider buses: fewer stages needed\n- Formula: ceil(12/(AxiStreamWidth/8)) - 1\n\nReasonable Default Values:\n\n1. Interface Type Defaults:\n```systemverilog\ntypedef struct packed {\n    logic [7:0] tdata;  // 8-bit default\n    logic       tkeep;  // 1-bit\n    logic       tuser;  // 1-bit\n    logic       tlast;  // 1-bit\n    logic       tvalid; // 1-bit\n} axi4st_8_s;\n```\n\n2. Pipeline Depth Based on Width:\n```systemverilog\n// Examples:\n// 8-bit:  11 stages needed\n// 16-bit: 5 stages needed\n// 32-bit: 2 stages needed\n// 64-bit: 1 stage needed\n// 128-bit: 0 stages needed\n```\n\nDesign Considerations:\n1. Parameters should be checked for validity:\n   - AxiStreamWidth must be a power of 2\n   - AxiStreamWidth must be \u2265 8\n   - Pipeline depth must be appropriate for the data width\n\n2. The module should support easy reconfiguration for different bus widths while maintaining functionality\n\n3. Default values should support the most common use case (8-bit) while allowing for optimization with wider buses\n\n4. Parameters should be compile-time constant to allow for optimal synthesis\n\nThis parameterization allows the module to be flexible while maintaining efficiency across different implementations.How will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Processing Flow:\n\n1. MAC Address Capture Logic:\n```systemverilog\n// Registers for MAC address storage\nlogic [47:0] dest_mac_reg;\nlogic [47:0] source_mac_reg;\nlogic [$clog2(12):0] byte_counter; // Counts bytes in header\nlogic parsing_active;  // Indicates active parsing state\n\n// For 8-bit implementation example:\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        byte_counter <= '0;\n        parsing_active <= 1'b0;\n    end\n    else if (inAxi4St.tvalid && inTready) begin\n        if (byte_counter < 6) begin\n            // Capture Destination MAC\n            dest_mac_reg <= {dest_mac_reg[39:0], inAxi4St.tdata};\n            byte_counter <= byte_counter + 1;\n        end\n        else if (byte_counter < 12) begin\n            // Capture Source MAC\n            source_mac_reg <= {source_mac_reg[39:0], inAxi4St.tdata};\n            byte_counter <= byte_counter + 1;\n        end\n    end\nend\n```\n\n2. Pipeline Control Logic:\n```systemverilog\n// Frame tracking\nlogic frame_start;\nlogic frame_active;\n\n// Start of frame detection\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        frame_start <= 1'b1;  // Ready for new frame\n        frame_active <= 1'b0;\n    end\n    else if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n            frame_start <= 1'b1;  // Next will be new frame\n            frame_active <= 1'b0;\n        end\n        else begin\n            frame_start <= 1'b0;\n            frame_active <= 1'b1;\n        end\n    end\nend\n```\n\n3. Output Control:\n```systemverilog\n// Valid generation logic\nlogic parsed_valid_reg;\nalways_ff @(posedge clock) begin\n    if (reset)\n        parsed_valid_reg <= 1'b0;\n    else\n        parsed_valid_reg <= frame_start && outAxi4St.tvalid;\nend\n```\n\nRequired Registers:\n\n1. MAC Address Storage:\n- dest_mac_reg[47:0]\n- source_mac_reg[47:0]\n\n2. Control Registers:\n- byte_counter\n- parsing_active\n- frame_start\n- frame_active\n- parsed_valid_reg\n\n3. Pipeline Registers:\n- Through local_axist_pipe instance\n\nCombinational Logic:\n\n1. MAC Assembly Logic:\n```systemverilog\n// For wider data paths\nalways_comb begin\n    case (AxiStreamWidth)\n        8: begin\n            // Sequential byte assembly\n        end\n        16: begin\n            // Two bytes per cycle\n        end\n        32: begin\n            // Four bytes per cycle\n        end\n        // etc.\n    endcase\nend\n```\n\n2. Output Assignment:\n```systemverilog\nassign outParsedDestMac = dest_mac_reg;\nassign outParsedSourceMac = source_mac_reg;\nassign outParsedValid = parsed_valid_reg;\n```\n\n3. Ready/Valid Handshaking:\n```systemverilog\nassign inTready = pipe_instance.inTready;\n```\n\nSpecial Considerations:\n\n1. Data Width Handling:\n- Logic must adapt to different data widths\n- Wider buses need parallel processing\n- Byte ordering must be maintained (Big Endian)\n\n2. Pipeline Depth:\n- Must be calculated based on data width\n- Ensures MAC fields align with first output beat\n\n3. Error Handling:\n- Consider adding error detection for malformed frames\n- Validate minimum frame length\n\n4. Performance Optimization:\n- Minimize latency for wider data paths\n- Efficient state machine implementation\n- Proper pipeline balancing\n\nThis structure ensures proper extraction and alignment of MAC addresses while maintaining AXI4-Stream protocol compliance.What are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me analyze the clocking, timing, and reset requirements from the problem description:\n\nClocking Requirements:\n1. Single Clock Domain\n```systemverilog\ninput logic clock   // Single system clock\n```\n- All operations are synchronous to this clock\n- No clock domain crossing needed\n- AXI4-Stream protocol operates on single clock\n\nReset Requirements:\n1. Synchronous Reset\n```systemverilog\ninput logic reset   // Synchronous reset\n```\n- Problem explicitly states reset is synchronous\n- All registers should reset on the positive edge of clock when reset is high\n\nSignals Requiring Reset:\n1. Control Registers:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        byte_counter <= '0;\n        frame_start <= 1'b1;\n        frame_active <= 1'b0;\n        parsing_active <= 1'b0;\n        parsed_valid_reg <= 1'b0;\n    end\nend\n```\n\n2. MAC Address Registers:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        dest_mac_reg <= '0;\n        source_mac_reg <= '0;\n    end\nend\n```\n\nLatency Requirements:\n1. Variable based on data width:\n- 8-bit width: 11 cycles minimum latency\n- 16-bit width: 5 cycles minimum latency\n- 32-bit width: 2 cycles minimum latency\n- 64-bit width: 1 cycle minimum latency\n- 128-bit width: 0 cycles minimum latency\n\n2. Alignment Requirement:\n- Extracted MAC addresses must align with first output data beat\n- Pipeline depth must accommodate this alignment\n\nThroughput Requirements:\n1. AXI4-Stream Protocol:\n- Must maintain continuous streaming when ready\n- No artificial stalls or bubbles\n```systemverilog\n// Continuous operation when ready\nassign inTready = outTready && !internal_stall;\n```\n\n2. Back-Pressure Handling:\n- Must respect outTready signal\n- Propagate backpressure through pipeline\n```systemverilog\n// Backpressure propagation\nassign inTready = pipe_instance.inTready;\n```\n\nTiming Constraints:\n1. Setup/Hold Requirements:\n- All registers operate on positive clock edge\n- Standard setup/hold times apply\n```systemverilog\n// All sequential logic\nalways_ff @(posedge clock) begin\n    // Logic here\nend\n```\n\n2. Frame Boundary Requirements:\n- Must detect frame boundaries correctly\n- Valid extraction on first beat of each frame\n```systemverilog\n// Frame boundary detection\nframe_start <= inAxi4St.tvalid && !frame_active;\n```\n\nSpecific Timing Considerations:\n1. Protocol Timing:\n- AXI4-Stream handshake timing must be maintained\n- tvalid/tready/tlast relationships preserved\n\n2. Critical Paths:\n- MAC address assembly logic\n- Pipeline stage transitions\n- Valid generation logic\n\n3. Performance Goals:\n- Minimize added latency\n- Maintain line rate throughput\n- No clock cycle gaps in data stream\n\nImplementation Guidelines:\n1. Reset Strategy:\n```systemverilog\n// Synchronous reset implementation\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Reset values\n    end\n    else begin\n        // Normal operation\n    end\nend\n```\n\n2. Pipeline Control:\n```systemverilog\n// Use local_axist_pipe for proper delay\nlocal_axist_pipe #(\n    .NumStages(REQUIRED_STAGES),\n    .AxiStreamType(AxiStreamType)\n) pipe_instance (\n    .clock(clock),\n    .reset(reset),\n    // Other connections\n);\n```\n\n3. Throughput Optimization:\n- Register outputs for timing closure\n- Minimize combinational logic depth\n- Efficient state machine encoding\n\nThese timing and reset requirements ensure reliable operation while maintaining protocol compliance and meeting performance goals.What test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline the test scenarios and assertions needed to verify this module:\n\nTest Scenarios:\n\n1. Basic Functionality Tests:\n```systemverilog\n// Test basic frame processing\ntask test_basic_frame();\n    // Send single frame with known MAC addresses\n    logic [47:0] test_dest_mac = 48'h112233445566;\n    logic [47:0] test_src_mac = 48'hAABBCCDDEEFF;\n    send_frame(test_dest_mac, test_src_mac);\n    // Verify extracted values\n    check_parsed_macs(test_dest_mac, test_src_mac);\nendtask\n```\n\n2. Protocol Edge Cases:\n```systemverilog\n// Test minimum/maximum frame sizes\n// Test back-to-back frames\n// Test with gaps between frames\ntask test_protocol_edges();\n    // Minimum size frame\n    send_min_frame();\n    // Maximum size frame\n    send_max_frame();\n    // Back-to-back frames\n    send_consecutive_frames();\n    // Frames with gaps\n    send_frames_with_gaps();\nendtask\n```\n\n3. Backpressure Testing:\n```systemverilog\n// Test various backpressure scenarios\ntask test_backpressure();\n    // Random outTready assertion/deassertion\n    fork\n        send_continuous_frames();\n        apply_random_backpressure();\n    join\nendtask\n```\n\n4. Reset Testing:\n```systemverilog\ntask test_reset_scenarios();\n    // Reset during frame transfer\n    fork\n        send_frame();\n        #10 reset = 1'b1;\n        #11 reset = 1'b0;\n    join\n    // Reset between frames\n    // Reset with backpressure\nendtask\n```\n\nAssertions:\n\n1. Protocol Compliance:\n```systemverilog\n// Valid/Ready handshaking\nproperty valid_ready_handshake;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inTready |=> inAxi4St.tvalid;\nendproperty\nassert property(valid_ready_handshake);\n\n// Frame continuity\nproperty frame_continuity;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && !inAxi4St.tlast |=> inAxi4St.tvalid;\nendproperty\nassert property(frame_continuity);\n```\n\n2. MAC Extraction Checks:\n```systemverilog\n// Valid signal timing\nproperty parsed_valid_timing;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && frame_start |-> outParsedValid;\nendproperty\nassert property(parsed_valid_timing);\n\n// MAC value stability\nproperty mac_stability;\n    @(posedge clock) disable iff (reset)\n    outParsedValid |=> \n        $stable(outParsedDestMac) && $stable(outParsedSourceMac);\nendproperty\nassert property(mac_stability);\n```\n\n3. Pipeline Behavior:\n```systemverilog\n// Pipeline delay check\nproperty pipeline_delay;\n    @(posedge clock) disable iff (reset)\n    $past(inAxi4St.tvalid, PIPELINE_DEPTH) && \n    $past(inTready, PIPELINE_DEPTH) |-> outAxi4St.tvalid;\nendproperty\nassert property(pipeline_delay);\n```\n\n4. Error Conditions:\n```systemverilog\n// Frame minimum length\nproperty min_frame_length;\n    @(posedge clock) disable iff (reset)\n    inAxi4St.tvalid && inAxi4St.tlast |-> (byte_counter >= 12);\nendproperty\nassert property(min_frame_length);\n\n// No valid drops mid-frame\nproperty valid_persistence;\n    @(posedge clock) disable iff (reset)\n    frame_active && !inAxi4St.tlast |-> !$fell(inAxi4St.tvalid);\nendproperty\nassert property(valid_persistence);\n```\n\nCoverage Points:\n\n1. Functional Coverage:\n```systemverilog\ncovergroup mac_extraction_cg;\n    mac_values: coverpoint {outParsedDestMac, outParsedSourceMac} {\n        bins broadcast = {48'hFFFFFFFFFFFF};\n        bins unicast = {[0:48'hFFFFFFFFFFFE]};\n    }\n    \n    frame_sizes: coverpoint byte_counter {\n        bins min_size = {12};\n        bins mid_size = {[13:1000]};\n        bins max_size = {1500};\n    }\nendgroup\n```\n\n2. Protocol Coverage:\n```systemverilog\ncovergroup protocol_cg;\n    backpressure: coverpoint inTready {\n        bins ready_patterns[] = {2'b00, 2'b01, 2'b10, 2'b11};\n    }\n    \n    frame_gaps: coverpoint frame_gap_size {\n        bins no_gap = {0};\n        bins small_gap = {[1:5]};\n        bins large_gap = {[6:$]};\n    }\nendgroup\n```\n\nTest Environment Setup:\n```systemverilog\nclass test_env;\n    // Virtual interface for DUT\n    virtual axi4st_if vif;\n    // Scoreboard\n    mac_scoreboard sb;\n    // Coverage collector\n    mac_extraction_cg cg;\n    \n    // Test sequences\n    task run_all_tests();\n        test_basic_frame();\n        test_protocol_edges();\n        test_backpressure();\n        test_reset_scenarios();\n    endtask\nendclass\n```\n\nThis comprehensive verification approach ensures:\n- Correct MAC address extraction\n- Protocol compliance\n- Proper handling of edge cases\n- Reset behavior verification\n- Coverage of important scenarios\n- Early detection of potential issues through assertionsWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. MAC Address Parser Block:\n```systemverilog\nmodule mac_parser #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic                 clock,\n    input  logic                 reset,\n    input  logic [AxiStreamWidth-1:0] data_in,\n    input  logic                 data_valid,\n    output logic [47:0]          dest_mac,\n    output logic [47:0]          source_mac,\n    output logic                 parse_complete\n);\n```\nPurpose:\n- Extracts MAC addresses from incoming data stream\n- Handles byte ordering (Big Endian)\n- Tracks parsing progress\n- Supports different data widths\n\n2. Frame Control Block:\n```systemverilog\nmodule frame_controller (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic tlast,\n    output logic frame_start,\n    output logic frame_active,\n    output logic parsing_enable\n);\n```\nPurpose:\n- Detects frame boundaries\n- Manages frame state\n- Controls parsing window\n- Generates control signals for other blocks\n\n3. Pipeline Manager (Using local_axist_pipe):\n```systemverilog\nmodule pipeline_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumStages = 11\n) (\n    // Standard interface ports\n);\n```\nPurpose:\n- Manages data pipeline delay\n- Handles backpressure propagation\n- Aligns extracted MAC data with output stream\n- Interfaces with provided local_axist_pipe module\n\n4. Output Alignment Block:\n```systemverilog\nmodule output_aligner #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] source_mac,\n    input  logic        frame_start,\n    output logic        parsed_valid,\n    output logic [47:0] aligned_dest_mac,\n    output logic [47:0] aligned_source_mac\n);\n```\nPurpose:\n- Aligns parsed MAC addresses with first output beat\n- Generates parsed_valid signal\n- Ensures timing requirements are met\n\n5. Top-Level Integration (dut):\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    // Top-level interface ports\n);\n\n    // Instantiate submodules\n    mac_parser parser (/*...*/);\n    frame_controller frame_ctrl (/*...*/);\n    pipeline_manager pipe_mgr (/*...*/);\n    output_aligner aligner (/*...*/);\n```\n\nInterconnections:\n```systemverilog\n    // Internal connections between blocks\n    logic [47:0] parsed_dest_mac, parsed_src_mac;\n    logic parse_complete, frame_start, frame_active;\n    \n    // Connect blocks\n    assign parser.data_in = inAxi4St.tdata;\n    assign parser.data_valid = inAxi4St.tvalid && inTready;\n    \n    assign frame_ctrl.tvalid = inAxi4St.tvalid;\n    assign frame_ctrl.tlast = inAxi4St.tlast;\n    \n    assign aligner.dest_mac = parsed_dest_mac;\n    assign aligner.source_mac = parsed_src_mac;\n```\n\nData Flow Between Blocks:\n```\ninAxi4St -> Frame Controller -+-> MAC Parser -> Output Aligner -+-> outParsedDestMac\n                             |                                  +-> outParsedSourceMac\n                             +-> Pipeline Manager --------------> outAxi4St\n```\n\nKey Interactions:\n1. Frame Controller with MAC Parser:\n- Controls when parsing occurs\n- Synchronizes with frame boundaries\n\n2. MAC Parser with Output Aligner:\n- Passes extracted MAC addresses\n- Indicates completion of parsing\n\n3. Pipeline Manager with Output Aligner:\n- Coordinates timing of parsed data\n- Ensures alignment with delayed stream\n\n4. Top-Level Integration:\n- Manages all control signals\n- Handles protocol requirements\n- Provides clean interfaces\n\nThis modular approach provides:\n- Clear separation of concerns\n- Easier testing and verification\n- Better maintainability\n- Simplified debugging\n- Reusable componentsWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll write the SystemVerilog code for each submodule and highlight their critical interfaces:\n\n1. MAC Parser Module:\n```systemverilog\nmodule mac_parser #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic                          clock,\n    input  logic                          reset,\n    input  logic [AxiStreamWidth-1:0]     data_in,\n    input  logic                          data_valid,\n    input  logic                          parsing_enable,\n    output logic [47:0]                   dest_mac,\n    output logic [47:0]                   source_mac,\n    output logic                          parse_complete\n);\n    // Internal registers\n    logic [47:0] dest_mac_reg, source_mac_reg;\n    logic [$clog2(12):0] byte_counter;\n    \n    // Parsing logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            dest_mac_reg <= '0;\n            source_mac_reg <= '0;\n            parse_complete <= 1'b0;\n        end\n        else if (data_valid && parsing_enable) begin\n            case (AxiStreamWidth)\n                8: begin  // 8-bit processing\n                    if (byte_counter < 6) begin\n                        dest_mac_reg <= {dest_mac_reg[39:0], data_in};\n                    end\n                    else if (byte_counter < 12) begin\n                        source_mac_reg <= {source_mac_reg[39:0], data_in};\n                    end\n                    byte_counter <= byte_counter + 1;\n                    parse_complete <= (byte_counter == 11);\n                end\n                // Add cases for other widths\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign dest_mac = dest_mac_reg;\n    assign source_mac = source_mac_reg;\nendmodule\n```\n\n2. Frame Controller:\n```systemverilog\nmodule frame_controller (\n    input  logic clock,\n    input  logic reset,\n    input  logic tvalid,\n    input  logic tlast,\n    output logic frame_start,\n    output logic frame_active,\n    output logic parsing_enable\n);\n    // Frame state tracking\n    logic frame_active_reg;\n    logic frame_start_reg;\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            frame_active_reg <= 1'b0;\n            frame_start_reg <= 1'b0;\n            parsing_enable <= 1'b0;\n        end\n        else begin\n            if (tvalid) begin\n                if (!frame_active_reg) begin\n                    frame_start_reg <= 1'b1;\n                    frame_active_reg <= 1'b1;\n                    parsing_enable <= 1'b1;\n                end\n                else begin\n                    frame_start_reg <= 1'b0;\n                    if (tlast) begin\n                        frame_active_reg <= 1'b0;\n                        parsing_enable <= 1'b0;\n                    end\n                end\n            end\n        end\n    end\n\n    assign frame_start = frame_start_reg;\n    assign frame_active = frame_active_reg;\nendmodule\n```\n\n3. Pipeline Manager:\n```systemverilog\nmodule pipeline_manager #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumStages = 11\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    output logic        inTready,\n    output AxiStreamType outAxi4St,\n    input  logic        outTready\n);\n    // Instantiate provided pipeline module\n    local_axist_pipe #(\n        .NumStages(NumStages),\n        .AxiStreamType(AxiStreamType)\n    ) pipe_inst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(inAxi4St),\n        .inTready(inTready),\n        .outAxi4St(outAxi4St),\n        .outTready(outTready)\n    );\nendmodule\n```\n\n4. Output Aligner:\n```systemverilog\nmodule output_aligner #(\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  logic [47:0] dest_mac,\n    input  logic [47:0] source_mac,\n    input  logic        frame_start,\n    input  logic        parse_complete,\n    output logic        parsed_valid,\n    output logic [47:0] aligned_dest_mac,\n    output logic [47:0] aligned_source_mac\n);\n    // Register MAC addresses and valid signal\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            aligned_dest_mac <= '0;\n            aligned_source_mac <= '0;\n            parsed_valid <= 1'b0;\n        end\n        else begin\n            if (parse_complete) begin\n                aligned_dest_mac <= dest_mac;\n                aligned_source_mac <= source_mac;\n            end\n            parsed_valid <= frame_start && parse_complete;\n        end\n    end\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between MAC Parser and Frame Controller:\n```systemverilog\n// Control signals\n.parsing_enable(parsing_enable),  // From Frame Controller to Parser\n.parse_complete(parse_complete)   // From Parser to Frame Controller\n```\n\n2. Between MAC Parser and Output Aligner:\n```systemverilog\n// Data paths\n.dest_mac(parsed_dest_mac),      // From Parser to Aligner\n.source_mac(parsed_src_mac),     // From Parser to Aligner\n.parse_complete(parse_complete)   // From Parser to Aligner\n```\n\n3. Between Frame Controller and Output Aligner:\n```systemverilog\n// Control signals\n.frame_start(frame_start),       // From Controller to Aligner\n.frame_active(frame_active)      // From Controller to Aligner\n```\n\n4. Top-Level Integration:\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n) (\n    // Standard ports...\n);\n    // Internal connections\n    logic [47:0] parsed_dest_mac, parsed_src_mac;\n    logic parse_complete, frame_start, frame_active;\n    logic parsing_enable;\n\n    // Instantiate all submodules\n    mac_parser #(\n        .AxiStreamWidth(AxiStreamWidth)\n    ) parser_inst (/*...*/);\n\n    frame_controller frame_ctrl_inst (/*...*/);\n\n    pipeline_manager #(\n        .AxiStreamType(AxiStreamType),\n        .NumStages(NumStages)\n    ) pipe_mgr_inst (/*...*/);\n\n    output_aligner #(\n        .AxiStreamWidth(AxiStreamWidth)\n    ) aligner_inst (/*...*/);\n\nendmodule\n```\n\nThese interfaces ensure proper synchronization and data flow between submodules while maintaining modular design principles.\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_3"
  },
  {
    "index": 20,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned NumInputs = 4,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0\n) (\n    input  logic                        clock,\n    input  logic                        reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic        [NumInputs-1:0]  inTready,\n    output AxiStreamType                outAxi4St,\n    input  logic                        outTready\n);\n\n    // Internal signals\n    logic [NumInputs-1:0]                 requests_in;\n    logic [NumInputs-1:0]                 grant_out;\n    logic [$clog2(NumInputs)-1:0]         select_out;\n    logic                                 update_valid;\n    logic                                 in_packet;\n\n    // Generate request vector from valid inputs\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++) begin\n            requests_in[i] = inAxi4St[i].tvalid;\n        end\n    end\n\n    // Round robin arbiter instance\n    local_rrarb #(\n        .NumInputs(NumInputs)\n    ) u_rrarb (\n        .clock(clock),\n        .reset(reset),\n        .update_valid(update_valid),\n        .requests_in(requests_in),\n        .grant_out(grant_out),\n        .select_out(select_out)\n    );\n\n    // Zero-latency multiplexing to output\n    always_comb begin\n        outAxi4St = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            if (grant_out[i]) begin\n                outAxi4St = inAxi4St[i];\n            end\n        end\n    end\n\n    // Generate ready signals\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++) begin\n            inTready[i] = grant_out[i] && outTready;\n        end\n    end\n\n    // Packet boundary detection \n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(outAxi4St),\n        .inTready(outTready),\n        .tfirst(),\n        .in_packet(in_packet)\n    );\n\n    // Update arbitration control\n    always_comb begin\n        update_valid = !in_packet ||\n                      (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n    end\n\nendmodule",
    "conversation": "Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n\nAdditionally, you are required to use the following module (without revealing the internals) to perform round robin arbitration. The outputs of local_rrarb (grant_out, and select_out) are held and will not change unless input update_valid=1. When update_valid=1, a requests_in (vector of request valid bits) is also set, and a new arbitration winner is on the outputs -- grant_out is a 1-hot vector, and select_out is the encoded winner with values between 0 and NumInputs-1.\n\nmodule local_rrarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n\nAdditionally, you are required to use the folowing module (without revealing the internals) to determine when a packet or frame starts on any of the inputs.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining how to drive helper module local_rrarb's input vector for \"update_valid\". For example, if you were to connect dut's output outAxist4St and outTready to an instance of local_axist_tfirst, you could know if the output is in the middle of sending a packet:\n\nlogic in_packet_on_outAxi4St; // from local_axist_tfirst module output\nlocig update_valid; // update_valid to input of local_rrarb module\n\nalways_ff @(posedge clock) begin\n\n  update_valid <=\n    // we are not in a packet now, safe to set update_valid=1 next cycle\n    in_packet_on_outaxi4st ||\n    // OR, we just transfered the final outbound data phit, safe to set update_valid=1 next cycle\n    (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n\nend\n\n    ======\n    \n    Answer the questions regarding the description\n    What is the main functionality of this hardware module? What is the high-level block diagram?\n [NEW STEP]\n \nLet me break down the main functionality and provide a high-level block diagram of this module:\n\nMain Functionality:\n1. This is an AXI4-Stream multiplexer with Round Robin arbitration\n2. It takes multiple AXI4-Stream inputs (parameterized, default 4) and multiplexes them to a single AXI4-Stream output\n3. Key requirements:\n   - Zero latency from selected input to output\n   - Round Robin arbitration (fair scheduling)\n   - Must maintain packet/frame integrity (can't switch inputs mid-packet)\n   - Uses provided local_rrarb module for arbitration decisions\n   - Uses provided local_axist_tfirst module for packet boundary detection\n\nHigh-Level Block Diagram:\n```\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n inAxi4St[0] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                 \u2502\n                         \u2502                                  \u2502\n inAxi4St[1] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                 \u2502\n                         \u2502         Round Robin             \u251c\u2500\u2500\u2500\u2500\u2500\u2500 outAxi4St\n inAxi4St[2] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          Arbiter               \u2502\n                         \u2502            +                    \u2502\n inAxi4St[3] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      AXI4-Stream MUX          \u2502\n                         \u2502                                 \u2502\n                         \u2502                                 \u2502\n outTready \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500 inTready[3:0]\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                                     clock\n                                     reset\n\nInternal Blocks:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  local_rrarb   \u2502    \u2502 local_axist_   \u2502\n\u2502   (arbiter)    \u2502    \u2502    tfirst      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nKey Components:\n1. Round Robin Arbiter (local_rrarb module)\n   - Selects which input gets access to output\n   - Maintains fairness across inputs\n   - Only updates on packet boundaries\n\n2. Packet Boundary Detection (local_axist_tfirst module)\n   - Monitors packet boundaries\n   - Helps determine when arbitration can occur\n\n3. Multiplexer\n   - Routes selected input to output\n   - Manages ready signals based on selection\n\nThe module ensures fair access to the output while maintaining packet integrity and providing zero-latency data transfer from the selected input to the output.What aspects should be parameterizable? What are reasonable default values?\n [NEW STEP]\n \nBased on the problem description, here are the key parameterizable aspects and their reasonable default values:\n\nRequired Parameters (from description):\n1. `NumInputs`\n   - Purpose: Number of AXI4-Stream input ports\n   - Default: 4\n   - Range: Typically 2 to 16 would be reasonable\n\n2. `AxiStreamType`\n   - Purpose: Defines the structure of AXI4-Stream interfaces\n   - Default: local_pkg::axi4st_8_s\n   - Structure contains: {tdata[7:0], tkeep, tuser, tlast, tvalid}\n\n3. `AxiStreamWidth`\n   - Purpose: Width of tdata field\n   - Default: 8\n   - Note: This parameter is required but not used in implementation\n\n4. `FlopArbSel`\n   - Purpose: Optional pipeline register for arbitration\n   - Default: 0 (no flopping, to meet zero-latency requirement)\n   - Note: This parameter is required but not used in implementation\n\n5. `FlopOutput`\n   - Purpose: Optional pipeline register for output\n   - Default: 0 (no flopping, to meet zero-latency requirement)\n   - Note: This parameter is required but not used in implementation\n\nDerived Parameters (internal):\n1. `NumSelectBits`\n   - Purpose: Number of bits needed to encode selected input\n   - Value: $clog2(NumInputs)\n   - Used by local_rrarb module\n\nReasonable Parameter Combinations:\n1. Minimal Configuration:\n```systemverilog\n#(\n    .NumInputs(2),\n    .AxiStreamType(local_pkg::axi4st_8_s),\n    .AxiStreamWidth(8),\n    .FlopArbSel(0),\n    .FlopOutput(0)\n)\n```\n\n2. Typical Configuration:\n```systemverilog\n#(\n    .NumInputs(4),\n    .AxiStreamType(local_pkg::axi4st_8_s),\n    .AxiStreamWidth(8),\n    .FlopArbSel(0),\n    .FlopOutput(0)\n)\n```\n\n3. Large Configuration:\n```systemverilog\n#(\n    .NumInputs(8),\n    .AxiStreamType(local_pkg::axi4st_8_s),\n    .AxiStreamWidth(8),\n    .FlopArbSel(0),\n    .FlopOutput(0)\n)\n```\n\nParameter Constraints:\n1. NumInputs must be \u2265 2 (for meaningful arbitration)\n2. FlopArbSel and FlopOutput should be 0 to meet zero-latency requirement\n3. AxiStreamWidth should match the tdata width in AxiStreamType\n\nThe parameterization allows the module to be flexible while maintaining the core requirements of:\n- Zero-latency operation\n- Round-robin arbitration\n- Packet integrity preservation\n- Fair access to multiple inputsHow will data be processed and transformed between input and output? What registers and combinational logic are needed?\n [NEW STEP]\n \nLet me break down the data processing, transformation, and required logic elements:\n\nData Path Components:\n\n1. Input Selection Logic (Combinational):\n```systemverilog\n// Multiplexer for selected input to output\nalways_comb begin\n    outAxi4St = '0;  // Default value\n    if (|grant_out) begin  // If any input is granted\n        for (int i = 0; i < NumInputs; i++) begin\n            if (grant_out[i]) begin\n                outAxi4St = inAxi4St[i];  // Direct connection\n            end\n        end\n    end\nend\n```\n\n2. Ready Signal Generation (Combinational):\n```systemverilog\n// Generate ready signals for inputs\nalways_comb begin\n    inTready = '0;  // Default all not ready\n    for (int i = 0; i < NumInputs; i++) begin\n        inTready[i] = grant_out[i] && outTready;\n    end\nend\n```\n\nRequired Registers:\n\n1. Arbitration State:\n```systemverilog\nlogic [NumInputs-1:0] grant_out;      // From local_rrarb\nlogic [$clog2(NumInputs)-1:0] select_out;  // From local_rrarb\n```\n\n2. Packet Tracking:\n```systemverilog\nlogic in_packet;          // From local_axist_tfirst\nlogic update_valid;       // To local_rrarb\nlogic [NumInputs-1:0] requests_in;  // To local_rrarb\n```\n\nControl Logic:\n\n1. Request Generation:\n```systemverilog\nalways_comb begin\n    // Generate request vector from valid inputs not currently selected\n    for (int i = 0; i < NumInputs; i++) begin\n        requests_in[i] = inAxi4St[i].tvalid;\n    end\nend\n```\n\n2. Arbitration Update Control:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        update_valid <= 1'b1;  // Allow initial arbitration after reset\n    end else begin\n        update_valid <= !in_packet ||  // Not in packet\n                       (outAxi4St.tvalid && outTready && outAxi4St.tlast);  // End of packet\n    end\nend\n```\n\nKey Transformations:\n\n1. Zero-Latency Path:\n- Input \u2192 Output: Direct combinational path through multiplexer\n- No registers in the data path to maintain zero latency\n\n2. Control Path:\n```\nInput Valid Signals \u2192 Request Vector \u2192 Arbiter \u2192 Grant Vector \u2192 Ready Signals\n```\n\nRequired Module Instances:\n\n1. Round Robin Arbiter:\n```systemverilog\nlocal_rrarb #(\n    .NumInputs(NumInputs)\n) u_rrarb (\n    .clock,\n    .reset,\n    .update_valid,\n    .requests_in,\n    .grant_out,\n    .select_out\n);\n```\n\n2. Packet Boundary Detection:\n```systemverilog\nlocal_axist_tfirst #(\n    .AxiStreamType(AxiStreamType)\n) u_tfirst (\n    .clock,\n    .reset,\n    .inAxi4St(outAxi4St),\n    .inTready(outTready),\n    .in_packet,\n    .tfirst()  // Not used\n);\n```\n\nCritical Timing Paths:\n1. Input selection to output (combinational)\n2. Ready signal generation (combinational)\n3. Arbitration update logic (registered)\n\nThe design focuses on:\n- Maintaining zero-latency data path\n- Proper packet boundary handling\n- Fair arbitration using round-robin\n- Clean handshaking with ready/valid signals\n- Synchronous reset handlingWhat verification strategies would you recommend? What test scenarios and edge cases should be considered?\n [NEW STEP]\n \nLet me outline a comprehensive verification strategy for this AXI4-Stream Round Robin Arbiter:\n\n1. Testbench Architecture:\n```systemverilog\nmodule tb_dut;\n    // Clock and reset generation\n    // AXI4-Stream Driver for inputs\n    // AXI4-Stream Monitor for output\n    // Scoreboard for checking\n    // Coverage collection\nend\n```\n\n2. Test Scenarios:\n\nA. Basic Functionality Tests:\n```systemverilog\n// Single input active\ntask test_single_input;\n    // Activate only one input\n    // Verify correct output\nendtask\n\n// All inputs active\ntask test_all_inputs;\n    // Activate all inputs\n    // Verify round-robin behavior\nendtask\n```\n\nB. Packet Integrity Tests:\n```systemverilog\n// Complete packet transfer\ntask test_packet_transfer;\n    // Send complete packet on one input\n    // Verify packet maintains integrity\nendtask\n\n// Multiple packet sizes\ntask test_variable_packets;\n    // Test minimum (1 beat)\n    // Test typical (16-64 beats)\n    // Test maximum size packets\nendtask\n```\n\n3. Edge Cases:\n\nA. Timing Edge Cases:\n```systemverilog\n// Ready/Valid timing\ntask test_ready_valid_timing;\n    // Test ready before valid\n    // Test valid before ready\n    // Test simultaneous ready/valid\nendtask\n\n// Reset scenarios\ntask test_reset_conditions;\n    // Reset during packet transfer\n    // Reset between packets\n    // Reset with multiple active requests\nendtask\n```\n\nB. Arbitration Edge Cases:\n```systemverilog\n// Arbitration fairness\ntask test_arbitration_fairness;\n    // Verify no starvation\n    // Check round-robin sequence\n    // Test priority after reset\nendtask\n\n// Switching conditions\ntask test_switching_conditions;\n    // Switch after packet completion\n    // Attempt switch during packet\n    // Switch with zero-wait cycles\nendtask\n```\n\n4. Coverage Metrics:\n\nA. Functional Coverage:\n```systemverilog\ncovergroup cg_arbitration;\n    // Cover all input combinations\n    cp_inputs: coverpoint active_inputs {\n        bins single_input[] = {1'b1};\n        bins multiple_inputs[] = {2'h3, 2'h5, 2'h6, 2'h7};\n        bins all_inputs = {2'hF};\n    }\n    \n    // Cover arbitration transitions\n    cp_transitions: coverpoint selected_input {\n        bins transitions[] = (0,1,2,3 => 0,1,2,3);\n    }\nendgroup\n```\n\nB. Protocol Coverage:\n```systemverilog\ncovergroup cg_protocol;\n    // Cover ready/valid handshaking\n    cp_handshake: coverpoint {ready, valid} {\n        bins valid_first = (2'b10 => 2'b11);\n        bins ready_first = (2'b01 => 2'b11);\n    }\n    \n    // Cover packet characteristics\n    cp_packet: coverpoint packet_size {\n        bins small = {[1:4]};\n        bins medium = {[5:16]};\n        bins large = {[17:32]};\n    }\nendgroup\n```\n\n5. Assertion Checks:\n\nA. Protocol Assertions:\n```systemverilog\n// Packet integrity\nproperty packet_integrity;\n    @(posedge clock) disable iff (reset)\n    $rose(outAxi4St.tvalid) |-> \n        !$fell(outAxi4St.tvalid) until outAxi4St.tlast;\nendproperty\n\n// No switching during packet\nproperty no_switch_during_packet;\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && !outAxi4St.tlast) |->\n        $stable(grant_out);\nendproperty\n```\n\nB. Fairness Assertions:\n```systemverilog\n// Round-robin ordering\nproperty round_robin_order;\n    @(posedge clock) disable iff (reset)\n    $changed(grant_out) |->\n        next_grant == expected_round_robin_winner;\nendproperty\n\n// No starvation\nproperty no_starvation;\n    @(posedge clock) disable iff (reset)\n    requests_in[*100] |-> grant_out;\nendproperty\n```\n\n6. Performance Tests:\n```systemverilog\ntask test_performance;\n    // Measure throughput\n    // Check zero-latency requirement\n    // Verify back-to-back transfers\n    // Test maximum sustainable bandwidth\nendtask\n```\n\n7. Random Testing:\n```systemverilog\ntask random_test;\n    // Randomize input patterns\n    // Randomize packet sizes\n    // Randomize ready/valid timing\n    // Check for protocol violations\nendtask\n```\n\n8. Stress Testing:\n```systemverilog\ntask stress_test;\n    // Maximum load conditions\n    // Rapid toggling of requests\n    // Long-running tests\n    // Corner case combinations\nendtask\n```\n\nSpecial Considerations:\n1. Verify zero-latency requirement is met\n2. Check round-robin fairness over long sequences\n3. Verify packet boundaries are respected\n4. Test all possible input combinations\n5. Verify proper reset behavior\n6. Check for metastability conditions\n7. Verify no glitches on output signals\n\nThese verification strategies ensure:\n- Functional correctness\n- Protocol compliance\n- Performance requirements\n- Robustness\n- Fair arbitration\n- Complete coverage\n- Edge case handlingWhat are the clocking, latency and throughput requirements? Are there specific timing constraints? What signals need to be reset? Should reset be synchronous or asynchronous?\n [NEW STEP]\n \nLet me break down the timing and reset requirements based on the problem description:\n\nClocking Requirements:\n1. Single Clock Domain:\n```systemverilog\ninput logic clock     // Primary system clock\n```\n- All operations are synchronous to this clock\n- No clock domain crossing requirements mentioned\n- Single clock simplifies timing analysis\n\nLatency Requirements:\n1. Zero-Latency Path:\n```systemverilog\n// Direct combinational path required from input to output\nalways_comb begin\n    outAxi4St = inAxi4St[select_out];  // Zero cycle latency\nend\n```\n- Must have zero cycles between input and output\n- No pipeline registers allowed in data path\n- Critical timing path to consider\n\nThroughput Requirements:\n1. Maximum Throughput:\n- Can transfer one data beat per clock cycle\n- No artificial bandwidth limitations\n- Back-to-back transfers must be supported\n```systemverilog\n// Example maximum throughput sequence\n// Clock Cycle    : 1    2    3    4    \n// tvalid        : 1    1    1    1    \n// tready        : 1    1    1    1    \n// Transfer      : Yes  Yes  Yes  Yes  \n```\n\nReset Requirements:\n1. Synchronous Reset:\n```systemverilog\ninput logic reset    // Synchronous reset, active high\n```\n- Problem explicitly specifies synchronous reset\n- All registers should use synchronous reset\n\n2. Signals Requiring Reset:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Control signals\n        update_valid <= 1'b1;    // Enable initial arbitration\n        \n        // State tracking\n        in_packet <= 1'b0;       // Not in packet initially\n        \n        // Other internal registers needed for control\n    end\n    else begin\n        // Normal operation\n    end\nend\n```\n\nTiming Constraints:\n1. Critical Paths:\n```\nInput \u2192 Mux \u2192 Output (combinational)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Input   \u2502 --> \u2502 Mux \u2502 --> \u2502 Output \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nMax Delay = Tclock - Tsetup - Tmargin\n```\n\n2. Setup/Hold Requirements:\n```systemverilog\n// All registered signals\nalways_ff @(posedge clock) begin\n    // Must meet setup time before clock edge\n    // Must meet hold time after clock edge\nend\n```\n\n3. Clock Constraints:\n```tcl\n# Example SDC constraints\ncreate_clock -name clock -period 10\nset_input_delay -clock clock 2 [all_inputs]\nset_output_delay -clock clock 2 [all_outputs]\n```\n\nPerformance Considerations:\n1. Zero-Latency Path:\n- Critical timing path through multiplexer\n- May limit maximum clock frequency\n- Careful placement and routing needed\n\n2. Arbitration Logic:\n- Can be pipelined as needed\n- Not in critical data path\n- Can be optimized for timing\n\nTiming Analysis Requirements:\n1. Static Timing Analysis:\n```\n- Setup/Hold checks\n- Maximum combinational delay\n- Clock-to-Q delays\n- Input/Output delays\n```\n\n2. Critical Paths to Analyze:\n```\n1. Input data \u2192 Output data (zero cycle)\n2. Ready signal generation\n3. Arbitration logic\n4. Reset synchronization\n```\n\nReset Strategy Recommendations:\n1. Synchronous Reset Implementation:\n```systemverilog\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        // Reset to known good state\n        // Clear control signals\n        // Initialize state machines\n    end\n    else begin\n        // Normal operation\n    end\nend\n```\n\n2. Reset Values:\n- Control signals: Inactive/safe state\n- State machines: Idle state\n- Output signals: Default/inactive values\n\n3. Reset Recovery:\n- Must handle proper restart after reset\n- Must maintain packet boundaries\n- Must initialize arbitration fairly\n\nKey Timing Requirements Summary:\n1. Zero cycle latency from input to output\n2. Single clock domain operation\n3. Synchronous reset\n4. Maximum throughput capability\n5. Clean arbitration switching\n6. Proper reset initialization\n7. Meeting setup/hold requirements\n8. Managing combinational delaysWhat test scenarios are needed? How will assertions be used to catch issues?\n [NEW STEP]\n \nLet me outline comprehensive test scenarios and assertions needed for this design:\n\n1. Basic Functional Test Scenarios:\n```systemverilog\n// Single input tests\ntask test_basic_single_input;\n    // Test each input individually\n    for (int i = 0; i < NumInputs; i++) begin\n        // Send single packet\n        // Verify correct output\n        // Check zero latency\n    end\nendtask\n\n// Multiple input tests\ntask test_basic_multiple_inputs;\n    // Test concurrent requests\n    // Verify round-robin behavior\n    // Check packet integrity\nendtask\n```\n\n2. Protocol Compliance Tests:\n```systemverilog\n// AXI4-Stream protocol tests\ntask test_protocol_compliance;\n    // Test TVALID before TREADY\n    // Test TREADY before TVALID\n    // Test simultaneous TVALID/TREADY\n    // Verify TLAST handling\nendtask\n\n// Packet integrity tests\ntask test_packet_boundaries;\n    // Single-beat packets\n    // Multi-beat packets\n    // Back-to-back packets\n    // Interrupted packets\nendtask\n```\n\n3. Critical Assertions:\n\nA. Protocol Assertions:\n```systemverilog\n// Valid/Ready Handshaking\nproperty valid_ready_handshake;\n    @(posedge clock) disable iff (reset)\n    outAxi4St.tvalid && !outTready |=> outAxi4St.tvalid;\nendproperty\nassert property(valid_ready_handshake);\n\n// Packet Integrity\nproperty packet_continuity;\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && !outAxi4St.tlast) |=>\n        outAxi4St.tvalid until outAxi4St.tlast;\nendproperty\nassert property(packet_continuity);\n```\n\nB. Arbitration Assertions:\n```systemverilog\n// Round Robin Fairness\nproperty round_robin_order;\n    @(posedge clock) disable iff (reset)\n    $fell(in_packet) |-> \n        next_grant != current_grant;\nendproperty\nassert property(round_robin_order);\n\n// No Switching During Packet\nproperty stable_selection;\n    @(posedge clock) disable iff (reset)\n    (outAxi4St.tvalid && !outAxi4St.tlast) |->\n        $stable(grant_out);\nendproperty\nassert property(stable_selection);\n```\n\n4. Corner Case Tests:\n```systemverilog\ntask test_corner_cases;\n    // Reset during packet transfer\n    test_reset_during_packet();\n    \n    // Backpressure scenarios\n    test_backpressure();\n    \n    // All inputs requesting simultaneously\n    test_full_contention();\n    \n    // Single-cycle packets\n    test_minimum_packet();\nendtask\n```\n\n5. Performance Tests:\n```systemverilog\ntask test_performance;\n    // Zero latency verification\n    test_latency();\n    \n    // Maximum throughput\n    test_throughput();\n    \n    // Back-to-back transfers\n    test_consecutive_transfers();\nendtask\n```\n\n6. Error Checking Assertions:\n```systemverilog\n// Zero Latency Check\nproperty zero_latency;\n    @(posedge clock) disable iff (reset)\n    $changed(inAxi4St[select_out]) |->\n        $changed(outAxi4St);\nendproperty\nassert property(zero_latency);\n\n// Ready Generation\nproperty ready_generation;\n    @(posedge clock) disable iff (reset)\n    foreach(inTready[i]) \n        inTready[i] == (grant_out[i] && outTready);\nendproperty\nassert property(ready_generation);\n```\n\n7. Coverage Points:\n```systemverilog\ncovergroup cg_arbitration;\n    // Input combinations\n    cp_inputs: coverpoint requests_in {\n        bins single_requests[] = {[1:NumInputs]};\n        bins multiple_requests = {[2:NumInputs]};\n        bins all_requests = {2**NumInputs-1};\n    }\n    \n    // Arbitration transitions\n    cp_transitions: coverpoint select_out {\n        bins transitions[] = ([0:NumInputs-1] => [0:NumInputs-1]);\n    }\n    \n    // Cross coverage\n    cross_input_select: cross cp_inputs, cp_transitions;\nendgroup\n```\n\n8. Randomized Tests:\n```systemverilog\nclass random_stimulus;\n    rand bit [NumInputs-1:0] active_inputs;\n    rand int packet_size;\n    rand int backpressure_probability;\n    \n    constraint valid_packet_size {\n        packet_size inside {[1:100]};\n    }\n    \n    task generate_stimulus();\n        // Generate random patterns\n        // Apply constraints\n        // Check results\n    endtask\nendclass\n```\n\n9. System-Level Tests:\n```systemverilog\ntask test_system_integration;\n    // Multiple back-to-back packets\n    // Mixed packet sizes\n    // Variable delays\n    // Stressed conditions\nendtask\n```\n\n10. Reset and Recovery Tests:\n```systemverilog\ntask test_reset_scenarios;\n    // Reset during idle\n    // Reset during transfer\n    // Reset during arbitration\n    // Multiple reset pulses\nendtask\n```\n\nKey Testing Focus Areas:\n1. Zero-latency verification\n2. Round-robin fairness\n3. Packet integrity\n4. Protocol compliance\n5. Performance metrics\n6. Corner cases\n7. Error conditions\n8. Reset behavior\n\nTest Environment Requirements:\n1. Self-checking testbench\n2. Automated regression\n3. Coverage analysis\n4. Performance measurements\n5. Protocol checkers\n6. Assertion monitoring\n7. Error injection\n8. Stress testing\n\nSuccess Criteria:\n1. All assertions pass\n2. 100% functional coverage\n3. Zero protocol violations\n4. Performance requirements met\n5. All corner cases verified\n6. No packet corruption\n7. Proper arbitration order\n8. Clean reset behaviorWhat distinct functional blocks or submodules would logically divide this design? For each submodule identified, what specific task does it perform?\n [NEW STEP]\n \nLet me break down the design into logical functional blocks/submodules:\n\n1. Round Robin Arbiter Block (Given):\n```systemverilog\nmodule local_rrarb #(params) (\n    input  logic clock,\n    input  logic reset,\n    input  logic update_valid,\n    input  logic [NumInputs-1:0] requests_in,\n    output logic [NumInputs-1:0] grant_out,\n    output logic [$clog2(NumInputs)-1:0] select_out\n);\n```\nPurpose:\n- Implements round-robin arbitration\n- Maintains fairness across inputs\n- Generates grant signals\n- Provides encoded selection\n\n2. Packet Boundary Detector (Given):\n```systemverilog\nmodule local_axist_tfirst #(params) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    input  logic inTready,\n    output logic tfirst,\n    output logic in_packet\n);\n```\nPurpose:\n- Detects packet boundaries\n- Tracks active packet status\n- Identifies first beat of packets\n\n3. Input Request Handler:\n```systemverilog\nmodule input_request_handler #(params) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] requests_in,\n    input  logic in_packet,\n    output logic update_valid\n);\n```\nPurpose:\n- Generates request vector\n- Manages arbitration updates\n- Tracks valid inputs\n- Handles packet boundaries\n\n4. AXI4-Stream Multiplexer:\n```systemverilog\nmodule axi4stream_mux #(params) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0] grant_out,\n    input  logic outTready,\n    output AxiStreamType outAxi4St,\n    output logic [NumInputs-1:0] inTready\n);\n```\nPurpose:\n- Multiplexes selected input to output\n- Manages ready signaling\n- Maintains zero latency\n- Routes data path\n\n5. Control State Machine:\n```systemverilog\nmodule control_fsm #(params) (\n    input  logic clock,\n    input  logic reset,\n    input  logic in_packet,\n    input  logic [NumInputs-1:0] grant_out,\n    output logic update_valid,\n    input  AxiStreamType outAxi4St,\n    input  logic outTready\n);\n```\nPurpose:\n- Manages control flow\n- Handles reset conditions\n- Controls arbitration timing\n- Ensures packet integrity\n\nHere's how these blocks interconnect:\n\n```\n                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502  Control State   \u2502\n                            \u2502    Machine       \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n                                     \u2502 update_valid\n                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Input      \u2502requests_in \u2502   Round Robin  \u2502\n\u2502   Request    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    Arbiter     \u2502\n\u2502   Handler    \u2502           \u2502  (local_rrarb)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                           \u2502\n       \u2502                    grant_out\n       \u2502                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AXI4-Stream \u2502            \u2502   Packet       \u2502\n\u2502  Multiplexer \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   Boundary     \u2502\n\u2502              \u2502           \u2502   Detector      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nAdditional Supporting Logic:\n\n6. Ready Signal Generator:\n```systemverilog\n// Part of AXI4-Stream Multiplexer\nalways_comb begin\n    for (int i = 0; i < NumInputs; i++) begin\n        inTready[i] = grant_out[i] && outTready;\n    end\nend\n```\nPurpose:\n- Generates ready signals\n- Handles backpressure\n- Maintains handshaking\n\n7. Reset Synchronizer:\n```systemverilog\nmodule reset_sync (\n    input  logic clock,\n    input  logic async_reset,\n    output logic sync_reset\n);\n```\nPurpose:\n- Ensures clean reset\n- Synchronizes reset signal\n- Prevents metastability\n\nIntegration Points:\n\n1. Data Path Integration:\n```systemverilog\n// Zero latency path\nassign outAxi4St = inAxi4St[select_out];\n```\n\n2. Control Path Integration:\n```systemverilog\n// Arbitration control\nassign update_valid = !in_packet || \n                     (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n```\n\n3. Status Integration:\n```systemverilog\n// Packet tracking\nassign packet_active = in_packet || outAxi4St.tvalid;\n```\n\nKey Features of Modularization:\n\n1. Clear Separation of Concerns:\n- Control logic separate from data path\n- Arbitration separate from multiplexing\n- Status tracking separate from control\n\n2. Reusable Components:\n- Multiplexer can be used independently\n- Arbitrator is self-contained\n- Packet detector is standalone\n\n3. Maintainability:\n- Each module has specific function\n- Easy to modify individual blocks\n- Clear interfaces between modules\n\n4. Testability:\n- Modules can be tested independently\n- Clear boundaries for verification\n- Simplified debug process\n\nThis modular approach provides:\n- Clean design structure\n- Easy maintenance\n- Simple verification\n- Clear functionality\n- Flexible modification\n- Robust operationWrite a System verilog code for each of the submodules specified. What are the critical interfaces between these submodules?\n [NEW STEP]\n \nI'll break down each submodule and then show the critical interfaces between them. Note that local_rrarb and local_axist_tfirst are given and their internals are not revealed.\n\n1. Top Module (dut):\n```systemverilog\nmodule dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned NumInputs = 4,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0\n) (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready\n);\n\n    // Internal signals\n    logic [NumInputs-1:0] grant_out;\n    logic [$clog2(NumInputs)-1:0] select_out;\n    logic update_valid;\n    logic [NumInputs-1:0] requests_in;\n    logic in_packet;\n    \n    // Instantiate submodules\n    input_request_handler #(\n        .NumInputs(NumInputs),\n        .AxiStreamType(AxiStreamType)\n    ) u_req_handler (\n        .inAxi4St(inAxi4St),\n        .requests_in(requests_in),\n        .in_packet(in_packet),\n        .update_valid(update_valid)\n    );\n\n    local_rrarb #(\n        .NumInputs(NumInputs)\n    ) u_rrarb (\n        .clock(clock),\n        .reset(reset),\n        .update_valid(update_valid),\n        .requests_in(requests_in),\n        .grant_out(grant_out),\n        .select_out(select_out)\n    );\n\n    axi4stream_mux #(\n        .NumInputs(NumInputs),\n        .AxiStreamType(AxiStreamType)\n    ) u_mux (\n        .inAxi4St(inAxi4St),\n        .grant_out(grant_out),\n        .outTready(outTready),\n        .outAxi4St(outAxi4St),\n        .inTready(inTready)\n    );\n\n    local_axist_tfirst #(\n        .AxiStreamType(AxiStreamType)\n    ) u_tfirst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(outAxi4St),\n        .inTready(outTready),\n        .tfirst(),  // Unused\n        .in_packet(in_packet)\n    );\n\nendmodule\n```\n\n2. Input Request Handler:\n```systemverilog\nmodule input_request_handler #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumInputs = 4\n) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] requests_in,\n    input  logic in_packet,\n    output logic update_valid\n);\n\n    // Generate requests from valid inputs\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++) begin\n            requests_in[i] = inAxi4St[i].tvalid;\n        end\n    end\n\n    // Generate update_valid based on packet status\n    always_comb begin\n        update_valid = !in_packet ||\n                      (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n    end\n\nendmodule\n```\n\n3. AXI4-Stream Multiplexer:\n```systemverilog\nmodule axi4stream_mux #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned NumInputs = 4\n) (\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    input  logic [NumInputs-1:0] grant_out,\n    input  logic outTready,\n    output AxiStreamType outAxi4St,\n    output logic [NumInputs-1:0] inTready\n);\n\n    // Zero-latency multiplexing\n    always_comb begin\n        outAxi4St = '0;\n        for (int i = 0; i < NumInputs; i++) begin\n            if (grant_out[i]) begin\n                outAxi4St = inAxi4St[i];\n            end\n        end\n    end\n\n    // Generate ready signals\n    always_comb begin\n        for (int i = 0; i < NumInputs; i++) begin\n            inTready[i] = grant_out[i] && outTready;\n        end\n    end\n\nendmodule\n```\n\nCritical Interfaces:\n\n1. Between Input Request Handler and Round Robin Arbiter:\n```systemverilog\n// Critical interface signals\nlogic [NumInputs-1:0] requests_in;  // Input requests\nlogic update_valid;                 // Update arbitration\n```\nPurpose:\n- Request generation for arbitration\n- Control when arbitration updates\n\n2. Between Round Robin Arbiter and Multiplexer:\n```systemverilog\n// Critical interface signals\nlogic [NumInputs-1:0] grant_out;    // Selected input\nlogic [$clog2(NumInputs)-1:0] select_out;  // Encoded selection\n```\nPurpose:\n- Selection control\n- Input routing\n\n3. Between Multiplexer and Packet Boundary Detector:\n```systemverilog\n// Critical interface signals\nAxiStreamType outAxi4St;  // Output stream\nlogic outTready;          // Output ready\nlogic in_packet;          // Packet status\n```\nPurpose:\n- Packet tracking\n- Flow control\n\n4. AXI4-Stream Interface:\n```systemverilog\n// Critical interface signals\nAxiStreamType [NumInputs-1:0] inAxi4St;  // Input streams\nlogic [NumInputs-1:0] inTready;          // Input ready signals\nAxiStreamType outAxi4St;                 // Output stream\nlogic outTready;                         // Output ready\n```\nPurpose:\n- Data transfer\n- Flow control\n- Protocol compliance\n\nInterface Timing Requirements:\n```systemverilog\n// Zero-latency path requirement\nalways_comb begin\n    outAxi4St = inAxi4St[select_out];  // Must be combinational\nend\n\n// Ready signal generation\nalways_comb begin\n    inTready = grant_out & {NumInputs{outTready}};  // Must be combinational\nend\n```\n\nCritical Considerations:\n1. Zero-latency requirement\n2. Combinational paths\n3. Protocol compliance\n4. Packet integrity\n5. Proper handshaking\n\nThese modules and interfaces ensure:\n- Clean data flow\n- Proper control\n- Protocol compliance\n- Performance requirements\n- Modular design\n- Easy maintenance\n- Clear verification boundaries\n\n    Integrate the submodules into one working module in SystemVerilog. Include all submodules in your final answer as one workingf module. Leave no comment referencing previous answers. Remembering the description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n\nAdditionally, you are required to use the following module (without revealing the internals) to perform round robin arbitration. The outputs of local_rrarb (grant_out, and select_out) are held and will not change unless input update_valid=1. When update_valid=1, a requests_in (vector of request valid bits) is also set, and a new arbitration winner is on the outputs -- grant_out is a 1-hot vector, and select_out is the encoded winner with values between 0 and NumInputs-1.\n\nmodule local_rrarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n\nAdditionally, you are required to use the folowing module (without revealing the internals) to determine when a packet or frame starts on any of the inputs.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining how to drive helper module local_rrarb's input vector for \"update_valid\". For example, if you were to connect dut's output outAxist4St and outTready to an instance of local_axist_tfirst, you could know if the output is in the middle of sending a packet:\n\nlogic in_packet_on_outAxi4St; // from local_axist_tfirst module output\nlocig update_valid; // update_valid to input of local_rrarb module\n\nalways_ff @(posedge clock) begin\n\n  update_valid <=\n    // we are not in a packet now, safe to set update_valid=1 next cycle\n    in_packet_on_outaxi4st ||\n    // OR, we just transfered the final outbound data phit, safe to set update_valid=1 next cycle\n    (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n\nend\n\n    ======\n    \n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rrarb_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb_test.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb_test;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  oclib_axist_rrarb\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : oclib_axist_rrarb_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/local_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = local_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = local_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/local_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : tb\n",
    "name": "test_axist_rrarb_4"
  }
]