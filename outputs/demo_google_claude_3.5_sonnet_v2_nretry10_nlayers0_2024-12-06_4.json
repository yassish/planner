[
  {
    "index": 3,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n)(\n  input logic clock,\n  input logic reset,\n  \n  input AxiStreamType inAxi4St,\n  output logic inTready,\n  input logic [ExtraDataWidth-1:0] inExtra,\n  \n  output AxiStreamType outAxi4St, \n  input logic outTready,\n  output logic [ExtraDataWidth-1:0] outExtra,\n  \n  input logic [7:0] i_rate_numerator,\n  input logic [7:0] i_rate_denominator,\n  input logic i_rate_by_frame\n);\n\n  logic [15:0] credit_count;\n  logic [15:0] next_credit_count;\n  logic frame_started;\n  logic rate_exceeded;\n  logic hold_back;\n  logic last_seen;\n  \n  AxiStreamType pipe_in;\n  logic pipe_in_ready;\n  \n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(pipe_in),\n    .inTready(pipe_in_ready),\n    .pipeAxi4St(),\n    .pipeTready(),\n    .outAxi4St(outAxi4St),\n    .outTready(outTready)\n  );\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      credit_count <= '0;\n      frame_started <= 1'b0;\n      last_seen <= 1'b0;\n    end else begin\n      credit_count <= next_credit_count;\n      if (inAxi4St.tvalid && inTready) begin\n        frame_started <= 1'b1;\n        if (inAxi4St.tlast) begin\n          frame_started <= 1'b0;\n          last_seen <= 1'b1;\n        end\n      end else if (!inAxi4St.tvalid) begin\n        last_seen <= 1'b0;\n      end\n    end\n  end\n\n  always_comb begin\n    next_credit_count = credit_count;\n    \n    if (inAxi4St.tvalid && inTready) begin\n      next_credit_count = credit_count + i_rate_denominator - i_rate_numerator;\n    end else if (credit_count > i_rate_denominator) begin\n      next_credit_count = credit_count - i_rate_numerator;\n    end\n  end\n\n  always_comb begin\n    rate_exceeded = (credit_count >= i_rate_denominator);\n    hold_back = rate_exceeded && (i_rate_by_frame ? last_seen : 1'b1);\n    \n    pipe_in = inAxi4St;\n    pipe_in.tvalid = inAxi4St.tvalid && !hold_back;\n    inTready = pipe_in_ready && !hold_back;\n    \n    outExtra = inExtra;\n  end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_3",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_0/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_0/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.303 MB sources in 19 modules, into 0.310 MB in 16 C++ files needing 0.002 MB\n- Verilator: Walltime 2.088 s (elab=0.006, cvt=0.021, bld=1.983); cpu 0.707 s on 64 threads; alloced 150.902 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           419780000 TOP.tb.main: First 100 frames, mon m_tactive_count=13238, m_tinactive_count=28730, calc rate(pct)=32\n[10000101000] %Error: tb.sv:1688: Assertion failed in TOP.tb.uCONTROL.main: stimulusDone=(0) after 1000000 cycles\n%Error: tb.sv:1688: Verilog $stop\nAborting...\n",
    "stderr": "%Warning-TIMESCALEMOD: tb.sv:22:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n   22 | package oclib_assert_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n                       ... For warning description see https://verilator.org/warn/TIMESCALEMOD?v=5.028\n                       ... Use \"/* verilator lint_off TIMESCALEMOD */\" and lint_on around source to disable this message.\n%Warning-TIMESCALEMOD: tb.sv:686:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n  686 | package oclib_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1158:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1158 | package oclib_memory_bist_pkg;\n      |         ^~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1202:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1202 | package oclib_uart_pkg;\n      |         ^~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1221:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1221 | package ocsim_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1461:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1461 | package ocsim_packet_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1628:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1628 | module ocsim_tb_control #(\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1773:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1773 | module ocsim_axist_driver\n      |        ^~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2088:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2088 | module ocsim_axist_monitor\n      |        ^~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2363:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2363 | module oclib_axist_rate_limit\n      |        ^~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2478:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2478 | module oclib_axist_rate_limit_test;\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2822:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2822 | package local_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3293:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3293 | module oclib_ready_valid_pipe_core\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3351:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3351 | module local_axist_pipe\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3447:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3447 | module tb;\n      |        ^~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-REALCVT: tb.sv:3650:75: Implicit conversion of real to integer\n 3650 |                $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n      |                                                                           ^~~~~~~~~~~~~~\n",
    "pass": false,
    "score": 64,
    "warnings": 16,
    "errors": 0,
    "runtime": 22.842873334884644,
    "batch_iter": 0,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_0",
    "start_time": 1733526071.9779587,
    "stop_time": 1733526094.820832
  },
  {
    "index": 0,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8\n) (\n  input  logic        clock,\n  input  logic        reset,\n  input  AxiStreamType inAxi4St,\n  output logic        inTready,\n  output AxiStreamType outAxi4St,\n  input  logic        outTready,\n  output logic        outParsedValid,\n  output logic [47:0] outParsedDestMac,  \n  output logic [47:0] outParsedSourceMac\n);\n\n  // State machine states\n  typedef enum logic [1:0] {\n    IDLE,\n    CAPTURE,\n    WAIT_END\n  } state_t;\n  \n  state_t state_q, state_d;\n  \n  // Counters and registers\n  logic [3:0] byte_cnt_q, byte_cnt_d;\n  logic [47:0] dest_mac_q, dest_mac_d;\n  logic [47:0] source_mac_q, source_mac_d;\n  logic parsed_valid_q, parsed_valid_d;\n  \n  // Pass through AXI4 stream\n  assign outAxi4St = inAxi4St;\n  \n  // Ready when downstream is ready\n  assign inTready = outTready;\n  \n  // Output assignments\n  assign outParsedValid = parsed_valid_q;\n  assign outParsedDestMac = dest_mac_q;\n  assign outParsedSourceMac = source_mac_q;\n\n  // Next state and output logic\n  always_comb begin\n    // Default assignments\n    state_d = state_q;\n    byte_cnt_d = byte_cnt_q;\n    dest_mac_d = dest_mac_q;\n    source_mac_d = source_mac_q;\n    parsed_valid_d = 1'b0;\n\n    case (state_q)\n      IDLE: begin\n        if (inAxi4St.tvalid && outTready) begin\n          state_d = CAPTURE;\n          byte_cnt_d = 'd1;\n          dest_mac_d = {dest_mac_q[39:0], inAxi4St.tdata};\n        end\n      end\n\n      CAPTURE: begin\n        if (inAxi4St.tvalid && outTready) begin\n          byte_cnt_d = byte_cnt_q + 'd1;\n          \n          if (byte_cnt_q <= 'd5) begin\n            dest_mac_d = {dest_mac_q[39:0], inAxi4St.tdata};\n          end\n          else if (byte_cnt_q <= 'd11) begin\n            source_mac_d = {source_mac_q[39:0], inAxi4St.tdata};\n          end\n          \n          if (byte_cnt_q == 'd11) begin\n            parsed_valid_d = 1'b1;\n            state_d = WAIT_END;\n          end\n        end\n      end\n\n      WAIT_END: begin\n        if (inAxi4St.tvalid && outTready && inAxi4St.tlast) begin\n          state_d = IDLE;\n        end\n      end\n\n      default: state_d = IDLE;\n    endcase\n  end\n\n  // Sequential logic\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      state_q <= IDLE;\n      byte_cnt_q <= '0;\n      dest_mac_q <= '0;\n      source_mac_q <= '0;\n      parsed_valid_q <= 1'b0;\n    end else begin\n      state_q <= state_d;\n      byte_cnt_q <= byte_cnt_d;\n      dest_mac_q <= dest_mac_d;\n      source_mac_q <= source_mac_d;\n      parsed_valid_q <= parsed_valid_d;\n    end\n  end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output sometime after the first data phit on inAxi4St.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- outParsedValid should be 1 for a single cycle when outParsedDestMac and outParsedSourceMac are valid.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_eth_parser_lite_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_eth_parser_lite_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// -- Custom testbench for ./dut.sv\n// -- Only checks outParsedValid, and that outAxi4St is correct.\n// -- Does not check that outParsedValid=1 on first data phit of outAxi4St.\n// -- Uses ./dut.sv.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  // TODO(drew): This check is removed for this test.\n  ////`OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  logic                 prev_outParsedValid;\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    prev_outParsedValid <= outParsedValid; // add this hook so we only look at this once per frame.\n    if (!reset && outParsedValid && !prev_outParsedValid) begin\n      // In this tb, we skip the outTready=1 qualifier.\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: observed outParsedDestMac=0x%0x outParsedSourceMac=0x%0x\",\n                 $realtime, outParsedDestMac, outParsedSourceMac);\n      end\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_lite_2",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_1/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_1/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.312 MB sources in 19 modules, into 0.229 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 2.033 s (elab=0.006, cvt=0.034, bld=1.843); cpu 0.199 s on 64 threads; alloced 150.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           420030000 TOP.tb.main: Monitor queues: mon queue size=0, drv queue size=0\n           420050000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n           420050000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n           420055000 TOP.tb.u_drv: num_packets_driven=100\n           420055000 TOP.tb.u_mon: num_packets_received=100\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 420us; walltime 0.331 s; speed 1.278 ms/s\n- Verilator: cpu 0.329 s on 1 threads; alloced 505 MB\n",
    "stderr": "",
    "pass": true,
    "score": 100,
    "warnings": 0,
    "errors": 0,
    "runtime": 2.4438769817352295,
    "batch_iter": 1,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_1",
    "start_time": 1733526071.9990747,
    "stop_time": 1733526074.4429517
  },
  {
    "index": 4,
    "dut": "module dut\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8\n  )\n  (\n  input logic clock,\n  input logic reset,\n  \n  input AxiStreamType inAxi4St,\n  output logic inTready,\n  \n  output AxiStreamType outAxi4St,\n  input logic outTready,\n  \n  output logic outParsedValid,\n  output logic [47:0] outParsedDestMac,\n  output logic [47:0] outParsedSourceMac\n  );\n\n  localparam int NumDelayStages = (48+AxiStreamWidth-1)/AxiStreamWidth; \n\n  logic tfirst;\n  logic in_packet;\n  logic [5:0] byte_count;\n  logic [47:0] dest_mac_reg;\n  logic [47:0] source_mac_reg;\n  \n  AxiStreamType [NumDelayStages:0] pipe_axi4st;\n  logic [NumDelayStages:0] pipe_tready;\n  \n  // Detect start of packet\n  local_axist_tfirst #(\n    .AxiStreamType(AxiStreamType)\n  ) u_tfirst (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .tfirst(tfirst),\n    .in_packet(in_packet)\n  );\n  \n  // Pipeline for output alignment\n  local_axist_pipe #(\n    .NumStages(NumDelayStages),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .pipeAxi4St(pipe_axi4st),\n    .pipeTready(pipe_tready),\n    .outAxi4St(outAxi4St),\n    .outTready(outTready)\n  );\n\n  // Parse MAC addresses\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      byte_count <= '0;\n      dest_mac_reg <= '0;\n      source_mac_reg <= '0;\n      outParsedValid <= 1'b0;\n    end else begin\n      outParsedValid <= 1'b0;\n      \n      if (inAxi4St.tvalid && inTready) begin\n        if (tfirst) begin\n          byte_count <= '0;\n        end else if (byte_count < 6'd12) begin\n          byte_count <= byte_count + 1'b1;\n        end\n        \n        case (byte_count)\n          6'd0: dest_mac_reg[47:40] <= inAxi4St.tdata;\n          6'd1: dest_mac_reg[39:32] <= inAxi4St.tdata;\n          6'd2: dest_mac_reg[31:24] <= inAxi4St.tdata;\n          6'd3: dest_mac_reg[23:16] <= inAxi4St.tdata;\n          6'd4: dest_mac_reg[15:8] <= inAxi4St.tdata;\n          6'd5: dest_mac_reg[7:0] <= inAxi4St.tdata;\n          6'd6: source_mac_reg[47:40] <= inAxi4St.tdata;\n          6'd7: source_mac_reg[39:32] <= inAxi4St.tdata;\n          6'd8: source_mac_reg[31:24] <= inAxi4St.tdata;\n          6'd9: source_mac_reg[23:16] <= inAxi4St.tdata;\n          6'd10: source_mac_reg[15:8] <= inAxi4St.tdata;\n          6'd11: begin\n            source_mac_reg[7:0] <= inAxi4St.tdata;\n            outParsedValid <= 1'b1;\n          end\n          default: ;\n        endcase\n      end\n    end\n  end\n\n  assign outParsedDestMac = dest_mac_reg;\n  assign outParsedSourceMac = source_mac_reg;\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\nAdditionally, you are required to use the folowing module (internal contents not shown) to determine when a packet or frame starts.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining when to start parsing or extracting contents from a frame. For example:\n\nlogic first_byte_of_dest_mac_valid; // if 1, indicates dest mac [47:40] present on inAxi4St.tdata.\nassign first_byte_of_dest_mac_valid = tfirst && in_packet;\n\n\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/local_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_4",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_2/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_2/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.321 MB sources in 22 modules, into 0.264 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 2.236 s (elab=0.018, cvt=0.036, bld=1.879); cpu 2.055 s on 64 threads; alloced 150.906 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n[180000] %Error: tb.sv:4222: Assertion failed in TOP.tb:               180000 TOP.tb: (outParsedValid == (outAxi4St.tvalid && out_tfirst)) NOT TRUE at tb.sv:4222\n%Error: tb.sv:4222: Verilog $stop\nAborting...\n",
    "stderr": "",
    "pass": false,
    "score": 80,
    "warnings": 0,
    "errors": 0,
    "runtime": 2.400845527648926,
    "batch_iter": 2,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_2",
    "start_time": 1733526072.0201087,
    "stop_time": 1733526074.4209542
  },
  {
    "index": 2,
    "dut": "module dut #(\n  parameter int unsigned Depth = 4096,\n  parameter int unsigned EntriesMTU = 1504,\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int FifoSizeInBytes = 4096,\n  parameter int MaxNumberOfPackets = 32,\n  parameter int DropIngressOnAfull = 1,\n  parameter int DropEgressOnError = 1,\n  parameter int IngressPrefillBytes = -1\n) (\n  input  logic                          clock,\n  input  logic                          reset,\n  \n  input  AxiStreamType                  inAxi4St,\n  input  logic                          inError,\n  input  logic [ExtraDataWidth-1:0]     inExtra,\n  output logic                          inTready,\n  \n  output AxiStreamType                  outAxi4St,\n  output logic                          outError,\n  output logic [ExtraDataWidth-1:0]     outExtra,\n  input  logic                          outTready,\n  \n  output logic                          inFifoAfull,\n  output logic                          inDropEvent,\n  output logic                          outDropEvent\n);\n\nlocalparam int CountWidth = $clog2(Depth + 1);\n\ntypedef struct packed {\n  AxiStreamType axi4st;\n  logic error;\n  logic [ExtraDataWidth-1:0] extra;\n} fifo_data_t;\n\nfifo_data_t fifo_in, fifo_out;\nlogic [CountWidth-1:0] fifo_count;\nlogic fifo_push, fifo_pop;\nlogic pkt_in_progress;\nlogic drop_pkt;\nlogic [$clog2(MaxNumberOfPackets+1)-1:0] pkt_count;\n\n// FIFO instance\nlocal_axist_fifo #(\n  .AxiStreamType(fifo_data_t),\n  .AxiStreamWidth($bits(fifo_data_t)),\n  .ExtraDataWidth(1),\n  .Depth(Depth)\n) u_fifo (\n  .clock(clock),\n  .reset(reset),\n  .inCount(fifo_count),\n  .inAxi4St(fifo_in),\n  .inTready(fifo_push),\n  .outAxi4St(fifo_out),\n  .outTready(fifo_pop)\n);\n\n// Input logic\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    pkt_in_progress <= 1'b0;\n    drop_pkt <= 1'b0;\n    pkt_count <= '0;\n  end else begin\n    if (inAxi4St.tvalid && inTready) begin\n      if (!pkt_in_progress) begin\n        pkt_in_progress <= 1'b1;\n        drop_pkt <= (fifo_count < EntriesMTU) || (pkt_count >= MaxNumberOfPackets);\n      end\n      if (inAxi4St.tlast) begin\n        pkt_in_progress <= 1'b0;\n        if (!drop_pkt) begin\n          pkt_count <= pkt_count + 1'b1;\n        end\n      end\n    end\n    \n    if (outAxi4St.tvalid && outTready && outAxi4St.tlast) begin\n      pkt_count <= pkt_count - 1'b1;\n    end\n  end\nend\n\n// Input assignments\nalways_comb begin\n  inTready = 1'b1;\n  fifo_in.axi4st = inAxi4St;\n  fifo_in.error = inError;\n  fifo_in.extra = inExtra;\n  fifo_push = inAxi4St.tvalid && !drop_pkt;\n  inDropEvent = inAxi4St.tvalid && inAxi4St.tlast && drop_pkt;\n  inFifoAfull = (fifo_count >= (Depth - PacketMtuInBytes)) || (pkt_count >= MaxNumberOfPackets);\nend\n\n// Output assignments  \nalways_comb begin\n  outAxi4St = fifo_out.axi4st;\n  outError = fifo_out.error;\n  outExtra = fifo_out.extra;\n  fifo_pop = outTready;\n  outDropEvent = 1'b0;\nend\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'local_axist_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). The internals of module 'local_axist_fifo' are not revealed, but has the following module header and ports:\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter int unsigned CountWidth     = $clog2(Depth + 1),\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready\n   );\n\n\n\nAdditionally, you may use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = local_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = local_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/local_axist_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_fifo\n  #(\n  parameter type         AxiStreamType  = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = local_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_storefwd_fifo_4",
    "return_code": 0,
    "stdout": "",
    "stderr": "%Warning-PINMISSING: dut.sv:53:3: Cell has missing pin: 'almostFull'\n   53 | ) u_fifo (\n      |   ^~~~~~\n                     tb.sv:4530:44: ... Location of port declaration\n 4530 |   output logic                             almostFull,\n      |                                            ^~~~~~~~~~\n                     ... For warning description see https://verilator.org/warn/PINMISSING?v=5.028\n                     ... Use \"/* verilator lint_off PINMISSING */\" and lint_on around source to disable this message.\n%Warning-PINMISSING: dut.sv:53:3: Cell has missing pin: 'almostEmpty'\n   53 | ) u_fifo (\n      |   ^~~~~~\n                     tb.sv:4531:44: ... Location of port declaration\n 4531 |   output logic                             almostEmpty,\n      |                                            ^~~~~~~~~~~\n%Warning-PINMISSING: dut.sv:53:3: Cell has missing pin: 'outCount'\n   53 | ) u_fifo (\n      |   ^~~~~~\n                     tb.sv:4533:44: ... Location of port declaration\n 4533 |   output logic [CountWidth - 1 : 0]        outCount,\n      |                                            ^~~~~~~~\n%Warning-PINMISSING: dut.sv:53:3: Cell has missing pin: 'outError'\n   53 | ) u_fifo (\n      |   ^~~~~~\n                     tb.sv:4541:44: ... Location of port declaration\n 4541 |   output logic                             outError,\n      |                                            ^~~~~~~~\n%Warning-PINMISSING: dut.sv:53:3: Cell has missing pin: 'outExtra'\n   53 | ) u_fifo (\n      |   ^~~~~~\n                     tb.sv:4542:44: ... Location of port declaration\n 4542 |   output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n      |                                            ^~~~~~~~\n%Error: tb.sv:4546:32: Member 'tdata' not found in structure\n                     : ... note: In instance 'tb.u_dut.u_fifo'\n 4546 |   initial if (!($bits(inAxi4St.tdata) == AxiStreamWidth)) begin   \n      |                                ^~~~~\n%Error: tb.sv:4592:35: Member 'tvalid' not found in structure\n                     : ... note: In instance 'tb.u_dut.u_fifo'\n 4592 |     data_in_fifo_valid = inAxi4St.tvalid;\n      |                                   ^~~~~~\n%Error: tb.sv:4596:15: Member 'tvalid' not found in structure\n                     : ... note: In instance 'tb.u_dut.u_fifo'\n 4596 |     outAxi4St.tvalid    = data_out_fifo_valid;\n      |               ^~~~~~\n%Error: Exiting due to 3 error(s)\n",
    "pass": false,
    "score": 35,
    "warnings": 5,
    "errors": 4,
    "runtime": 0.25932908058166504,
    "batch_iter": 3,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_3",
    "start_time": 1733526072.0411804,
    "stop_time": 1733526072.3005095
  },
  {
    "index": 1,
    "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int unsigned AxiStreamWidth = 128, \n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n) (\n    input logic clock,\n    input logic reset,\n    input AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // MAC table entry structure\n    typedef struct packed {\n        logic valid;\n        logic [47:0] mac_addr;\n        logic [1:0] port;\n        logic [31:0] epoch_counter;\n    } mac_table_entry_t;\n\n    // MAC table\n    mac_table_entry_t [MacTableDepth-1:0] mac_table;\n    \n    // Current frame tracking\n    logic [47:0] curr_dst_mac;\n    logic [47:0] curr_src_mac;\n    logic [1:0] curr_rx_port;\n    logic [NumPorts-1:0] tx_ports;\n    logic frame_in_progress;\n\n    // Default assignments\n    assign egressFifoDropEvents = '0;\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                mac_table[i].valid <= 1'b0;\n            end\n            frame_in_progress <= 1'b0;\n            curr_dst_mac <= '0;\n            curr_src_mac <= '0;\n            curr_rx_port <= '0;\n            tx_ports <= '0;\n        end else begin\n            // Process input frame\n            for (int i = 0; i < NumPorts; i++) begin\n                if (inAxi4St[i].tvalid && inTready[i]) begin\n                    if (!frame_in_progress) begin\n                        // Start of frame - extract MAC addresses\n                        curr_dst_mac <= inAxi4St[i].tdata[47:0];\n                        curr_src_mac <= inAxi4St[i].tdata[95:48];\n                        curr_rx_port <= i[1:0];\n                        frame_in_progress <= 1'b1;\n\n                        // Learn source MAC\n                        for (int j = 0; j < MacTableDepth; j++) begin\n                            if (!mac_table[j].valid) begin\n                                mac_table[j].valid <= 1'b1;\n                                mac_table[j].mac_addr <= inAxi4St[i].tdata[95:48];\n                                mac_table[j].port <= i[1:0];\n                                mac_table[j].epoch_counter <= '0;\n                                break;\n                            end\n                        end\n                    end\n\n                    // Check for end of frame\n                    if (inAxi4St[i].tlast) begin\n                        frame_in_progress <= 1'b0;\n                    end\n                end\n            end\n\n            // Age MAC table entries\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].epoch_counter >= MacTableCyclesPerEpoch) begin\n                        mac_table[i].valid <= 1'b0;\n                    end else begin\n                        mac_table[i].epoch_counter <= mac_table[i].epoch_counter + 1;\n                    end\n                end\n            end\n        end\n    end\n\n    // Determine output ports based on destination MAC\n    always_comb begin\n        // Default to flood except rx port\n        tx_ports = '1;\n        tx_ports[curr_rx_port] = 1'b0;\n\n        // Check if destination MAC is in table\n        for (int i = 0; i < MacTableDepth; i++) begin\n            if (mac_table[i].valid && (mac_table[i].mac_addr == curr_dst_mac)) begin\n                tx_ports = '0;\n                tx_ports[mac_table[i].port] = 1'b1;\n                break;\n            end\n        end\n\n        // Handle broadcast/multicast\n        if (curr_dst_mac[0] || &curr_dst_mac) begin\n            tx_ports = '1;\n            tx_ports[curr_rx_port] = 1'b0;\n        end\n    end\n\n    // Input ready logic\n    always_comb begin\n        for (int i = 0; i < NumPorts; i++) begin\n            inTready[i] = outTready[i] && !frame_in_progress;\n        end\n    end\n\n    // Output forwarding logic  \n    always_comb begin\n        for (int i = 0; i < NumPorts; i++) begin\n            if (tx_ports[i] && frame_in_progress) begin\n                outAxi4St[i] = inAxi4St[curr_rx_port];\n            end else begin\n                outAxi4St[i] = '0;\n            end\n        end\n    end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module DOES need to support a 'ready' output signal for backpressure for the inAxi4St inputs, named inTready.\nThe module does need to support 'outReady' input signals for each transmit port\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/test_l2_switch_lite_5/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule custom_tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_5_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n      u_drv.m_out_tvalid_pct = 80;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n",
    "name": "test_l2_switch_lite_5",
    "return_code": 0,
    "stdout": "",
    "stderr": "%Warning-MULTIDRIVEN: dut.sv:94:9: Variable written to in always_comb also written by other process (IEEE 1800-2023 9.2.2.2): 'tx_ports'\n                                 : ... note: In instance 'tb.u_dut'\n                      dut.sv:94:9: \n   94 |         tx_ports = '1;\n      |         ^~~~~~~~\n                      dut.sv:47:13: ... Location of other write\n   47 |             tx_ports <= '0;\n      |             ^~~~~~~~\n                      ... For warning description see https://verilator.org/warn/MULTIDRIVEN?v=5.028\n                      ... Use \"/* verilator lint_off MULTIDRIVEN */\" and lint_on around source to disable this message.\n%Error-BLKANDNBLK: dut.sv:32:26: Unsupported: Blocked and non-blocking assignments to same variable: 'tb.u_dut.tx_ports'\n   32 |     logic [NumPorts-1:0] tx_ports;\n      |                          ^~~~~~~~\n                   dut.sv:94:18: ... Location of blocking assignment\n   94 |         tx_ports = '1;\n      |                  ^\n                   dut.sv:47:22: ... Location of nonblocking assignment\n   47 |             tx_ports <= '0;\n      |                      ^~\n%Error: Exiting due to 1 error(s)\n",
    "pass": false,
    "score": 59,
    "warnings": 1,
    "errors": 2,
    "runtime": 0.8443374633789062,
    "batch_iter": 4,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_4",
    "start_time": 1733526072.0623636,
    "stop_time": 1733526072.906701
  },
  {
    "index": 6,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n)(\n  input  logic clock,\n  input  logic reset,\n  input  AxiStreamType inAxi4St,\n  output logic inTready,\n  input  logic [ExtraDataWidth-1:0] inExtra,\n  output AxiStreamType outAxi4St,\n  input  logic outTready,\n  output logic [ExtraDataWidth-1:0] outExtra,\n  input  logic [7:0] i_rate_numerator,\n  input  logic [7:0] i_rate_denominator,\n  input  logic i_rate_by_frame\n);\n\n// Internal signals\nlogic [15:0] rate_counter;\nlogic throttle;\nlogic frame_active;\nlogic frame_start;\nlogic frame_end;\n\n// Frame tracking\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    frame_active <= 1'b0;\n  end else if (inAxi4St.tvalid && inTready) begin\n    if (inAxi4St.tlast) begin\n      frame_active <= 1'b0;\n    end else if (!frame_active) begin\n      frame_active <= 1'b1;\n    end\n  end\nend\n\nassign frame_start = inAxi4St.tvalid && !frame_active;\nassign frame_end = inAxi4St.tvalid && inTready && inAxi4St.tlast;\n\n// Rate limiting counter\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    rate_counter <= '0;\n  end else begin\n    if (inAxi4St.tvalid && inTready) begin\n      // Increment by denominator when sending data\n      rate_counter <= rate_counter + i_rate_denominator;\n    end else if (rate_counter >= i_rate_numerator) begin\n      // Decrement by numerator when idle\n      rate_counter <= rate_counter - i_rate_numerator;\n    end\n  end\nend\n\n// Generate throttle signal\nalways_comb begin\n  if (i_rate_by_frame) begin\n    // Mode 1: Only throttle at frame boundaries\n    throttle = frame_start && (rate_counter > (16'hFFFF - i_rate_denominator));\n  end else begin\n    // Mode 0: Throttle any time during frame\n    throttle = (rate_counter > (16'hFFFF - i_rate_denominator));\n  end\nend\n\n// AXI4-Stream handshaking\nassign inTready = !throttle && outTready;\n\nalways_comb begin\n  outAxi4St = inAxi4St;\n  outAxi4St.tvalid = inAxi4St.tvalid && !throttle;\n  outExtra = inExtra;\nend\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output. This has two modes of rate limiting and both must be implemented.\nMode 0:\n  When input i_rate_by_frame=0, this is a rate limiter where outputs inTready and outAxi4St.tvalid are set to 0 at any point in the frame.\nMode 1:\n  When input i_rate_by_frame=1, this is a rate limiter where outputs inTready and outAxi4St.tvalid can only be 0 on the first data phit of a frame. They must be\n  held at 0 for enough cycles to satisfy the overal rate limiting.\n  For example, if i_rate_by_frame=1, i_rate_numerator=10, i_rate_demoninator=40, this is a 25% rate limiter. If we send a 100 data phit frame, it must be sent with\n  outAxi4St.tvalid=1 for all 100 data phits consecutively. But we need at least 400 cycles of inactively to satisfy the overall rate limiter for the next frame. In this mode\n  i_rate_by_frame=1, you need a larger internal counter than 8-bits, and you may consider it needs to consume/increment by one i_rate_demonitor per sent data phit, and then release/decrement one i_rate_numerator when no data phit is sent (inAxi4St.tvalid=0, outTready=0 during the frame), or after the frame is sent.\n  prior to being able to send again.\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_2",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_5/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_5/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.296 MB sources in 17 modules, into 0.302 MB in 16 C++ files needing 0.002 MB\n- Verilator: Walltime 2.118 s (elab=0.006, cvt=0.039, bld=1.878); cpu 0.803 s on 64 threads; alloced 150.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           453000000 TOP.tb.main: First 100 frames, mon m_tactive_count=13238, m_tinactive_count=32052, calc rate(pct)=29\n           844710000 TOP.tb.main: 2nd 100 frames, mon m_tactive_count=13057, m_tinactive_count=26114, calc rate(pct)=33.3333\n[844710000] %Error: tb.sv:3529: Assertion failed in TOP.tb.main:            844710000 TOP.tb.main: (main_calc_rate > 48.0 && main_calc_rate < 52.0) NOT TRUE at tb.sv:3529\n%Error: tb.sv:3529: Verilog $stop\nAborting...\n",
    "stderr": "%Warning-TIMESCALEMOD: tb.sv:22:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n   22 | package oclib_assert_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n                       ... For warning description see https://verilator.org/warn/TIMESCALEMOD?v=5.028\n                       ... Use \"/* verilator lint_off TIMESCALEMOD */\" and lint_on around source to disable this message.\n%Warning-TIMESCALEMOD: tb.sv:686:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n  686 | package oclib_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1158:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1158 | package oclib_memory_bist_pkg;\n      |         ^~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1202:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1202 | package oclib_uart_pkg;\n      |         ^~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1221:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1221 | package ocsim_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1461:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1461 | package ocsim_packet_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1628:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1628 | module ocsim_tb_control #(\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1773:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1773 | module ocsim_axist_driver\n      |        ^~~~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2088:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2088 | module ocsim_axist_monitor\n      |        ^~~~~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2363:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2363 | module oclib_axist_rate_limit\n      |        ^~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2478:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2478 | module oclib_axist_rate_limit_test;\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2822:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2822 | package local_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3298:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3298 | module tb;\n      |        ^~\n                       tb.sv:3674:8: ... Location of module with timescale\n 3674 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-REALCVT: tb.sv:3501:75: Implicit conversion of real to integer\n 3501 |                $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n      |                                                                           ^~~~~~~~~~~~~~\n",
    "pass": false,
    "score": 66,
    "warnings": 14,
    "errors": 0,
    "runtime": 4.234132766723633,
    "batch_iter": 5,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_5",
    "start_time": 1733526072.1313853,
    "stop_time": 1733526076.365518
  },
  {
    "index": 9,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  input logic clock,\n  input logic reset,\n  \n  input AxiStreamType inAxi4St,\n  output logic inTready,\n  input logic [ExtraDataWidth-1:0] inExtra,\n  \n  output AxiStreamType outAxi4St, \n  input logic outTready,\n  output logic [ExtraDataWidth-1:0] outExtra,\n  \n  input logic [7:0] i_rate_numerator,\n  input logic [7:0] i_rate_denominator,\n  input logic i_rate_by_frame\n);\n  \n  // Counter for rate limiting\n  logic [7:0] rate_counter;\n  logic allow_transfer;\n  \n  // Pipeline stages\n  AxiStreamType pipe_in, pipe_out;\n  logic [ExtraDataWidth-1:0] extra_pipe;\n  logic pipe_ready;\n  \n  // Rate counter for throttling\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      rate_counter <= '0;\n    end\n    else if (outAxi4St.tvalid && outTready) begin\n      if (rate_counter >= i_rate_denominator - 1) begin\n        rate_counter <= '0;\n      end\n      else begin\n        rate_counter <= rate_counter + 1'b1;\n      end\n    end\n  end\n  \n  // Determine if transfer allowed based on rate\n  always_comb begin\n    allow_transfer = (rate_counter < i_rate_numerator);\n  end\n  \n  // Input stage connections\n  always_comb begin\n    pipe_in = inAxi4St;\n    inTready = pipe_ready && allow_transfer;\n  end\n  \n  // Pipeline instance\n  local_axist_pipe #(\n    .NumStages(1),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(pipe_in),\n    .inTready(pipe_ready),\n    .pipeAxi4St(),  // Not used\n    .pipeTready(),  // Not used  \n    .outAxi4St(pipe_out),\n    .outTready(outTready && allow_transfer)\n  );\n  \n  // Output stage connections  \n  always_ff @(posedge clock) begin\n    if (reset) begin\n      extra_pipe <= '0;\n    end\n    else if (inAxi4St.tvalid && inTready) begin\n      extra_pipe <= inExtra;\n    end\n  end\n  \n  always_comb begin\n    outAxi4St = pipe_out;\n    outExtra = extra_pipe;\n  end\n  \nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- For this design, this input can be ignored and assumed the value is tied to 0.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_lite_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_lite_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/test_axist_rate_limit_lite_3/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// custom_tb.sv -- refactored from oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n// Does not check i_rate_by_frame=1\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule custom_tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b0;    // NOTE this custom_tb.sv has it tied to 0.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_lite_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv -- refactored from oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n// Does not check i_rate_by_frame=1\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b0;    // NOTE this tb.sv has it tied to 0.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_lite_3",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_6/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_6/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.330 MB sources in 20 modules, into 0.308 MB in 16 C++ files needing 0.002 MB\n- Verilator: Walltime 1.966 s (elab=0.022, cvt=0.055, bld=1.765); cpu 0.384 s on 64 threads; alloced 151.906 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           419420000 TOP.tb.main: First 100 frames, mon m_tactive_count=13238, m_tinactive_count=28694, calc rate(pct)=32\n[423155000] %Error: tb.sv:1589: Assertion failed in TOP.ocsim_packet_pkg.compare_packets:            423155000 TOP.ocsim_packet_pkg.compare_packets: (got.data.size()) (00000173) NOT EQ (want.data.size()) (000000b3) at tb.sv:1589\n%Error: tb.sv:1589: Verilog $stop\nAborting...\n",
    "stderr": "%Warning-TIMESCALEMOD: tb.sv:22:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n   22 | package oclib_assert_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n                       ... For warning description see https://verilator.org/warn/TIMESCALEMOD?v=5.028\n                       ... Use \"/* verilator lint_off TIMESCALEMOD */\" and lint_on around source to disable this message.\n%Warning-TIMESCALEMOD: tb.sv:686:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n  686 | package oclib_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1158:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1158 | package oclib_memory_bist_pkg;\n      |         ^~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1202:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1202 | package oclib_uart_pkg;\n      |         ^~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1221:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1221 | package ocsim_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1461:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1461 | package ocsim_packet_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1628:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1628 | module ocsim_tb_control #(\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1773:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1773 | module ocsim_axist_driver\n      |        ^~~~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2088:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2088 | module ocsim_axist_monitor\n      |        ^~~~~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2363:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2363 | module oclib_axist_rate_limit\n      |        ^~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2478:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2478 | module oclib_axist_rate_limit_test;\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2822:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2822 | package local_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3293:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3293 | module oclib_ready_valid_pipe_core\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3351:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3351 | module local_axist_pipe\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3448:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3448 | module custom_tb;\n      |        ^~~~~~~~~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3797:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3797 | module tb;\n      |        ^~\n                       tb.sv:4173:8: ... Location of module with timescale\n 4173 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-REALCVT: tb.sv:4000:75: Implicit conversion of real to integer\n 4000 |                $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n      |                                                                           ^~~~~~~~~~~~~~\n",
    "pass": false,
    "score": 63,
    "warnings": 17,
    "errors": 0,
    "runtime": 3.1856610774993896,
    "batch_iter": 6,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_6",
    "start_time": 1733526072.1677787,
    "stop_time": 1733526075.3534398
  },
  {
    "index": 8,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType inAxi4St,\n    output logic inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready,\n    output logic outParsedValid,\n    output logic [47:0] outParsedDestMac,\n    output logic [47:0] outParsedSourceMac\n);\n\n    localparam int BYTES_PER_MAC = 6;\n    localparam int TOTAL_MAC_BYTES = BYTES_PER_MAC * 2;\n    localparam int BYTES_PER_TRANSFER = AxiStreamWidth/8;\n    localparam int CYCLES_TO_CAPTURE = (TOTAL_MAC_BYTES + BYTES_PER_TRANSFER - 1) / BYTES_PER_TRANSFER;\n    \n    logic [TOTAL_MAC_BYTES*8-1:0] mac_shift_reg;\n    logic [$clog2(CYCLES_TO_CAPTURE):0] byte_counter;\n    logic parsing_frame;\n    logic first_output_beat;\n    \n    // Delay line for AXI stream\n    AxiStreamType axi_delay_line[CYCLES_TO_CAPTURE];\n    \n    always_ff @(posedge clock) begin\n        if (reset) begin\n            byte_counter <= '0;\n            parsing_frame <= 1'b0;\n            mac_shift_reg <= '0;\n            first_output_beat <= 1'b0;\n            outParsedValid <= 1'b0;\n            outParsedDestMac <= '0;\n            outParsedSourceMac <= '0;\n        end else begin\n            if (inAxi4St.tvalid && inTready) begin\n                // Start new frame\n                if (!parsing_frame) begin\n                    parsing_frame <= 1'b1;\n                    byte_counter <= BYTES_PER_TRANSFER;\n                    mac_shift_reg <= '0;\n                end else if (byte_counter < TOTAL_MAC_BYTES) begin\n                    byte_counter <= byte_counter + BYTES_PER_TRANSFER;\n                end\n                \n                // Shift in new bytes\n                mac_shift_reg <= {mac_shift_reg[TOTAL_MAC_BYTES*8-AxiStreamWidth-1:0], inAxi4St.tdata};\n                \n                // Check if we've captured all MAC bytes\n                if (byte_counter >= (TOTAL_MAC_BYTES - BYTES_PER_TRANSFER)) begin\n                    outParsedDestMac <= mac_shift_reg[TOTAL_MAC_BYTES*8-1:BYTES_PER_MAC*8];\n                    outParsedSourceMac <= mac_shift_reg[BYTES_PER_MAC*8-1:0];\n                end\n                \n                // Reset on last beat\n                if (inAxi4St.tlast) begin\n                    parsing_frame <= 1'b0;\n                    byte_counter <= '0;\n                end\n            end\n            \n            // Manage delay line\n            if (inAxi4St.tvalid && inTready) begin\n                for (int i = CYCLES_TO_CAPTURE-1; i > 0; i--) begin\n                    axi_delay_line[i] <= axi_delay_line[i-1];\n                end\n                axi_delay_line[0] <= inAxi4St;\n                \n                first_output_beat <= !parsing_frame;\n            end\n            \n            outParsedValid <= first_output_beat && outAxi4St.tvalid;\n        end\n    end\n    \n    // Output assignments\n    assign outAxi4St = axi_delay_line[CYCLES_TO_CAPTURE-1];\n    assign inTready = outTready; // Backpressure\n    \nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_2",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_7/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_7/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.313 MB sources in 19 modules, into 0.232 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 1.973 s (elab=0.006, cvt=0.120, bld=1.490); cpu 1.691 s on 64 threads; alloced 150.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n[240000] %Error: tb.sv:4015: Assertion failed in TOP.tb:               240000 TOP.tb: (outParsedValid == (outAxi4St.tvalid && out_tfirst)) NOT TRUE at tb.sv:4015\n%Error: tb.sv:4015: Verilog $stop\nAborting...\n",
    "stderr": "",
    "pass": false,
    "score": 80,
    "warnings": 0,
    "errors": 0,
    "runtime": 2.2694122791290283,
    "batch_iter": 7,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_7",
    "start_time": 1733526072.1967134,
    "stop_time": 1733526074.4661257
  },
  {
    "index": 5,
    "dut": "module dut #(\n  parameter int Depth = 4096,\n  parameter int EntriesMTU = 1504,\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1, \n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int FifoSizeInBytes = 4096,\n  parameter int MaxNumberOfPackets = 32,\n  parameter int DropIngressOnAfull = 1,\n  parameter int DropEgressOnError = 1,\n  parameter int IngressPrefillBytes = -1\n)(\n  input logic clock,\n  input logic reset,\n  input AxiStreamType inAxi4St,\n  output logic inTready,\n  output AxiStreamType outAxi4St,\n  input logic outTready,\n  input logic inError,\n  input logic [ExtraDataWidth-1:0] inExtra,\n  output logic outError,\n  output logic [ExtraDataWidth-1:0] outExtra,\n  output logic inFifoAfull,\n  output logic inDropEvent,\n  output logic outDropEvent\n);\n\n  // Storage for FIFO entries\n  AxiStreamType fifo_data [Depth-1:0];\n  logic [ExtraDataWidth-1:0] fifo_extra [Depth-1:0];\n  logic [Depth-1:0] fifo_error;\n  \n  // FIFO pointers and counters\n  logic [$clog2(Depth):0] write_ptr;\n  logic [$clog2(Depth):0] read_ptr;\n  logic [$clog2(Depth):0] count;\n  logic [$clog2(MaxNumberOfPackets):0] packet_count;\n  \n  // Flags\n  logic fifo_empty;\n  logic fifo_full;\n  logic frame_in_progress;\n  logic drop_current_frame;\n  \n  // Calculate empty/full/afull conditions\n  assign fifo_empty = (count == 0);\n  assign fifo_full = (count == Depth);\n  assign inFifoAfull = (count > (Depth - PacketMtuInBytes)) || (packet_count >= MaxNumberOfPackets);\n  \n  // Input ready is always 1\n  assign inTready = 1'b1;\n  \n  // Frame drop logic\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      drop_current_frame <= 1'b0;\n      frame_in_progress <= 1'b0;\n    end else begin\n      if (inAxi4St.tvalid) begin\n        if (!frame_in_progress) begin\n          frame_in_progress <= 1'b1;\n          drop_current_frame <= inFifoAfull;\n        end\n        if (inAxi4St.tlast) begin\n          frame_in_progress <= 1'b0;\n          drop_current_frame <= 1'b0;\n        end\n      end\n    end\n  end\n  \n  // Write logic\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      write_ptr <= '0;\n      packet_count <= '0;\n    end else begin\n      if (inAxi4St.tvalid && !drop_current_frame && !fifo_full) begin\n        fifo_data[write_ptr[$clog2(Depth)-1:0]] <= inAxi4St;\n        fifo_extra[write_ptr[$clog2(Depth)-1:0]] <= inExtra;\n        fifo_error[write_ptr[$clog2(Depth)-1:0]] <= inAxi4St.tlast ? inError : 1'b0;\n        write_ptr <= write_ptr + 1;\n        if (inAxi4St.tlast) begin\n          packet_count <= packet_count + 1;\n        end\n      end\n    end\n  end\n  \n  // Read logic \n  always_ff @(posedge clock) begin\n    if (reset) begin\n      read_ptr <= '0;\n      outAxi4St <= '0;\n      outError <= 1'b0;\n      outExtra <= '0;\n    end else begin\n      if (!fifo_empty && outTready) begin\n        outAxi4St <= fifo_data[read_ptr[$clog2(Depth)-1:0]];\n        outExtra <= fifo_extra[read_ptr[$clog2(Depth)-1:0]];\n        outError <= fifo_error[read_ptr[$clog2(Depth)-1:0]];\n        if (outAxi4St.tlast) begin\n          packet_count <= packet_count - 1;\n        end\n        read_ptr <= read_ptr + 1;\n      end\n    end\n  end\n  \n  // Count tracking\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      count <= '0;\n    end else begin\n      if (!fifo_empty && outTready && !(!fifo_full && inAxi4St.tvalid && !drop_current_frame)) begin\n        count <= count - 1;\n      end else if (!fifo_empty && !outTready && (!fifo_full && inAxi4St.tvalid && !drop_current_frame)) begin\n        count <= count + 1;\n      end\n    end\n  end\n  \n  // Drop event generation\n  assign inDropEvent = inAxi4St.tvalid && inAxi4St.tlast && drop_current_frame;\n  assign outDropEvent = 1'b0;\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_storefwd_fifo_3",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_8/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_h028da22e__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_8/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.315 MB sources in 19 modules, into 0.302 MB in 17 C++ files needing 0.002 MB\n- Verilator: Walltime 2.001 s (elab=0.006, cvt=0.025, bld=1.891); cpu 0.261 s on 64 threads; alloced 150.914 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n               20000 TOP.tb.wait_drv_mon_done: waiting for driver to finish packets=17, inital 15-20 packets\n            29020000 TOP.tb.wait_drv_mon_done: waiting for monitor to see all packets=17, inital 15-20 packets\n[10000101000] %Error: tb.sv:1688: Assertion failed in TOP.tb.uCONTROL.main: stimulusDone=(0) after 1000000 cycles\n%Error: tb.sv:1688: Verilog $stop\nAborting...\n",
    "stderr": "",
    "pass": false,
    "score": 80,
    "warnings": 0,
    "errors": 0,
    "runtime": 10.975267887115479,
    "batch_iter": 8,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_8",
    "start_time": 1733526072.2222674,
    "stop_time": 1733526083.1975353
  },
  {
    "index": 10,
    "dut": "module dut \n  #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned FlopArbSel = 0, \n    parameter int unsigned FlopOutput = 0,\n    parameter int NumInputs = 4,\n    parameter int NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n  )\n  (\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] inTready,\n    output AxiStreamType outAxi4St,\n    input  logic outTready\n  );\n\n  logic [NumInputs-1:0] request_valid;\n  logic [NumInputs-1:0] grant;\n  logic [NumSelectBits-1:0] select;\n  logic update_arb;\n  logic xfer_active;\n  logic last_beat;\n\n  // Generate request valid bits from input tvalid signals\n  always_comb begin\n    for(int i=0; i<NumInputs; i++) begin\n      request_valid[i] = inAxi4St[i].tvalid & ~xfer_active;\n    end\n  end\n\n  // Detect last beat of transfer\n  assign last_beat = outAxi4St.tvalid & outAxi4St.tlast & outTready;\n\n  // Control when to update arbitration\n  always_comb begin\n    update_arb = ~xfer_active | last_beat;\n  end\n\n  // Track active transfer\n  always_ff @(posedge clock) begin\n    if(reset) begin\n      xfer_active <= 1'b0;\n    end\n    else begin\n      if(last_beat) begin\n        xfer_active <= 1'b0;\n      end\n      else if(|request_valid) begin\n        xfer_active <= 1'b1;\n      end\n    end\n  end\n\n  // Instantiate round robin arbiter\n  local_rrarb #(\n    .NumInputs(NumInputs),\n    .NumSelectBits(NumSelectBits)\n  ) u_rrarb (\n    .clock(clock),\n    .reset(reset),\n    .update_valid(update_arb),\n    .requests_in(request_valid),\n    .grant_out(grant),\n    .select_out(select)\n  );\n\n  // Route selected input to output\n  always_comb begin\n    outAxi4St = inAxi4St[select];\n  end\n\n  // Generate ready signals\n  always_comb begin\n    inTready = '0;\n    inTready[select] = outTready;\n  end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n\nAdditionally, you are required to use the following module (without revealing the internals) to perform round robin arbitration. The outputs of local_rrarb (grant_out, and select_out) are held and will not change unless input update_valid=1. When update_valid=1, a requests_in (vector of request valid bits) is also set, and a new arbitration winner is on the outputs -- grant_out is a 1-hot vector, and select_out is the encoded winner with values between 0 and NumInputs-1.\n\nmodule local_rrarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rrarb_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb_test.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb_test;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  oclib_axist_rrarb\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : oclib_axist_rrarb_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_3_test_sim/local_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = local_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = local_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : tb\n",
    "name": "test_axist_rrarb_3",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_9/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_axist_driver__DepSet_hbd398ec9__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_axist_driver__Slow.cpp Vtb_ocsim_axist_driver__DepSet_hbd398ec9__0__Slow.cpp Vtb_ocsim_axist_driver__DepSet_h608c9d06__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_9/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.317 MB sources in 20 modules, into 1.105 MB in 20 C++ files needing 0.007 MB\n- Verilator: Walltime 3.083 s (elab=0.007, cvt=0.301, bld=2.523); cpu 0.971 s on 64 threads; alloced 159.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20001, error: 0, timestamp_ps=4671226772094713856, data: {size: 80, data: 02e478bc_b6e4b753 21e1c582_62351256 fdf43b58_b25c1e9e 9eee1076_63c01d22 06816378_6fcef7d1 9e776ea8_4fbb94e2 661f09e3_1f84c533 4b9cf3c9_edca5d47 24efa96d_3978eac2 5454239d_b3add52e}}, driven_packetqueue[port=2].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20002, error: 0, timestamp_ps=4671226772094713856, data: {size: 99, data: d789f6af_ef9d3fcf 2a779a0b_53af8c02 fbe8c2dd_c86461e5 21f359f5_bd7e62ca 90455810_6073fc3d 6c0ee737_4740331c b6d73a67_5384f4e4 2867953c_64958a3d 7f5bdcec_c6467904 d434bd1b_02715363 def0045f_f8238061 6157d2fc_bc7b317e ed64d4}}, driven_packetqueue[port=2].size()=2\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10003, error: 0, timestamp_ps=4671226772094713856, data: {size: 195, data: cbcbdbe9_4e244207 00d63f39_f9d77a76 7c42ae76_2b27d2a2 06090fdc_e45979ac 80f7ea8d_af8910ca c6ab784c_f75a5411 c9291014_712a318c e682866e_d96e8db8 548d69d6_6e65b257 4e6499a9_4043aaf6 e7d72253_860ee4c9 4049f309_f85b9610 826dde1b_80dd3b7a 9f0ab89c_d3b44983 dce9561f_5f658cd8 ed68193c_c56723bf 01844393_231b47e8 a96a799a_4ef32f29 f18066a9_916155e2 0486cee7_d19b4c7e 986d3184_2037d10b cfd7ac20_4dc8c2dc abbab4c6_0314de4e ab49162c_91c50798 169624}}, driven_packetqueue[port=1].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20004, error: 0, timestamp_ps=4671226772094713856, data: {size: 114, data: fc4972c0_b43c151f 8dc37444_8556cb91 eaa4bb97_054192fa 1471e190_dd5abc7f dfc2b2e4_08607d84 d1ac4b17_84e68979 a9080756_5bd44c8f acf0adee_cb380c0e ab8145be_8462cde9 b31f2220_e662fa6e a7ded685_a3a55bb9 9c71786e_59657165 da867758_3750cb24 6c0f8bec_a266d95e 37db}}, driven_packetqueue[port=2].size()=3\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10005, error: 0, timestamp_ps=4671226772094713856, data: {size: 195, data: 553c5e89_da01634e 9bccda12_1f909132 94c2c573_eca81d11 a9ad035c_08585e1a f004278b_15b80e58 be09cdc0_46309a87 4ac2cd1f_def29988 ffbfea3e_3c17508a ffdc288a_d86e3c1f 935a5c59_b59bccf8 cec85d25_68b168b0 87b12106_8e6bd938 22ffd2c2_de5f172b 9a6d40c2_07153d69 607e037e_40fedb6d 3e887dc5_c6f61368 0effee13_309a479b c6d1522d_57417f37 0bd63f1c_2d131288 a8612ecc_d7be9be5 c2c639f1_15a57a80 24e47f75_1b73326c 7960c0ec_ee33d95b 4bd14f5a_574005ad b9bbce}}, driven_packetqueue[port=1].size()=2\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 6, error: 0, timestamp_ps=4671226772094713856, data: {size: 96, data: cfe4a9fd_cba357b0 abdc957d_da5eb2a2 dcac2d5f_0955120b f45a677b_062e3354 ce2a62bc_0fe01f5d eed8c7d1_d2f8b199 a8cf8c5e_433a0a33 df8d2c81_bfe7066c c682856b_f0908540 12cabcae_430dc2ee 58bc411f_c07275d8 f6df60c7_c9601b5d}}, driven_packetqueue[port=0].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20007, error: 0, timestamp_ps=4671226772094713856, data: {size: 176, data: 9b5c176e_33505407 3db302a7_4e45cf0f a9c954ed_41d5fb50 f02c0f06_ffb1977f bbc0e8eb_987d144e 842448e6_4e1fb34f ec9c1d87_30aa365b bc2cf4a5_7a124404 71f7560d_844ecade 2c0fb7ee_c12e6563 aeeb5a23_a49f943c e690472d_54032386 5494a34b_f3f7a6c5 3a810e58_12e671e4 790f3c47_914f6d0b 10d84089_11f9bd84 7c804bca_4cb85df2 e44451af_40e645b7 58a56ef5_64629819 18f18467_9ca4be19 b64157c7_d75faa16 459161dc_172014f8}}, driven_packetqueue[port=2].size()=4\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 8, error: 0, timestamp_ps=4671226772094713856, data: {size: 154, data: cead5e36_624b7148 e8280743_5520a660 c2352099_180483d9 336498e7_431c9d52 6fe54837_4b7238ae 3c293667_a5e4b0a6 90063ebb_d9d7611c 14bdee3a_f66ee422 5b0b5328_4165ac16 6a7e4bb0_2dd4531b 138fba9a_9d5f5c7f 98bf7b1b_eb4e86e0 55aece2b_08533d8f a6c48afd_63838295 90a82493_249875a3 28566fd0_38a59fa8 d6f5db56_f634efc8 3b7bf6b3_e3de105f 17cdc0f3_ff9bda61 855b}}, driven_packetqueue[port=0].size()=2\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10009, error: 0, timestamp_ps=4671226772094713856, data: {size: 142, data: 3e6d9791_226e1f7f 1180f269_91ee78f9 8af08984_349aa2a1 e5ffcb7f_ff1151e4 d6bab4e1_46a312d3 6d919edc_7e304ca5 a1a1daba_72ef6d58 641e6d17_1f052219 b30de20e_dbbed225 1b72989e_419e92af c7bf9343_17037aaa 9274a505_56b6fb67 8dd184d5_3a4917df bfd08fab_630ac9a5 476f00fc_67022d7d 77b49490_4927d802 45894eae_0b321591 dce9d991_6027}}, driven_packetqueue[port=1].size()=3\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10010, error: 0, timestamp_ps=4671226772094713856, data: {size: 93, data: b00a7bc8_43a8df1e 9b4b300c_386f3a56 ec120782_fc862d84 5f5c8ce4_377891f7 3e222c9c_28df1c8e 5d600612_e3bb22fa b9577d7e_1d20e65d dbf514ed_3b5be2fd 62026d88_1483a582 d58fc555_4860772a 5ae14a97_55dbf619 54e769b8_19}}, driven_packetqueue[port=1].size()=4\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10011, error: 0, timestamp_ps=4671226772094713856, data: {size: 177, data: 769addce_b60ec640 ae389d0b_d7af38d5 f556722e_50e9894d f090fa19_50963224 fa689a24_60b7f28c 86d6df68_a9850455 e7dde760_efe9bddd 58f2c9f9_3dcd605e 9731a485_39f47741 893df4f0_4d7a9efd 13b9bdd3_8770fa68 5a9346bb_e9465d93 1390df7d_f7cd2595 fe6c49f7_a471a570 45ff9b1e_98966a53 d81b1823_1c1abcf9 865a05e2_282674cb 22824d9d_ca7eed6e 0b26e083_deb5daa2 ec6148f3_dfb84bd1 84ac2e6c_d70e09e8 4b0a2348_674b4027 3b}}, driven_packetqueue[port=1].size()=5\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 12, error: 0, timestamp_ps=4671226772094713856, data: {size: 168, data: c0643af4_b57704ca ff88dcee_0e9a784f e483166d_24b56b36 ed112fef_0933189c a239a6fc_51756564 185a19ff_d5efd0b7 cfda1789_1c52fe34 37c2b179_763b651f 7e622a51_e42a1b06 6a261fdc_846abc49 6d3053eb_6f93be00 b61a9945_f8a9de8c 8be688e8_5bc3905f adbfd07f_46f5f3a1 383f7900_921ab66f fe8abb2b_61380745 ff9256b3_1cc5deac b86798a6_2cb35f8f 4a9c11cd_e4e0cbc9 d48d217c_c0833265 f8597a9f_1c8299d0}}, driven_packetqueue[port=0].size()=3\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20013, error: 0, timestamp_ps=4671226772094713856, data: {size: 170, data: 4f0654d3_81ad49f2 1ba3f61f_3f4fc2f0 16c867b4_a5df6c7f 1b53c849_c40f8e46 da13702b_04e48c85 c615f9ef_664f2f7a 19a401ec_6a20bbec c20da0ba_17adcfad 8ae0a818_d858d2b1 9ddf8820_10fa5f41 e0cb2ae4_e4e0954e 239e51fc_efd74b7a 08af3cec_26cc3afc 9e652134_525a329d 6a90bcfc_f1b81798 50c710fc_ce98198e 52241ee1_42707ee8 43b75821_788e86a8 a242304d_d201c399 d899a1cb_b354c3fb 1a799cbe_e491b1e5 2640}}, driven_packetqueue[port=2].size()=5\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20014, error: 0, timestamp_ps=4671226772094713856, data: {size: 164, data: 8252118e_a3fe2adb 1382501e_4fa17966 367dcf0f_f4a658ad af9eac63_a3bfbc9a 347a2bcd_1ead4ce3 616a1840_2e2d2312 e92cc14a_f52db61d 7ae3801b_d4af8186 2298baa0_d3e5a095 f7316f4b_9073d9d6 7fc36d36_91c02a6d 8c4175e1_3df1c554 5e1e543b_28eba30a 4ad28d91_f4296536 90238e01_673cbd0a ed98dcec_2f481980 005c96ef_09cc18e9 9b956827_1639c61e 2a775f17_57287f7e aa21e3b9_5c472385 2d50f60d}}, driven_packetqueue[port=2].size()=6\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20015, error: 0, timestamp_ps=4671226772094713856, data: {size: 134, data: 354fff1c_af606550 bc77a324_8e4e8890 6fb259cc_3f4d186c 93835846_60f40cec bf031d29_7722ffff 41d2f660_bfefea76 25d67b5d_eb895ea4 140b93c5_e8dd14e1 6451068e_46a669b1 35a6224e_974c0ebf c1c44098_c3aa4702 2b792db0_5ef34bdf 57c3d90f_1b21781e bd5cce4f_6359dc52 0126b388_dce72d43 04a971be_1a9142c2 5955e342_4bb6}}, driven_packetqueue[port=2].size()=7\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20016, error: 0, timestamp_ps=4671226772094713856, data: {size: 171, data: c9d7d98a_1cc7baaa 5b904f22_a1cdbe23 efaa25aa_a7c2d218 34148ec8_161fd264 660a3d49_33ad6d73 7ce428af_41b6c6fa ee8291b3_9c5cebfc 29a68d5e_1e6a8646 dd58a0d2_ddfe200f 7892db7a_3e624d49 b9bc192d_91a3257f 5a2899bd_1c6abf13 d77db86c_5dc4385b 5404848a_6c75dedf c49703d7_72b05302 05fe5744_3c09e1ec e2072519_ec6424e7 1d1c41a6_21b5f2cb 730c33a2_b4dd9710 000257d8_4ef9993e c5470ba9_26794855 1ade6c}}, driven_packetqueue[port=2].size()=8\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 17, error: 0, timestamp_ps=4671226772094713856, data: {size: 163, data: 7a2fbc93_7ae1f1c4 523b389f_142f0716 b32bbd81_9b5b3244 177fe500_031bca7f ff14adb1_32f5eb8e d21c1cc0_ee787e03 580613c7_18f4706c c716844e_a3fea752 57abb920_f51c65e5 184fd2cb_b1e62415 1004da76_bb62874f fb4eaa9b_287e3855 d794e5a5_1877cd4b a3a8d387_5b149258 44fc9b9c_b85531e0 2b087968_3149ccc6 9f3b77b6_5bb3caba e2b5e18f_5eb2c4a9 cda00e59_59f845d2 87be6492_f0dfcbfb f6b2e2}}, driven_packetqueue[port=0].size()=4\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10018, error: 0, timestamp_ps=4671226772094713856, data: {size: 107, data: fb6ea7ec_34f1aa5e 4200c0bb_58848e55 32aeaf5b_00deb716 61614cfb_101bc989 67988715_8cbae916 5b860d01_80b689b7 2d934186_ee1b0851 66b8e5fa_298a4a74 d91832b8_855c97c9 1b7f013d_cef00f05 837bca7e_d01fad67 81ac20e5_4ac06d37 55f09ccd_4d7c204c 636d8b}}, driven_packetqueue[port=1].size()=6\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10019, error: 0, timestamp_ps=4671226772094713856, data: {size: 86, data: 277a7c84_f8bc1623 c40953db_ca48b747 decaba69_0c73c6fa 306018f5_3604e787 a5e8f284_087e4ac0 9f2fd098_a98fef0a 86ca1d90_50ea09b0 ea6aedfe_55bdebd2 8295e841_97f33660 24acd18f_d54f191c 5d2f4b16_ebad}}, driven_packetqueue[port=1].size()=7\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 20, error: 0, timestamp_ps=4671226772094713856, data: {size: 151, data: 036af29e_dff23933 206bdf2d_e184a041 95ef52f6_ab55ba71 c390de3e_9c6527b4 d1da5c4b_beec5305 3c144a75_6881bd9c 43ca0ad4_97f0b828 8f792bb4_dae3eb0b 0b1e1272_2b806861 d2cff17a_1093222c 9ef1553e_1b1fe196 09940813_958056ae b294a8ea_da433a85 7846bd57_bb5c45bf edca989d_c547eb25 43480199_30e893d0 b91f4894_9248ede4 9a5f2192_5d051954 d7adc634_9dfd2e}}, driven_packetqueue[port=0].size()=5\n            42020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10021, error: 0, timestamp_ps=4720908638787469312, data: {size: 79, data: 68e5afc0_2899ee2b e3f659fd_fe452be7 5ac5eaf9_26a9f0b3 4a6d3908_f27212fc 7e21b0a9_9ad1ea17 a5a18c59_647b2ed7 f38b59f3_44196cb7 4ba6ffa7_5f81db52 d0408315_d4448131 96bebd20_b72616}}, driven_packetqueue[port=1].size()=1\n            42020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10022, error: 0, timestamp_ps=4720908638787469312, data: {size: 71, data: 54f49b15_7e357569 8869b435_22bbc678 b1e7ca45_1248fb52 1c0737da_af3012b5 16a06f95_994730a3 40b83c5e_247e1c44 0254dbd8_9e653255 0969bef4_b3e96c2f 0e2f7ae1_15ef2b}}, driven_packetqueue[port=1].size()=2\n            45020000 TOP.tb.add_rand_packet: port=0, pkt={id: 23, error: 0, timestamp_ps=4721311291971469312, data: {size: 112, data: 804b72d0_046e4cc9 c043403b_3b1cd9b6 bd2041ad_851b5198 cfb76b40_18e4ba93 be1fdf73_02714ba0 afb8d0ff_42f9536d 7b3f3ede_c9090f33 0b900ad8_4078bb12 83f1755d_caf33736 38ca96d7_390b70ad 620ba590_73c88f8d a88b0f49_6471ffd1 16b0d17f_6b836f43 aa3a0c88_d6b8dfe3}}, driven_packetqueue[port=0].size()=1\n            45020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10024, error: 0, timestamp_ps=4721311291971469312, data: {size: 172, data: f6f4e4af_ae2417f2 bde43ff1_02e8afc5 6f15a7ed_b394e9ad a7fc93ed_7d513f1b a9c0dc17_b291dd0d 6f767c35_75345b62 85f71412_14e8975e 2086f8ef_50da0e38 cf699f9d_aa6dda87 3f8fcd64_782a08d8 27f63adb_0f731430 40fc973d_e65c3e06 c1869ad9_86bb4ee5 9eacb893_5352d9b1 aa56a5fd_456909c7 cd3f08b6_d6c44189 b3c34640_dc2e8aa1 d16d623a_83b59032 59d16d74_cbd9c0db 7243d6e9_17db1f43 3ced14c4_1b4bf679 411d4c7d}}, driven_packetqueue[port=1].size()=1\n            50020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20025, error: 0, timestamp_ps=4721982380611469312, data: {size: 98, data: 5f682260_806b245b 02290b38_41f3d64a 83a31207_19c751be 39a07e13_dd4da32f dea1136c_3e015613 71e303d6_e0a4deb8 91ae2a33_c87fea78 d697b3ca_c831f781 013bea7f_5794fc1d ebca04bf_5dc30c10 34991970_fb99a126 9846e3df_59d31fd5 3f44}}, driven_packetqueue[port=2].size()=1\n            50020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10026, error: 0, timestamp_ps=4721982380611469312, data: {size: 191, data: c8bac85b_99482d46 75a03732_516d3b49 b1a339fa_54c90d6e 65740d78_1b08c424 8d1ed001_d7d65634 3dd373e8_002b0d61 a5fc3c01_262ab01c 47319dd1_d23b7da8 d6436c1d_97ea9479 dc22add0_e07fe326 b6c3290f_04b2f049 0c749fd4_918b7dbc 1f01f480_d5a2ba2d 08b1b013_54ffb3b5 427fc07b_8990ef52 94371dbd_fc0ea290 8777bbc0_d9649e96 a3ea937f_f7e0bdac 921df378_def5a86a 75ead333_ae7de5d7 071923e3_abcd35c9 db800a9c_06b2c28b a5104d77_b2d30232 6d787512_1ab9c3}}, driven_packetqueue[port=1].size()=1\n            55020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10027, error: 0, timestamp_ps=4722653469251469312, data: {size: 151, data: 9322361e_45c9159a c06e7dcb_e8f99392 cae993ce_1f08efe6 69a55a9b_ae2fad58 49332e47_0d6cfff4 694de579_7305d4e7 e19fc632_5c0d6d03 6a52e1d4_9563d82a 945cf7f6_3b64edb0 69bbfcd8_01236a6a e42ee23f_9b201ded d52ccdbe_9af09dac a22d3a54_3de8c4ce 4746f587_e8f34a09 c7e3f09d_f30deb72 b2bde1d0_91d7a344 9a9da25e_a61c257f 1e5e90d0_c05d0f5f f407f24a_8d6f5b}}, driven_packetqueue[port=1].size()=1\n            55020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20028, error: 0, timestamp_ps=4722653469251469312, data: {size: 91, data: 1b587bc2_5afc85f9 9beb0c47_8609f268 81f659c0_14e798e5 d6a3db59_dc884e75 a894f96e_03f682e3 7a1c7295_1d89cfba e3a1ad38_0c05c08e 23e2d9d3_79b8d890 9cacd566_35265aed f90a238e_2871e1fa 9bb6a476_c7c3d09a 41a2f8}}, driven_packetqueue[port=2].size()=1\n            59020000 TOP.tb.add_rand_packet: port=0, pkt={id: 29, error: 0, timestamp_ps=4723190340163469312, data: {size: 169, data: 1a6b1bd0_ea823134 0f6852fa_aaef2bc2 0bd7a5a3_f3ac1d10 fc531b78_dd7055fe 152be910_474c7a76 26551a6b_c6425dfe 6aa9ac3c_7f0eaf51 b9bde0fb_0668b815 af64dcc2_e4374900 46727723_145b0dd2 1e9ca57a_6ed658f8 81c7de3c_2f7c2f66 91941ead_343d0ff2 9b3d526a_592f878d 7491933d_b94bf01d da032559_2562ad58 16b54a16_d3355d1e e633b042_2d1fd147 1769759a_4be4a337 f9186c86_0db08dd3 eed4d996_74199250 69}}, driven_packetqueue[port=0].size()=1\n            59020000 TOP.tb.add_rand_packet: port=0, pkt={id: 30, error: 0, timestamp_ps=4723190340163469312, data: {size: 157, data: b45c2d35_cba03590 eed196e2_129c0b53 ea4f152b_9043d557 f8cde632_e711c9f1 6499e7f5_27239d6d a6bf7d94_f07c4060 8a6f5737_f9e2e54b f88e05eb_78783aa7 51bba0ca_498fad31 5d637806_32f6a19d 97707525_c89ba856 e8bfc9f4_0f838d58 91aa7d0d_1e5456e3 9b6fafbd_3d4fa3cf 6dc63efa_51052c17 9a78f1bd_6b0f7e00 d31c1f23_9426de0f 8fcbb283_c2f785a4 4b4157fd_1a03064e 08e9d688_2c}}, driven_packetqueue[port=0].size()=2\n            64020000 TOP.tb.add_rand_packet: port=0, pkt={id: 31, error: 0, timestamp_ps=4723861428803469312, data: {size: 144, data: 20267708_40afc110 d1258d41_11aa645b 735682e8_fb749753 ecbf9fe0_bcc57e7f c4ce0528_13d7eb99 90921b96_46551206 264f1cb2_4595fee5 0cec43fa_01bd684b b05f9638_cb8aa4eb 38588fd3_cebca61f f57d9af3_9f9aa7d4 f395ebfb_4a35d211 210184c9_009bb96d 0a539dfc_8c2091d2 32fbf8c3_e919dfce 62525ca4_4f433519 28f98ec6_d5bbd1a6 ed6d9c96_6571f582}}, driven_packetqueue[port=0].size()=1\n            64020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10032, error: 0, timestamp_ps=4723861428803469312, data: {size: 83, data: e120dfff_e1b45bc7 c174035a_64311d1f 0728b26d_192c6b6a 72174dc2_44a9dff4 fa58d7a9_c86fa0dc 199fe8c6_c86758e1 385cc0cd_db386419 0ec6b29a_9b90b7f7 c4f24f99_958b7937 ac4845a0_d0b66187 8a8095}}, driven_packetqueue[port=1].size()=1\n            68020000 TOP.tb.add_rand_packet: port=0, pkt={id: 33, error: 0, timestamp_ps=4724337154413559808, data: {size: 102, data: c9868489_a610fb04 b26f8595_4d0d6b0d e50134ff_0f7fc2ef 91be4629_45da6be9 df94be77_69d6d5ba ad76d1a6_c4a5b0c9 b38fb783_e10413b5 0dac8fd2_023e4f4a 53e21aed_3effab27 95507f98_e47720aa 0157a94a_e3b47040 334de8e1_cdcdaacf c6740d44_4c3b}}, driven_packetqueue[port=0].size()=1\n            68020000 TOP.tb.add_rand_packet: port=0, pkt={id: 34, error: 0, timestamp_ps=4724337154413559808, data: {size: 195, data: d021d22e_2bc01c87 7bcff4e7_1d65e2a0 2e6b982b_e1e7a8a9 2d4103b0_037f4c90 6f6c4827_dcad2b6e b76b0d03_4a60fb03 89c2a588_98db0398 7ddfc2de_28a8f223 0eb6f587_4521f410 d0811cd8_155bc5bc 5c721a1e_16e7524c 04af7bda_c909fc24 1ea57b5c_0bcdda2a 285d38c4_a8d96332 990aa9dc_c23eab0e 7445828b_ebc3109d 17e7eafa_7948fc51 3635da11_2e1240c0 83429a26_d3ae059d 72b2d955_2dee6c17 9788d7fb_2b2569bc 164a25b1_be036c5e aae95bd0_5264bc34 d4716ec2_18f6fcac 80c87d}}, driven_packetqueue[port=0].size()=2\n            73020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20035, error: 0, timestamp_ps=4724672698733559808, data: {size: 176, data: 3005e909_8829a63d e3a7610c_3f98b2ea bbb73818_92dcb370 417e8ebe_920d23b0 ff743d14_6b3d07c8 d973556e_521f1c50 ef3abcf6_49975640 5bc2a958_cd04a0ec b2a6b3da_a69ee6ea cd30605e_d588ccd8 eecac504_949d268c a31ac55d_114fd323 ff18644c_dab631ab 4aefe2ff_65d5441a 752018b3_16e5c86d c74f9067_95224df9 d638503e_9b86b3eb c9c73c5c_bcd553c2 353a6270_cbac619f 5436870d_de07d978 9e23cf0a_6fd10e9a f8fc8e69_69200b1c}}, driven_packetqueue[port=2].size()=1\n            73020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10036, error: 0, timestamp_ps=4724672698733559808, data: {size: 68, data: f55bdbb4_674cc8ec 8aab18b2_23db1ee2 0019f589_b2564bba f1b7cc63_e270dab4 04804971_213394f1 c9345d0f_f6254af0 ba6aa553_951fa53e 1d1ff967_7ea08af9 496e67fe}}, driven_packetqueue[port=1].size()=1\n            77020000 TOP.tb.add_rand_packet: port=0, pkt={id: 37, error: 0, timestamp_ps=4724941134189559808, data: {size: 168, data: d0c136ca_9f56457d 4cbc2156_047c5a78 860732ee_df86620d 1379dda3_4000e1c9 65e1e077_15a4a8b2 5bf57fd6_69dd8288 7ce46d94_0c225466 276d6a54_612ad533 ce0b7b50_ae21445d 74bcd68d_054d4b23 45bdac65_bd4ba358 d44fd8c7_154face4 016054aa_e68c344d a0153734_4d0e2e32 5633d257_0a04ded0 d966f87f_4c73c37b 91fb2789_b4316e6d caec95ef_a8cab959 bb9dbc8f_c353d60b 3d734e1f_08503da4 46dfb25e_6a595f28}}, driven_packetqueue[port=0].size()=1\n            77020000 TOP.tb.add_rand_packet: port=0, pkt={id: 38, error: 0, timestamp_ps=4724941134189559808, data: {size: 169, data: e72c3894_e80b3af7 a93a8583_6747ce3f 2355e90a_57990859 98c5171c_664fc581 ff6cba26_51580f57 1f390994_a6e8e239 4272fe9e_3badecea 1b10ea05_0fbbf7ca 76e36f36_27e34bd6 baffe062_9f4c757c 4fde3996_398ea046 515befbc_427a2462 2da0672a_6ed52bca 1599aa78_4ff3a3fd 861d1024_59c5f537 a27ff0d9_d4998a50 2476b76c_353ab230 4c25154e_1496b453 e929b0ff_28ffb169 6a2a5a77_595f509d 35bb75d9_47ad4493 f1}}, driven_packetqueue[port=0].size()=2\n            82020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20039, error: 0, timestamp_ps=4725276678509559808, data: {size: 111, data: cdd3efb4_050dd3a3 c6a92fb0_b445da22 9926395e_e62573a4 26c21703_80e7597f 2c11d543_4ae898c3 7fa76adc_7e19b947 7ae2b380_68fc1e3e cf4a72a8_ccf49b4d 0c7e47ca_a91ee613 b0753008_81357205 ded8b308_a1e1c3d4 5c15254b_aea03491 949dae64_21ede9cd 177f9bbf_2f1b55}}, driven_packetqueue[port=2].size()=1\n            82020000 TOP.tb.add_rand_packet: port=0, pkt={id: 40, error: 0, timestamp_ps=4725276678509559808, data: {size: 136, data: 8779ca70_551c129d 3da75d80_9bb1d20d d76dd940_bfd8e2f7 b69bb1f1_1e2e214f 7655a8b7_c31d6b33 4924bd55_1c660776 ef1e77d3_aa30ede9 280f3f48_17540266 4a14a52a_65ad2d66 718cec79_dfa53f1f c8dce10c_deed3d29 33a691e6_d54c8e8a eb8a5c4c_a15ea04f 81ce348a_ee0dcae2 d6c3bf9d_a0fde39a 4d71ccb0_dee8f0f1 61e11127_84812ee4}}, driven_packetqueue[port=0].size()=1\n            86030000 TOP.tb.main: Monitor queues: mon queue size=0\n            86050000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n            86050000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n            86055000 TOP.tb.u_mon: num_packets_received=40\n            86055000 TOP.tb.gen_drv[0].u_drv: num_packets_driven=14\n            86055000 TOP.tb.gen_drv[1].u_drv: num_packets_driven=14\n            86055000 TOP.tb.gen_drv[2].u_drv: num_packets_driven=12\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 86us; walltime 0.136 s; speed 635.150 us/s\n- Verilator: cpu 0.135 s on 1 threads; alloced 505 MB\n",
    "stderr": "%Warning-UNOPTFLAT: dut.sv:24:9: Signal unoptimizable: Circular combinational logic: 'tb.u_dut.last_beat'\n   24 |   logic last_beat;\n      |         ^~~~~~~~~\n                    ... For warning description see https://verilator.org/warn/UNOPTFLAT?v=5.028\n                    ... Use \"/* verilator lint_off UNOPTFLAT */\" and lint_on around source to disable this message.\n                    dut.sv:24:9:      Example path: tb.u_dut.last_beat\n                    dut.sv:38:16:      Example path: ASSIGNW\n                    dut.sv:22:9:      Example path: tb.u_dut.update_arb\n                    tb.sv:4070:5:      Example path: ALWAYS\n                    tb.sv:4030:41:      Example path: tb.u_dut.u_rrarb.gen_Ninput.select_d\n                    dut.sv:71:15:      Example path: ASSIGNW\n                    tb.sv:4192:37:      Example path: tb.outAxi4St\n                    dut.sv:34:20:      Example path: ASSIGNW\n                    dut.sv:24:9:      Example path: tb.u_dut.last_beat\n",
    "pass": true,
    "score": 99,
    "warnings": 1,
    "errors": 0,
    "runtime": 3.3423876762390137,
    "batch_iter": 9,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_9",
    "start_time": 1733526072.2548478,
    "stop_time": 1733526075.5972354
  },
  {
    "index": 7,
    "dut": "module dut #(\n  parameter int NumPorts = 4,\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int MacTableDepth = 16,\n  parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000,\n  parameter int FifoPacketMtuInBytes = 1504,\n  parameter int FifoSizeInBytes = 4096,\n  parameter int MaxNumberOfPackets = 32,\n  parameter IngressPrefillBytes = -1\n) (\n  input logic clock,\n  input logic reset,\n  \n  input AxiStreamType [NumPorts-1:0] inAxi4St,\n  output logic [NumPorts-1:0] inTready,\n  \n  output AxiStreamType [NumPorts-1:0] outAxi4St,\n  input logic [NumPorts-1:0] outTready,\n  \n  output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n// MAC table entry struct\ntypedef struct packed {\n  logic valid;\n  logic [47:0] mac_addr;\n  logic [$clog2(NumPorts)-1:0] port;\n  logic [31:0] age_counter;\n} mac_entry_t;\n\n// MAC table\nmac_entry_t [MacTableDepth-1:0] mac_table;\n\n// Parser instances and signals\nAxiStreamType [NumPorts-1:0] parser_out;\nlogic [NumPorts-1:0] parser_valid;\nlogic [NumPorts-1:0][47:0] parsed_dest_mac;\nlogic [NumPorts-1:0][47:0] parsed_source_mac;\nlogic [NumPorts-1:0] parser_ready;\n\n// Generate parser instances\ngenvar i;\ngenerate\n  for(i = 0; i < NumPorts; i++) begin : g_parser\n    local_axist_eth_parser #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n    ) parser_inst (\n      .clock(clock),\n      .reset(reset),\n      .inAxi4St(inAxi4St[i]),\n      .inTready(parser_ready[i]),\n      .outAxi4St(parser_out[i]),\n      .outTready(1'b1),\n      .outParsedValid(parser_valid[i]),\n      .outParsedDestMac(parsed_dest_mac[i]),\n      .outParsedSourceMac(parsed_source_mac[i])\n    );\n  end\nendgenerate\n\n// FIFO instances for each egress port\nAxiStreamType [NumPorts-1:0][NumPorts-1:0] fifo_out;\nlogic [NumPorts-1:0][NumPorts-1:0] fifo_valid;\nlogic [NumPorts-1:0][NumPorts-1:0] fifo_ready;\n\n// Generate FIFO instances\ngenerate\n  for(i = 0; i < NumPorts; i++) begin : g_fifo\n    for(genvar j = 0; j < NumPorts; j++) begin : g_fifo_port\n      local_axist_storefwd_fifo #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ExtraDataWidth(1),\n        .PacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .MaxNumberOfPackets(MaxNumberOfPackets)\n      ) fifo_inst (\n        .clock(clock),\n        .reset(reset),\n        .inAxi4St(parser_out[i]),\n        .inError(1'b0),\n        .inExtra(1'b0),\n        .inTready(fifo_ready[i][j]),\n        .outAxi4St(fifo_out[i][j]),\n        .outError(),\n        .outExtra(),\n        .outTready(outTready[j]),\n        .inFifoAfull(),\n        .inDropEvent(),\n        .outDropEvent()\n      );\n    end\n  end\nendgenerate\n\n// Assign all inTready to 1\nassign inTready = {NumPorts{1'b1}};\n\n// Drive egressFifoDropEvents to 0\nassign egressFifoDropEvents = '0;\n\n// MAC table lookup and update logic\nalways_ff @(posedge clock) begin\n  if (reset) begin\n    mac_table <= '{default:'0};\n  end else begin\n    // Age counters\n    for (int i = 0; i < MacTableDepth; i++) begin\n      if (mac_table[i].valid) begin\n        if (mac_table[i].age_counter >= MacTableCyclesPerEpoch) begin\n          mac_table[i].valid <= 1'b0;\n        end else begin\n          mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n        end\n      end\n    end\n\n    // Process source MACs\n    for (int port = 0; port < NumPorts; port++) begin\n      if (parser_valid[port]) begin\n        // Learn source MAC\n        logic found = 0;\n        for (int i = 0; i < MacTableDepth; i++) begin\n          if (mac_table[i].valid && mac_table[i].mac_addr == parsed_source_mac[port]) begin\n            mac_table[i].port <= port;\n            mac_table[i].age_counter <= '0;\n            found = 1;\n            break;\n          end\n        end\n        \n        if (!found) begin\n          // Find empty slot\n          for (int i = 0; i < MacTableDepth; i++) begin\n            if (!mac_table[i].valid) begin\n              mac_table[i].valid <= 1'b1;\n              mac_table[i].mac_addr <= parsed_source_mac[port];\n              mac_table[i].port <= port;\n              mac_table[i].age_counter <= '0;\n              break;\n            end\n          end\n        end\n      end\n    end\n  end\nend\n\n// Output mux logic\nalways_comb begin\n  for (int out_port = 0; out_port < NumPorts; out_port++) begin\n    outAxi4St[out_port] = fifo_out[0][out_port];\n    for (int in_port = 1; in_port < NumPorts; in_port++) begin\n      if (fifo_out[in_port][out_port].tvalid) begin\n        outAxi4St[out_port] = fifo_out[in_port][out_port];\n      end\n    end\n  end\nend\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module does not need to support a 'ready' output signal for backpressure for the inAxi4St inputs, it is assumed these are received Ethernet frames coming from an Ethernet MAC Rx that does not support flow control with a 'ready' signal.\nThe module does need to support 'outReady' input signals for each transmit port, since outAxi4St will connect four Ethernet MAC Transmit ports.\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n     -- parameter int FifoPacketMutInBytes = 1504\n        -- Maximum Ethernet Frame size, in bytes.\n     -- parameter int FifoSizeInBytes = 4096\n        -- Maximum FIFO size for a single FIFO within the design, in bytes. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be internally stored for any single ingress to egress AxiStreamType output bus (outAxi4St[tx_port]).\n           For Example, if NumPorts=4, and all four ports inAxi4St[3:0] have frames with Destination MAC that steer to outAxi4St[0] (egress port 0), outAxi4St[0] can only egress one data phit per cycle, while four ports are queuing a total of four data phits per cycle. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n\nAdditionally, you have some helper modules that you must use (the internals are not shown)\n\nmodule local_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\nThis module takes an AXI4 Stream input (inAxi4St struct, flow control inTready), and outputs a delayed version of\nthe packet on an AXI4 Stream output (outAxi4St, flow control outTready). outParsedValid=1 on the first data phit\noutput from outAxi4St. outParsedDestMac and outParsedSourceMac are valid when outParsedValid=1.\n\n\nmodule local_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 1,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidth - 1 : 0]    inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidth - 1 : 0]    outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n\nThis module takes an AXI4 Stream input (inAxi4St struct, flow control inTready), and outputs a store-and-forwarded version of\nthe packet on an AXI4 Stream output (outAxi4St, flow control outTready). You can ignore inError (connect to 1'b0), inExtra, outError, and outExtra. This could be useful on an AXI4 Stream from an Ethernet Receive port, to ensure an entire packet is stored prior to sending it to a Transmit Ethernet port.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/local_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = local_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/local_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = local_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_6_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_l2_switch_6",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_10/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -x c++-header Vtb__pch.h -o Vtb__pch.h.fast.gch\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -x c++-header Vtb__pch.h -o Vtb__pch.h.slow.gch\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb___024root__Slow.o Vtb___024root__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb___024root__DepSet_hfe20aad3__0__Slow.o Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb___024root__DepSet_ha183790c__0__Slow.o Vtb___024root__DepSet_ha183790c__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_oclib_assert_pkg__Slow.o Vtb_oclib_assert_pkg__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.o Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_pkg__Slow.o Vtb_ocsim_pkg__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.o Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.o Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_local_axist_eth_parser__Tz1_A8__Slow.o Vtb_local_axist_eth_parser__Tz1_A8__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_local_axist_eth_parser__Tz1_A8__DepSet_ha8209eed__0__Slow.o Vtb_local_axist_eth_parser__Tz1_A8__DepSet_ha8209eed__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_local_axist_eth_parser__Tz1_A8__DepSet_h73838ce2__0__Slow.o Vtb_local_axist_eth_parser__Tz1_A8__DepSet_h73838ce2__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_local_axist_storefwd_fifo__pi1__Slow.o Vtb_local_axist_storefwd_fifo__pi1__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h487cff59__0__Slow.o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h487cff59__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h5347ac96__0__Slow.o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h5347ac96__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_packet_pkg__Slow.o Vtb_ocsim_packet_pkg__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb__Syms.o Vtb__Syms.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb.o Vtb.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__0.o Vtb___024root__DepSet_hfe20aad3__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__1.o Vtb___024root__DepSet_hfe20aad3__1.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__2.o Vtb___024root__DepSet_hfe20aad3__2.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__3.o Vtb___024root__DepSet_hfe20aad3__3.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_ha183790c__0.o Vtb___024root__DepSet_ha183790c__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb_local_axist_eth_parser__Tz1_A8__DepSet_ha8209eed__0.o Vtb_local_axist_eth_parser__Tz1_A8__DepSet_ha8209eed__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h487cff59__0.o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h487cff59__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h487cff59__1.o Vtb_local_axist_storefwd_fifo__pi1__DepSet_h487cff59__1.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb__main.o Vtb__main.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_10/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.452 MB sources in 30 modules, into 4.527 MB in 28 C++ files needing 0.002 MB\n- Verilator: Walltime 4.905 s (elab=0.014, cvt=0.296, bld=4.115); cpu 0.861 s on 64 threads; alloced 184.914 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.unnamedblk2: TB mac address 0: 0x00c41e5d9c00\n                   0 TOP.tb.unnamedblk2: TB mac address 1: 0x0002c2e0e401\n                   0 TOP.tb.unnamedblk2: TB mac address 2: 0x0078d58ebc02\n                   0 TOP.tb.unnamedblk2: TB mac address 3: 0x00b614ffe403\n                   0 TOP.tb.uCONTROL.main: TEST START\n               20000 TOP.tb.main: Start\n               20000 TOP.tb.main: Driving on port0, broadcast/multicast\n            11020000 TOP.tb.main: Driving on port0, broadcast/multicast\n            27020000 TOP.tb.main: Driving on port0, broadcast/multicast\n            36020000 TOP.tb.main: Driving on port0, broadcast/multicast\n            49020000 TOP.tb.main: Driving on port0, broadcast/multicast\n            59020000 TOP.tb.send_and_check_multicast_rand_packet: Driving broadcast/multicast on srcport=1\n[89840000] %Error: tb.sv:1589: Assertion failed in TOP.ocsim_packet_pkg.compare_packets:             89840000 TOP.ocsim_packet_pkg.compare_packets: (got.data.size()) (000001b8) NOT EQ (want.data.size()) (00000411) at tb.sv:1589\n%Error: tb.sv:1589: Verilog $stop\nAborting...\n",
    "stderr": "",
    "pass": false,
    "score": 80,
    "warnings": 0,
    "errors": 0,
    "runtime": 5.28695821762085,
    "batch_iter": 10,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_10",
    "start_time": 1733526072.2860823,
    "stop_time": 1733526077.5730405
  },
  {
    "index": 12,
    "dut": "module dut #(\n  parameter int Depth = 8,\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1,\n  parameter int unsigned AlmostFull = (Depth - 8),\n  parameter int unsigned AlmostEmpty = 0,\n  parameter bit PreferSrl = 0,\n  parameter int unsigned CountWidth = $clog2(Depth + 1)\n) (\n  input logic clock,\n  input logic reset,\n  input AxiStreamType inAxi4St,\n  output logic inTready,\n  output AxiStreamType outAxi4St,\n  input logic outTready,\n  output logic [CountWidth-1:0] inCount,\n  output logic [CountWidth-1:0] outCount,\n  input logic inError,\n  input logic [ExtraDataWidth-1:0] inExtra,\n  output logic outError,\n  output logic [ExtraDataWidth-1:0] outExtra,\n  output logic almostFull,\n  output logic almostEmpty\n);\n\n  // Check Depth parameter is legal (0 or power of 2)\n  initial begin\n    if (Depth != 0) begin\n      assert((Depth & (Depth-1)) == 0) else\n        $error(\"Depth must be 0 or a power of 2\");\n      assert(Depth != 1) else\n        $error(\"Depth of 1 is not supported\");\n    end\n  end\n\n  // Bypass mode when Depth = 0\n  generate\n    if (Depth == 0) begin : bypass_gen\n      always_comb begin\n        outAxi4St = inAxi4St;\n        inTready = outTready;\n        outError = inError;\n        outExtra = inExtra;\n        inCount = '0;\n        outCount = '0;\n        almostFull = 1'b0;\n        almostEmpty = 1'b1;\n      end\n    end\n    else begin : fifo_gen\n\n      // Pack AXI stream signals into FIFO data type\n      typedef struct packed {\n        logic [AxiStreamWidth-1:0] tdata;\n        logic tkeep;\n        logic tuser;\n        logic tlast;\n        logic [ExtraDataWidth-1:0] extra;\n        logic error;\n      } fifo_data_t;\n\n      fifo_data_t fifo_in, fifo_out;\n\n      // Pack input data\n      always_comb begin\n        fifo_in.tdata = inAxi4St.tdata;\n        fifo_in.tkeep = inAxi4St.tkeep;\n        fifo_in.tuser = inAxi4St.tuser;\n        fifo_in.tlast = inAxi4St.tlast;\n        fifo_in.extra = inExtra;\n        fifo_in.error = inError;\n      end\n\n      // Instantiate FIFO\n      local_fifo #(\n        .Width($bits(fifo_data_t)),\n        .Depth(Depth),\n        .DataType(fifo_data_t),\n        .AlmostFull(AlmostFull),\n        .AlmostEmpty(AlmostEmpty),\n        .CountWidth(CountWidth)\n      ) u_fifo (\n        .clock(clock),\n        .reset(reset),\n        .almostFull(almostFull),\n        .almostEmpty(almostEmpty),\n        .inCount(inCount),\n        .outCount(outCount),\n        .inData(fifo_in),\n        .inValid(inAxi4St.tvalid),\n        .inReady(inTready),\n        .outData(fifo_out),\n        .outValid(outAxi4St.tvalid),\n        .outReady(outTready)\n      );\n\n      // Unpack output data\n      always_comb begin\n        outAxi4St.tdata = fifo_out.tdata;\n        outAxi4St.tkeep = fifo_out.tkeep;\n        outAxi4St.tuser = fifo_out.tuser;\n        outAxi4St.tlast = fifo_out.tlast;\n        outExtra = fifo_out.extra;\n        outError = fifo_out.error;\n      end\n\n    end\n  endgenerate\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a simple ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported.\n\nAdditionally, you must use an existing module named 'local_fifo', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_fifo #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter int  CountWidth        = $clog2(Depth + 1)\n  )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 8\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 0, or a power-of-2.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned AlmostFull = (Depth - 8)\n        -- Number of entries (less than or equal to Depth), that if this many entries or more are occupied in the FIFO, module output almostFull is set to 1.\n     -- parameter int unsigned AlmostEmpty = 0\n        -- Number of entries: that if fewer than this many entries are occupied in the FIFO, module output almostEmpty is set to 1.\n     -- parameter bit          PreferSrl = 0\n        -- Style of the underlying FIFO. This can be left at value 0 and not used internally, but must exist in the parameter list.\n     --  parameter int unsigned CountWidth     = $clog2(Depth + 1)\n        -- Width in bits for module outputs inCount and outCount.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n       -- All fields of inAxi4St, except tvalid, must be stored in the FIFO if DEPTH > 0.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: inCount\n       -- output logic [CountWidth - 1 : 0] inCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if inCount==Depth, then inTready should be 0, because the FIFO is full.\n    -- Output: outCount\n       -- output logic [CountWidth - 1 : 0] outCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if outCount==0, then outAxi4St.tvalid should be 0, because the FIFO is empty\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: almostFull\n       -- output logic almostFull\n       -- is 1 when inCount >= AlmostFull\n    -- Output: almostEmpty\n       -- output logic almostEmpty\n       -- is 1 when outCount <= AlmostEmpty\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_simple_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_simple_fifo\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_simple_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_3_test_sim/local_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = local_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = local_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_simple_fifo_3",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_11/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_11/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.290 MB sources in 18 modules, into 0.215 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 0.747 s (elab=0.006, cvt=0.057, bld=0.281); cpu 1.132 s on 64 threads; alloced 150.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           410030000 TOP.tb.main: Monitor queues: mon queue size=0, drv queue size=0\n           410050000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n           410050000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n           410055000 TOP.tb.u_drv: num_packets_driven=100\n           410055000 TOP.tb.u_mon: num_packets_received=100\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 410us; walltime 0.324 s; speed 1.265 ms/s\n- Verilator: cpu 0.324 s on 1 threads; alloced 505 MB\n",
    "stderr": "%Warning-UNSIGNED: tb.sv:3856:34: Comparison is constant due to unsigned arithmetic\n                                : ... note: In instance 'tb.u_dut.fifo_gen.u_fifo'\n 3856 |         almostFull <= (depthNext >= AlmostFull);\n      |                                  ^~\n                   ... For warning description see https://verilator.org/warn/UNSIGNED?v=5.028\n                   ... Use \"/* verilator lint_off UNSIGNED */\" and lint_on around source to disable this message.\n",
    "pass": true,
    "score": 99,
    "warnings": 1,
    "errors": 0,
    "runtime": 1.2313902378082275,
    "batch_iter": 11,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_11",
    "start_time": 1733526072.321751,
    "stop_time": 1733526073.5531414
  },
  {
    "index": 14,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int AxiStreamWidth = 8,\n    parameter int unsigned FlopArbSel = 0,\n    parameter int unsigned FlopOutput = 0,\n    parameter int NumInputs = 4\n)(\n    input logic clock,\n    input logic reset,\n    input AxiStreamType [NumInputs-1:0] inAxi4St,\n    output logic [NumInputs-1:0] inTready,\n    output AxiStreamType outAxi4St,\n    input logic outTready\n);\n    \n    logic [NumInputs-1:0] requests;\n    logic [NumInputs-1:0] grant;\n    logic [$clog2(NumInputs)-1:0] priority_ptr;\n    logic [$clog2(NumInputs)-1:0] selected_input;\n    logic frame_active;\n    \n    // Generate request vector from input tvalid signals\n    always_comb begin\n        for (int i=0; i<NumInputs; i++) begin\n            requests[i] = inAxi4St[i].tvalid;\n        end\n    end\n    \n    // Round robin arbiter\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            priority_ptr <= '0;\n            frame_active <= 1'b0;\n        end else begin\n            if (!frame_active && |requests) begin\n                // Look for first request starting at priority_ptr\n                logic found = 1'b0;\n                for (int i=0; i<NumInputs; i++) begin\n                    automatic int idx = (priority_ptr + i) % NumInputs;\n                    if (!found && requests[idx]) begin\n                        selected_input <= idx[$clog2(NumInputs)-1:0];\n                        found = 1'b1;\n                    end\n                end\n                frame_active <= 1'b1;\n            end\n            else if (frame_active && outAxi4St.tvalid && outTready && outAxi4St.tlast) begin\n                frame_active <= 1'b0;\n                priority_ptr <= selected_input + 1;\n            end\n        end\n    end\n    \n    // Generate grant vector\n    always_comb begin\n        grant = '0;\n        if (frame_active) begin\n            grant[selected_input] = 1'b1;\n        end\n    end\n    \n    // Generate output signals\n    always_comb begin\n        outAxi4St = '0;\n        for (int i=0; i<NumInputs; i++) begin\n            if (grant[i]) begin\n                outAxi4St = inAxi4St[i];\n            end\n        end\n    end\n    \n    // Generate ready signals\n    always_comb begin\n        inTready = '0;\n        for (int i=0; i<NumInputs; i++) begin\n            if (grant[i]) begin\n                inTready[i] = outTready;\n            end\n        end\n    end\n    \nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rrarb_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb_test.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb_test;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  oclib_axist_rrarb\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : oclib_axist_rrarb_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : tb\n",
    "name": "test_axist_rrarb_2",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_12/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_axist_driver__DepSet_hbd398ec9__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_axist_driver__Slow.cpp Vtb_ocsim_axist_driver__DepSet_hbd398ec9__0__Slow.cpp Vtb_ocsim_axist_driver__DepSet_h608c9d06__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_12/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.309 MB sources in 19 modules, into 1.090 MB in 20 C++ files needing 0.007 MB\n- Verilator: Walltime 2.978 s (elab=0.009, cvt=0.064, bld=2.484); cpu 1.625 s on 64 threads; alloced 159.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20001, error: 0, timestamp_ps=4671226772094713856, data: {size: 80, data: 02e478bc_b6e4b753 21e1c582_62351256 fdf43b58_b25c1e9e 9eee1076_63c01d22 06816378_6fcef7d1 9e776ea8_4fbb94e2 661f09e3_1f84c533 4b9cf3c9_edca5d47 24efa96d_3978eac2 5454239d_b3add52e}}, driven_packetqueue[port=2].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20002, error: 0, timestamp_ps=4671226772094713856, data: {size: 99, data: d789f6af_ef9d3fcf 2a779a0b_53af8c02 fbe8c2dd_c86461e5 21f359f5_bd7e62ca 90455810_6073fc3d 6c0ee737_4740331c b6d73a67_5384f4e4 2867953c_64958a3d 7f5bdcec_c6467904 d434bd1b_02715363 def0045f_f8238061 6157d2fc_bc7b317e ed64d4}}, driven_packetqueue[port=2].size()=2\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10003, error: 0, timestamp_ps=4671226772094713856, data: {size: 195, data: cbcbdbe9_4e244207 00d63f39_f9d77a76 7c42ae76_2b27d2a2 06090fdc_e45979ac 80f7ea8d_af8910ca c6ab784c_f75a5411 c9291014_712a318c e682866e_d96e8db8 548d69d6_6e65b257 4e6499a9_4043aaf6 e7d72253_860ee4c9 4049f309_f85b9610 826dde1b_80dd3b7a 9f0ab89c_d3b44983 dce9561f_5f658cd8 ed68193c_c56723bf 01844393_231b47e8 a96a799a_4ef32f29 f18066a9_916155e2 0486cee7_d19b4c7e 986d3184_2037d10b cfd7ac20_4dc8c2dc abbab4c6_0314de4e ab49162c_91c50798 169624}}, driven_packetqueue[port=1].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20004, error: 0, timestamp_ps=4671226772094713856, data: {size: 114, data: fc4972c0_b43c151f 8dc37444_8556cb91 eaa4bb97_054192fa 1471e190_dd5abc7f dfc2b2e4_08607d84 d1ac4b17_84e68979 a9080756_5bd44c8f acf0adee_cb380c0e ab8145be_8462cde9 b31f2220_e662fa6e a7ded685_a3a55bb9 9c71786e_59657165 da867758_3750cb24 6c0f8bec_a266d95e 37db}}, driven_packetqueue[port=2].size()=3\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10005, error: 0, timestamp_ps=4671226772094713856, data: {size: 195, data: 553c5e89_da01634e 9bccda12_1f909132 94c2c573_eca81d11 a9ad035c_08585e1a f004278b_15b80e58 be09cdc0_46309a87 4ac2cd1f_def29988 ffbfea3e_3c17508a ffdc288a_d86e3c1f 935a5c59_b59bccf8 cec85d25_68b168b0 87b12106_8e6bd938 22ffd2c2_de5f172b 9a6d40c2_07153d69 607e037e_40fedb6d 3e887dc5_c6f61368 0effee13_309a479b c6d1522d_57417f37 0bd63f1c_2d131288 a8612ecc_d7be9be5 c2c639f1_15a57a80 24e47f75_1b73326c 7960c0ec_ee33d95b 4bd14f5a_574005ad b9bbce}}, driven_packetqueue[port=1].size()=2\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 6, error: 0, timestamp_ps=4671226772094713856, data: {size: 96, data: cfe4a9fd_cba357b0 abdc957d_da5eb2a2 dcac2d5f_0955120b f45a677b_062e3354 ce2a62bc_0fe01f5d eed8c7d1_d2f8b199 a8cf8c5e_433a0a33 df8d2c81_bfe7066c c682856b_f0908540 12cabcae_430dc2ee 58bc411f_c07275d8 f6df60c7_c9601b5d}}, driven_packetqueue[port=0].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20007, error: 0, timestamp_ps=4671226772094713856, data: {size: 176, data: 9b5c176e_33505407 3db302a7_4e45cf0f a9c954ed_41d5fb50 f02c0f06_ffb1977f bbc0e8eb_987d144e 842448e6_4e1fb34f ec9c1d87_30aa365b bc2cf4a5_7a124404 71f7560d_844ecade 2c0fb7ee_c12e6563 aeeb5a23_a49f943c e690472d_54032386 5494a34b_f3f7a6c5 3a810e58_12e671e4 790f3c47_914f6d0b 10d84089_11f9bd84 7c804bca_4cb85df2 e44451af_40e645b7 58a56ef5_64629819 18f18467_9ca4be19 b64157c7_d75faa16 459161dc_172014f8}}, driven_packetqueue[port=2].size()=4\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 8, error: 0, timestamp_ps=4671226772094713856, data: {size: 154, data: cead5e36_624b7148 e8280743_5520a660 c2352099_180483d9 336498e7_431c9d52 6fe54837_4b7238ae 3c293667_a5e4b0a6 90063ebb_d9d7611c 14bdee3a_f66ee422 5b0b5328_4165ac16 6a7e4bb0_2dd4531b 138fba9a_9d5f5c7f 98bf7b1b_eb4e86e0 55aece2b_08533d8f a6c48afd_63838295 90a82493_249875a3 28566fd0_38a59fa8 d6f5db56_f634efc8 3b7bf6b3_e3de105f 17cdc0f3_ff9bda61 855b}}, driven_packetqueue[port=0].size()=2\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10009, error: 0, timestamp_ps=4671226772094713856, data: {size: 142, data: 3e6d9791_226e1f7f 1180f269_91ee78f9 8af08984_349aa2a1 e5ffcb7f_ff1151e4 d6bab4e1_46a312d3 6d919edc_7e304ca5 a1a1daba_72ef6d58 641e6d17_1f052219 b30de20e_dbbed225 1b72989e_419e92af c7bf9343_17037aaa 9274a505_56b6fb67 8dd184d5_3a4917df bfd08fab_630ac9a5 476f00fc_67022d7d 77b49490_4927d802 45894eae_0b321591 dce9d991_6027}}, driven_packetqueue[port=1].size()=3\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10010, error: 0, timestamp_ps=4671226772094713856, data: {size: 93, data: b00a7bc8_43a8df1e 9b4b300c_386f3a56 ec120782_fc862d84 5f5c8ce4_377891f7 3e222c9c_28df1c8e 5d600612_e3bb22fa b9577d7e_1d20e65d dbf514ed_3b5be2fd 62026d88_1483a582 d58fc555_4860772a 5ae14a97_55dbf619 54e769b8_19}}, driven_packetqueue[port=1].size()=4\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10011, error: 0, timestamp_ps=4671226772094713856, data: {size: 177, data: 769addce_b60ec640 ae389d0b_d7af38d5 f556722e_50e9894d f090fa19_50963224 fa689a24_60b7f28c 86d6df68_a9850455 e7dde760_efe9bddd 58f2c9f9_3dcd605e 9731a485_39f47741 893df4f0_4d7a9efd 13b9bdd3_8770fa68 5a9346bb_e9465d93 1390df7d_f7cd2595 fe6c49f7_a471a570 45ff9b1e_98966a53 d81b1823_1c1abcf9 865a05e2_282674cb 22824d9d_ca7eed6e 0b26e083_deb5daa2 ec6148f3_dfb84bd1 84ac2e6c_d70e09e8 4b0a2348_674b4027 3b}}, driven_packetqueue[port=1].size()=5\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 12, error: 0, timestamp_ps=4671226772094713856, data: {size: 168, data: c0643af4_b57704ca ff88dcee_0e9a784f e483166d_24b56b36 ed112fef_0933189c a239a6fc_51756564 185a19ff_d5efd0b7 cfda1789_1c52fe34 37c2b179_763b651f 7e622a51_e42a1b06 6a261fdc_846abc49 6d3053eb_6f93be00 b61a9945_f8a9de8c 8be688e8_5bc3905f adbfd07f_46f5f3a1 383f7900_921ab66f fe8abb2b_61380745 ff9256b3_1cc5deac b86798a6_2cb35f8f 4a9c11cd_e4e0cbc9 d48d217c_c0833265 f8597a9f_1c8299d0}}, driven_packetqueue[port=0].size()=3\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20013, error: 0, timestamp_ps=4671226772094713856, data: {size: 170, data: 4f0654d3_81ad49f2 1ba3f61f_3f4fc2f0 16c867b4_a5df6c7f 1b53c849_c40f8e46 da13702b_04e48c85 c615f9ef_664f2f7a 19a401ec_6a20bbec c20da0ba_17adcfad 8ae0a818_d858d2b1 9ddf8820_10fa5f41 e0cb2ae4_e4e0954e 239e51fc_efd74b7a 08af3cec_26cc3afc 9e652134_525a329d 6a90bcfc_f1b81798 50c710fc_ce98198e 52241ee1_42707ee8 43b75821_788e86a8 a242304d_d201c399 d899a1cb_b354c3fb 1a799cbe_e491b1e5 2640}}, driven_packetqueue[port=2].size()=5\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20014, error: 0, timestamp_ps=4671226772094713856, data: {size: 164, data: 8252118e_a3fe2adb 1382501e_4fa17966 367dcf0f_f4a658ad af9eac63_a3bfbc9a 347a2bcd_1ead4ce3 616a1840_2e2d2312 e92cc14a_f52db61d 7ae3801b_d4af8186 2298baa0_d3e5a095 f7316f4b_9073d9d6 7fc36d36_91c02a6d 8c4175e1_3df1c554 5e1e543b_28eba30a 4ad28d91_f4296536 90238e01_673cbd0a ed98dcec_2f481980 005c96ef_09cc18e9 9b956827_1639c61e 2a775f17_57287f7e aa21e3b9_5c472385 2d50f60d}}, driven_packetqueue[port=2].size()=6\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20015, error: 0, timestamp_ps=4671226772094713856, data: {size: 134, data: 354fff1c_af606550 bc77a324_8e4e8890 6fb259cc_3f4d186c 93835846_60f40cec bf031d29_7722ffff 41d2f660_bfefea76 25d67b5d_eb895ea4 140b93c5_e8dd14e1 6451068e_46a669b1 35a6224e_974c0ebf c1c44098_c3aa4702 2b792db0_5ef34bdf 57c3d90f_1b21781e bd5cce4f_6359dc52 0126b388_dce72d43 04a971be_1a9142c2 5955e342_4bb6}}, driven_packetqueue[port=2].size()=7\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20016, error: 0, timestamp_ps=4671226772094713856, data: {size: 171, data: c9d7d98a_1cc7baaa 5b904f22_a1cdbe23 efaa25aa_a7c2d218 34148ec8_161fd264 660a3d49_33ad6d73 7ce428af_41b6c6fa ee8291b3_9c5cebfc 29a68d5e_1e6a8646 dd58a0d2_ddfe200f 7892db7a_3e624d49 b9bc192d_91a3257f 5a2899bd_1c6abf13 d77db86c_5dc4385b 5404848a_6c75dedf c49703d7_72b05302 05fe5744_3c09e1ec e2072519_ec6424e7 1d1c41a6_21b5f2cb 730c33a2_b4dd9710 000257d8_4ef9993e c5470ba9_26794855 1ade6c}}, driven_packetqueue[port=2].size()=8\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 17, error: 0, timestamp_ps=4671226772094713856, data: {size: 163, data: 7a2fbc93_7ae1f1c4 523b389f_142f0716 b32bbd81_9b5b3244 177fe500_031bca7f ff14adb1_32f5eb8e d21c1cc0_ee787e03 580613c7_18f4706c c716844e_a3fea752 57abb920_f51c65e5 184fd2cb_b1e62415 1004da76_bb62874f fb4eaa9b_287e3855 d794e5a5_1877cd4b a3a8d387_5b149258 44fc9b9c_b85531e0 2b087968_3149ccc6 9f3b77b6_5bb3caba e2b5e18f_5eb2c4a9 cda00e59_59f845d2 87be6492_f0dfcbfb f6b2e2}}, driven_packetqueue[port=0].size()=4\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10018, error: 0, timestamp_ps=4671226772094713856, data: {size: 107, data: fb6ea7ec_34f1aa5e 4200c0bb_58848e55 32aeaf5b_00deb716 61614cfb_101bc989 67988715_8cbae916 5b860d01_80b689b7 2d934186_ee1b0851 66b8e5fa_298a4a74 d91832b8_855c97c9 1b7f013d_cef00f05 837bca7e_d01fad67 81ac20e5_4ac06d37 55f09ccd_4d7c204c 636d8b}}, driven_packetqueue[port=1].size()=6\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10019, error: 0, timestamp_ps=4671226772094713856, data: {size: 86, data: 277a7c84_f8bc1623 c40953db_ca48b747 decaba69_0c73c6fa 306018f5_3604e787 a5e8f284_087e4ac0 9f2fd098_a98fef0a 86ca1d90_50ea09b0 ea6aedfe_55bdebd2 8295e841_97f33660 24acd18f_d54f191c 5d2f4b16_ebad}}, driven_packetqueue[port=1].size()=7\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 20, error: 0, timestamp_ps=4671226772094713856, data: {size: 151, data: 036af29e_dff23933 206bdf2d_e184a041 95ef52f6_ab55ba71 c390de3e_9c6527b4 d1da5c4b_beec5305 3c144a75_6881bd9c 43ca0ad4_97f0b828 8f792bb4_dae3eb0b 0b1e1272_2b806861 d2cff17a_1093222c 9ef1553e_1b1fe196 09940813_958056ae b294a8ea_da433a85 7846bd57_bb5c45bf edca989d_c547eb25 43480199_30e893d0 b91f4894_9248ede4 9a5f2192_5d051954 d7adc634_9dfd2e}}, driven_packetqueue[port=0].size()=5\n            42020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10021, error: 0, timestamp_ps=4720908638787469312, data: {size: 79, data: 68e5afc0_2899ee2b e3f659fd_fe452be7 5ac5eaf9_26a9f0b3 4a6d3908_f27212fc 7e21b0a9_9ad1ea17 a5a18c59_647b2ed7 f38b59f3_44196cb7 4ba6ffa7_5f81db52 d0408315_d4448131 96bebd20_b72616}}, driven_packetqueue[port=1].size()=1\n            42020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10022, error: 0, timestamp_ps=4720908638787469312, data: {size: 71, data: 54f49b15_7e357569 8869b435_22bbc678 b1e7ca45_1248fb52 1c0737da_af3012b5 16a06f95_994730a3 40b83c5e_247e1c44 0254dbd8_9e653255 0969bef4_b3e96c2f 0e2f7ae1_15ef2b}}, driven_packetqueue[port=1].size()=2\n            45020000 TOP.tb.add_rand_packet: port=0, pkt={id: 23, error: 0, timestamp_ps=4721311291971469312, data: {size: 112, data: 804b72d0_046e4cc9 c043403b_3b1cd9b6 bd2041ad_851b5198 cfb76b40_18e4ba93 be1fdf73_02714ba0 afb8d0ff_42f9536d 7b3f3ede_c9090f33 0b900ad8_4078bb12 83f1755d_caf33736 38ca96d7_390b70ad 620ba590_73c88f8d a88b0f49_6471ffd1 16b0d17f_6b836f43 aa3a0c88_d6b8dfe3}}, driven_packetqueue[port=0].size()=1\n            45020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10024, error: 0, timestamp_ps=4721311291971469312, data: {size: 172, data: f6f4e4af_ae2417f2 bde43ff1_02e8afc5 6f15a7ed_b394e9ad a7fc93ed_7d513f1b a9c0dc17_b291dd0d 6f767c35_75345b62 85f71412_14e8975e 2086f8ef_50da0e38 cf699f9d_aa6dda87 3f8fcd64_782a08d8 27f63adb_0f731430 40fc973d_e65c3e06 c1869ad9_86bb4ee5 9eacb893_5352d9b1 aa56a5fd_456909c7 cd3f08b6_d6c44189 b3c34640_dc2e8aa1 d16d623a_83b59032 59d16d74_cbd9c0db 7243d6e9_17db1f43 3ced14c4_1b4bf679 411d4c7d}}, driven_packetqueue[port=1].size()=1\n            50020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20025, error: 0, timestamp_ps=4721982380611469312, data: {size: 98, data: 5f682260_806b245b 02290b38_41f3d64a 83a31207_19c751be 39a07e13_dd4da32f dea1136c_3e015613 71e303d6_e0a4deb8 91ae2a33_c87fea78 d697b3ca_c831f781 013bea7f_5794fc1d ebca04bf_5dc30c10 34991970_fb99a126 9846e3df_59d31fd5 3f44}}, driven_packetqueue[port=2].size()=1\n            50020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10026, error: 0, timestamp_ps=4721982380611469312, data: {size: 191, data: c8bac85b_99482d46 75a03732_516d3b49 b1a339fa_54c90d6e 65740d78_1b08c424 8d1ed001_d7d65634 3dd373e8_002b0d61 a5fc3c01_262ab01c 47319dd1_d23b7da8 d6436c1d_97ea9479 dc22add0_e07fe326 b6c3290f_04b2f049 0c749fd4_918b7dbc 1f01f480_d5a2ba2d 08b1b013_54ffb3b5 427fc07b_8990ef52 94371dbd_fc0ea290 8777bbc0_d9649e96 a3ea937f_f7e0bdac 921df378_def5a86a 75ead333_ae7de5d7 071923e3_abcd35c9 db800a9c_06b2c28b a5104d77_b2d30232 6d787512_1ab9c3}}, driven_packetqueue[port=1].size()=1\n            55020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10027, error: 0, timestamp_ps=4722653469251469312, data: {size: 151, data: 9322361e_45c9159a c06e7dcb_e8f99392 cae993ce_1f08efe6 69a55a9b_ae2fad58 49332e47_0d6cfff4 694de579_7305d4e7 e19fc632_5c0d6d03 6a52e1d4_9563d82a 945cf7f6_3b64edb0 69bbfcd8_01236a6a e42ee23f_9b201ded d52ccdbe_9af09dac a22d3a54_3de8c4ce 4746f587_e8f34a09 c7e3f09d_f30deb72 b2bde1d0_91d7a344 9a9da25e_a61c257f 1e5e90d0_c05d0f5f f407f24a_8d6f5b}}, driven_packetqueue[port=1].size()=1\n            55020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20028, error: 0, timestamp_ps=4722653469251469312, data: {size: 91, data: 1b587bc2_5afc85f9 9beb0c47_8609f268 81f659c0_14e798e5 d6a3db59_dc884e75 a894f96e_03f682e3 7a1c7295_1d89cfba e3a1ad38_0c05c08e 23e2d9d3_79b8d890 9cacd566_35265aed f90a238e_2871e1fa 9bb6a476_c7c3d09a 41a2f8}}, driven_packetqueue[port=2].size()=1\n            59020000 TOP.tb.add_rand_packet: port=0, pkt={id: 29, error: 0, timestamp_ps=4723190340163469312, data: {size: 169, data: 1a6b1bd0_ea823134 0f6852fa_aaef2bc2 0bd7a5a3_f3ac1d10 fc531b78_dd7055fe 152be910_474c7a76 26551a6b_c6425dfe 6aa9ac3c_7f0eaf51 b9bde0fb_0668b815 af64dcc2_e4374900 46727723_145b0dd2 1e9ca57a_6ed658f8 81c7de3c_2f7c2f66 91941ead_343d0ff2 9b3d526a_592f878d 7491933d_b94bf01d da032559_2562ad58 16b54a16_d3355d1e e633b042_2d1fd147 1769759a_4be4a337 f9186c86_0db08dd3 eed4d996_74199250 69}}, driven_packetqueue[port=0].size()=1\n            59020000 TOP.tb.add_rand_packet: port=0, pkt={id: 30, error: 0, timestamp_ps=4723190340163469312, data: {size: 157, data: b45c2d35_cba03590 eed196e2_129c0b53 ea4f152b_9043d557 f8cde632_e711c9f1 6499e7f5_27239d6d a6bf7d94_f07c4060 8a6f5737_f9e2e54b f88e05eb_78783aa7 51bba0ca_498fad31 5d637806_32f6a19d 97707525_c89ba856 e8bfc9f4_0f838d58 91aa7d0d_1e5456e3 9b6fafbd_3d4fa3cf 6dc63efa_51052c17 9a78f1bd_6b0f7e00 d31c1f23_9426de0f 8fcbb283_c2f785a4 4b4157fd_1a03064e 08e9d688_2c}}, driven_packetqueue[port=0].size()=2\n            64020000 TOP.tb.add_rand_packet: port=0, pkt={id: 31, error: 0, timestamp_ps=4723861428803469312, data: {size: 144, data: 20267708_40afc110 d1258d41_11aa645b 735682e8_fb749753 ecbf9fe0_bcc57e7f c4ce0528_13d7eb99 90921b96_46551206 264f1cb2_4595fee5 0cec43fa_01bd684b b05f9638_cb8aa4eb 38588fd3_cebca61f f57d9af3_9f9aa7d4 f395ebfb_4a35d211 210184c9_009bb96d 0a539dfc_8c2091d2 32fbf8c3_e919dfce 62525ca4_4f433519 28f98ec6_d5bbd1a6 ed6d9c96_6571f582}}, driven_packetqueue[port=0].size()=1\n            64020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10032, error: 0, timestamp_ps=4723861428803469312, data: {size: 83, data: e120dfff_e1b45bc7 c174035a_64311d1f 0728b26d_192c6b6a 72174dc2_44a9dff4 fa58d7a9_c86fa0dc 199fe8c6_c86758e1 385cc0cd_db386419 0ec6b29a_9b90b7f7 c4f24f99_958b7937 ac4845a0_d0b66187 8a8095}}, driven_packetqueue[port=1].size()=1\n            68020000 TOP.tb.add_rand_packet: port=0, pkt={id: 33, error: 0, timestamp_ps=4724337154413559808, data: {size: 102, data: c9868489_a610fb04 b26f8595_4d0d6b0d e50134ff_0f7fc2ef 91be4629_45da6be9 df94be77_69d6d5ba ad76d1a6_c4a5b0c9 b38fb783_e10413b5 0dac8fd2_023e4f4a 53e21aed_3effab27 95507f98_e47720aa 0157a94a_e3b47040 334de8e1_cdcdaacf c6740d44_4c3b}}, driven_packetqueue[port=0].size()=1\n            68020000 TOP.tb.add_rand_packet: port=0, pkt={id: 34, error: 0, timestamp_ps=4724337154413559808, data: {size: 195, data: d021d22e_2bc01c87 7bcff4e7_1d65e2a0 2e6b982b_e1e7a8a9 2d4103b0_037f4c90 6f6c4827_dcad2b6e b76b0d03_4a60fb03 89c2a588_98db0398 7ddfc2de_28a8f223 0eb6f587_4521f410 d0811cd8_155bc5bc 5c721a1e_16e7524c 04af7bda_c909fc24 1ea57b5c_0bcdda2a 285d38c4_a8d96332 990aa9dc_c23eab0e 7445828b_ebc3109d 17e7eafa_7948fc51 3635da11_2e1240c0 83429a26_d3ae059d 72b2d955_2dee6c17 9788d7fb_2b2569bc 164a25b1_be036c5e aae95bd0_5264bc34 d4716ec2_18f6fcac 80c87d}}, driven_packetqueue[port=0].size()=2\n            73020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20035, error: 0, timestamp_ps=4724672698733559808, data: {size: 176, data: 3005e909_8829a63d e3a7610c_3f98b2ea bbb73818_92dcb370 417e8ebe_920d23b0 ff743d14_6b3d07c8 d973556e_521f1c50 ef3abcf6_49975640 5bc2a958_cd04a0ec b2a6b3da_a69ee6ea cd30605e_d588ccd8 eecac504_949d268c a31ac55d_114fd323 ff18644c_dab631ab 4aefe2ff_65d5441a 752018b3_16e5c86d c74f9067_95224df9 d638503e_9b86b3eb c9c73c5c_bcd553c2 353a6270_cbac619f 5436870d_de07d978 9e23cf0a_6fd10e9a f8fc8e69_69200b1c}}, driven_packetqueue[port=2].size()=1\n            73020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10036, error: 0, timestamp_ps=4724672698733559808, data: {size: 68, data: f55bdbb4_674cc8ec 8aab18b2_23db1ee2 0019f589_b2564bba f1b7cc63_e270dab4 04804971_213394f1 c9345d0f_f6254af0 ba6aa553_951fa53e 1d1ff967_7ea08af9 496e67fe}}, driven_packetqueue[port=1].size()=1\n            77020000 TOP.tb.add_rand_packet: port=0, pkt={id: 37, error: 0, timestamp_ps=4724941134189559808, data: {size: 168, data: d0c136ca_9f56457d 4cbc2156_047c5a78 860732ee_df86620d 1379dda3_4000e1c9 65e1e077_15a4a8b2 5bf57fd6_69dd8288 7ce46d94_0c225466 276d6a54_612ad533 ce0b7b50_ae21445d 74bcd68d_054d4b23 45bdac65_bd4ba358 d44fd8c7_154face4 016054aa_e68c344d a0153734_4d0e2e32 5633d257_0a04ded0 d966f87f_4c73c37b 91fb2789_b4316e6d caec95ef_a8cab959 bb9dbc8f_c353d60b 3d734e1f_08503da4 46dfb25e_6a595f28}}, driven_packetqueue[port=0].size()=1\n            77020000 TOP.tb.add_rand_packet: port=0, pkt={id: 38, error: 0, timestamp_ps=4724941134189559808, data: {size: 169, data: e72c3894_e80b3af7 a93a8583_6747ce3f 2355e90a_57990859 98c5171c_664fc581 ff6cba26_51580f57 1f390994_a6e8e239 4272fe9e_3badecea 1b10ea05_0fbbf7ca 76e36f36_27e34bd6 baffe062_9f4c757c 4fde3996_398ea046 515befbc_427a2462 2da0672a_6ed52bca 1599aa78_4ff3a3fd 861d1024_59c5f537 a27ff0d9_d4998a50 2476b76c_353ab230 4c25154e_1496b453 e929b0ff_28ffb169 6a2a5a77_595f509d 35bb75d9_47ad4493 f1}}, driven_packetqueue[port=0].size()=2\n            82020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20039, error: 0, timestamp_ps=4725276678509559808, data: {size: 111, data: cdd3efb4_050dd3a3 c6a92fb0_b445da22 9926395e_e62573a4 26c21703_80e7597f 2c11d543_4ae898c3 7fa76adc_7e19b947 7ae2b380_68fc1e3e cf4a72a8_ccf49b4d 0c7e47ca_a91ee613 b0753008_81357205 ded8b308_a1e1c3d4 5c15254b_aea03491 949dae64_21ede9cd 177f9bbf_2f1b55}}, driven_packetqueue[port=2].size()=1\n            82020000 TOP.tb.add_rand_packet: port=0, pkt={id: 40, error: 0, timestamp_ps=4725276678509559808, data: {size: 136, data: 8779ca70_551c129d 3da75d80_9bb1d20d d76dd940_bfd8e2f7 b69bb1f1_1e2e214f 7655a8b7_c31d6b33 4924bd55_1c660776 ef1e77d3_aa30ede9 280f3f48_17540266 4a14a52a_65ad2d66 718cec79_dfa53f1f c8dce10c_deed3d29 33a691e6_d54c8e8a eb8a5c4c_a15ea04f 81ce348a_ee0dcae2 d6c3bf9d_a0fde39a 4d71ccb0_dee8f0f1 61e11127_84812ee4}}, driven_packetqueue[port=0].size()=1\n            86030000 TOP.tb.main: Monitor queues: mon queue size=0\n            86050000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n            86050000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n            86055000 TOP.tb.u_mon: num_packets_received=40\n            86055000 TOP.tb.gen_drv[0].u_drv: num_packets_driven=14\n            86055000 TOP.tb.gen_drv[1].u_drv: num_packets_driven=14\n            86055000 TOP.tb.gen_drv[2].u_drv: num_packets_driven=12\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 86us; walltime 0.163 s; speed 637.925 us/s\n- Verilator: cpu 0.135 s on 1 threads; alloced 505 MB\n",
    "stderr": "",
    "pass": true,
    "score": 100,
    "warnings": 0,
    "errors": 0,
    "runtime": 3.328185796737671,
    "batch_iter": 12,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_12",
    "start_time": 1733526072.3517811,
    "stop_time": 1733526075.679967
  },
  {
    "index": 15,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned ExtraDataWidth = 1\n) (\n  input  logic                          clock,\n  input  logic                          reset,\n  \n  input  AxiStreamType                  inAxi4St,\n  output logic                          inTready,\n  input  logic [ExtraDataWidth-1:0]     inExtra,\n  \n  output AxiStreamType                  outAxi4St,\n  input  logic                          outTready,\n  output logic [ExtraDataWidth-1:0]     outExtra,\n  \n  input  logic [7:0]                    i_rate_numerator,\n  input  logic [7:0]                    i_rate_denominator, \n  input  logic                          i_rate_by_frame\n);\n\n// Instantiate axis_rate_limit\naxis_rate_limit #(\n  .DATA_WIDTH(AxiStreamWidth),\n  .KEEP_ENABLE(1),\n  .KEEP_WIDTH(1),\n  .LAST_ENABLE(1),\n  .ID_ENABLE(0),\n  .ID_WIDTH(1),\n  .DEST_ENABLE(0), \n  .DEST_WIDTH(1),\n  .USER_ENABLE(1),\n  .USER_WIDTH(ExtraDataWidth)\n) axis_rate_limit_inst (\n  .clk(clock),\n  .rst(reset),\n\n  // Input\n  .s_axis_tdata(inAxi4St.tdata),\n  .s_axis_tkeep(inAxi4St.tkeep),\n  .s_axis_tvalid(inAxi4St.tvalid),\n  .s_axis_tready(inTready),\n  .s_axis_tlast(inAxi4St.tlast),\n  .s_axis_tid('0),\n  .s_axis_tdest('0), \n  .s_axis_tuser(inExtra),\n\n  // Output  \n  .m_axis_tdata(outAxi4St.tdata),\n  .m_axis_tkeep(outAxi4St.tkeep),\n  .m_axis_tvalid(outAxi4St.tvalid),\n  .m_axis_tready(outTready),\n  .m_axis_tlast(outAxi4St.tlast),\n  .m_axis_tid(),\n  .m_axis_tdest(),\n  .m_axis_tuser(outExtra),\n\n  // Config\n  .rate_num(i_rate_numerator),\n  .rate_denom(i_rate_denominator),\n  .rate_by_frame(i_rate_by_frame)\n);\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can perform rate limiting on an AXI4 Stream Input to AXI4 Stream Output.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n\nAdditionally, for any sequential storage of inAxi4St or outAxi4St (both have ready/valid flow control) you must use an existing module named 'local_axist_pipe', of which the internals are not revealed, but has the following module header and ports:\n\nmodule local_axist_pipe #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\nAddiotnally, please use the following module instance of axis_rate_limit:\n\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n\n\n\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumPorts-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Input: i_rate_numerator\n       -- input logic [7:0] i_rate_numerator\n       -- A static value used to determine the rate limiting. Rate limiting, in this module, should be performed by\n          setting inTready=0 and outAxi4St.tvalid=0. The rate (value between 0.000 and 1.000) is determinted using\n          i_rate_numerator / i_rate_denominator.\n    -- Input: i_rate_denominator\n       -- input logic [7:0] i_rate_denominator\n       -- A static value used to determine the rate limiting. See i_rate_numerator for calcuating the rate.\n    -- Input: i_rate_by_frame\n       -- input logic i_rate_by_frame\n       -- A static value used to determine the shaping on setting inTready=0 and outAxi4St.tvalid=0 for rate limiting.\n          -- if i_rate_by_frame=0, then the rate limiting can ignore inAxi4St.tlast, and simply performing\n             throttling on any data phit between the first phit and last phit (inAxi4St.tlast=1).\n          -- if i_rate_by_frame=1, then the rate limiting can only happen AFTER the end of a packet or frame (the\n             cycle after inAxi4St.tlast=1). For example, if a frame is starting and has N data phits and is not rate limited,\n             this module should allow outAxi4St.tvalid=inAxi4St.tvalid and inTready=outTready (no rate limiting enabled).\n             However, after this frame, if the rate limit was exceeding during the frame, this module must set and hold\n             inTready=0 and outAxi4St.tvalid=0 until the rate limit is no longer exceeded.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rate_limit.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit.sv\n//\n// Wrapper around verilog-ethernet/axis_rate_limit.v\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra: additional egressm etadata, output alongside outAxi4St.tdata.\n//    -- Rate limiting controlled by inputs:\n//       -- i_rate_numerator, i_rate_denominator\n//       -- i_rate_by_frame: select on how to perform rate limit via output inTready:\n//          -- 0: throttle by data phit in the middle of frame (ignores tlast)\n//          -- 1: throttle for N cycles after tlast.\n\nmodule oclib_axist_rate_limit\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  input logic [7:0]                        i_rate_numerator,\n  input logic [7:0]                        i_rate_denominator,\n  input logic                              i_rate_by_frame = 1'b1\n   );\n\n\n  localparam int DATA_WIDTH = AxiStreamWidth;\n  localparam int KEEP_WIDTH = ((DATA_WIDTH + 7) / 8);\n  logic [DATA_WIDTH-1:0]        s_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        s_axis_tkeep;\n  logic                         s_axis_tvalid;\n  logic                         s_axis_tready;\n  logic                         s_axis_tlast;\n  logic [7:0]                   s_axis_tid;\n  logic [7:0]                   s_axis_tdest;\n  logic [ExtraDataWidthUse : 0] s_axis_tuser;\n\n  logic [DATA_WIDTH-1:0]        m_axis_tdata;\n  logic [KEEP_WIDTH-1:0]        m_axis_tkeep;\n  logic                         m_axis_tvalid;\n  logic                         m_axis_tready;\n  logic                         m_axis_tlast;\n  logic [ExtraDataWidthUse : 0] m_axis_tuser;\n\n  always_comb begin\n    s_axis_tdata  = inAxi4St.tdata;\n    s_axis_tkeep  = inAxi4St.tkeep;\n    s_axis_tvalid = inAxi4St.tvalid;\n    inTready      = s_axis_tready;\n    s_axis_tlast  = inAxi4St.tlast;\n    s_axis_tid    = 8'd0;\n    s_axis_tdest  = 8'd0;\n    s_axis_tuser  = {inExtra, inAxi4St.tuser};\n  end\n\n  always_comb begin\n    outAxi4St = '0;\n    outAxi4St.tdata  = m_axis_tdata;\n    outAxi4St.tkeep  = m_axis_tkeep;\n    outAxi4St.tvalid = m_axis_tvalid;\n    m_axis_tready    = outTready;\n    outAxi4St.tlast  = m_axis_tlast;\n    {outExtra,\n     outAxi4St.tuser}  = m_axis_tdata;\n  end\n\n  axis_rate_limit\n    #(\n      .DATA_WIDTH(AxiStreamWidth),\n      .LAST_ENABLE(1),\n      .USER_WIDTH(1 + ExtraDataWidthUse)\n      )\n  u_axis_rate_limit\n    (\n     .clk(clock),\n     .rst(reset),\n\n     .s_axis_tdata,\n     .s_axis_tkeep,\n     .s_axis_tvalid,\n     .s_axis_tready,\n     .s_axis_tlast,\n     .s_axis_tid,\n     .s_axis_tdest,\n     .s_axis_tuser,\n\n     .m_axis_tdata,\n     .m_axis_tkeep,\n     .m_axis_tvalid,\n     .m_axis_tready,\n     .m_axis_tlast,\n     .m_axis_tid(),\n     .m_axis_tdest(),\n     .m_axis_tuser,\n\n     .rate_num(i_rate_numerator),\n     .rate_denom(i_rate_denominator),\n     .rate_by_frame(i_rate_by_frame)\n     );\n\nendmodule : oclib_axist_rate_limit\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rate_limit_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rate_limit_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rate_limit_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_rate_limit\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_rate_limit_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_4_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rate_limit_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_rate_limit.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic [7:0]             i_rate_numerator;\n  logic [7:0]             i_rate_denominator;\n  logic                   i_rate_by_frame;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outExtra(),\n     .outTready,\n     .i_rate_numerator,\n     .i_rate_denominator,\n     .i_rate_by_frame\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && !outAxi4St.tlast |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, output tvalid=1 until tlast=1\"));\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      i_rate_by_frame && outAxi4St.tvalid && outAxi4St.tlast && !outTready |=> outAxi4St.tvalid,\n                      $sformatf(\"i_rate_by_frame=1, on last phit tlast=1 if outTready=0, must continue holding tavlid=1\"));\n\n\n  real main_calc_rate;\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // -----------------------------------------------------\n    // Do a total of 400 packets.\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 1st 100 packets, set rate limit at 1:1, with some common alterations\n    // on randomized tvalid and tready.\n    // Initial setting 1:1 rate.\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd64;\n    i_rate_by_frame    = '0;\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n\n    wait (u_drv.num_packets_driven == 20);\n    wait (u_mon.num_packets_received == 20);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    wait (u_drv.num_packets_driven == 40);\n    wait (u_mon.num_packets_received == 40);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    wait (u_drv.num_packets_driven == 60);\n    wait (u_mon.num_packets_received == 60);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    wait (u_drv.num_packets_driven == 80);\n    wait (u_mon.num_packets_received == 80);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    wait (u_drv.num_packets_driven == 100);\n    wait (u_mon.num_packets_received == 100);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: First 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%0d\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 10.0 && main_calc_rate < 90.0); // expectation is ~30%\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 2nd set of 100 packets, set rate limit at 1:1\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd64;\n    i_rate_denominator = 8'd128;\n    i_rate_by_frame    = '0;     // should expect inTready be on 50% of the time.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 200);\n    wait (u_mon.num_packets_received == 200);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 2nd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 3rd set of 100 packets, set rate limit at 1:2\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd2;\n    i_rate_by_frame    = 1'b0;     // should expect inTready to have 50% duty cycle\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 300);\n    wait (u_mon.num_packets_received == 300);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 3rd 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 48.0 && main_calc_rate < 52.0);\n\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 4th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = '0;     // should expect inTready to toggle at 25% duty cycle.\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 400);\n    wait (u_mon.num_packets_received == 400);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 4th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n    // -----------------------------------------------------\n    // For the 5th set 100 packets, set rate limit at 1:4\n    // Set our monitor's tready=100%\n    i_rate_numerator   = 8'd1;\n    i_rate_denominator = 8'd4;\n    i_rate_by_frame    = 1'b1;     // should expect inTready to be 0 for 3N cycles after a N phit frame\n    u_drv.m_out_tvalid_pct   = 100; // send at max rate\n    u_mon.m_out_tready1_pct  = 100; // drain at maximum rate.\n    u_mon.m_rate_monitor_enable = 1;\n    u_mon.m_tactive_count       = '0;\n    u_mon.m_tinactive_count     = '0;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait (u_drv.num_packets_driven == 500);\n    wait (u_mon.num_packets_received == 500);\n\n    main_calc_rate = u_mon.get_calc_rate();\n    if (ocsim_pkg::info_verbosity_low()) begin\n      $display(\"%t %m: 5th 100 frames, mon m_tactive_count=%0d, m_tinactive_count=%0d, calc rate(pct)=%g\",\n               $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n    end\n    `OC_ASSERT(main_calc_rate > 23.0 && main_calc_rate < 27.0);\n    // -----------------------------------------------------\n\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_rate_limit.v' \n\n/*\n\nCopyright (c) 2014-2018 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream rate limiter\n */\nmodule axis_rate_limit #\n(\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Configuration\n     */\n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\n// internal datapath\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg                   m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nreg [23:0] acc_reg = 24'd0, acc_next;\nreg pause;\nreg frame_reg = 1'b0, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 1'b0;\n    frame_next = frame_reg;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (s_axis_tready && s_axis_tvalid) begin\n        // read input\n        frame_next = !s_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (LAST_ENABLE && rate_by_frame) begin\n            pause = !frame_next;\n        end else begin\n            pause = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = m_axis_tready_int_early && !pause;\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = s_axis_tvalid && s_axis_tready;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser;\nend\n\nalways @(posedge clk) begin\n    acc_reg <= acc_next;\n    frame_reg <= frame_next;\n    s_axis_tready_reg <= s_axis_tready_next;\n\n    if (rst) begin\n        acc_reg <= 24'd0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end\nend\n\n// output datapath logic\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n// datapath control\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        // input is ready\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            // output is ready or currently not valid, transfer data to output\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            // output is not ready, store input in temp\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        // input is not ready, but output is ready\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    m_axis_tvalid_reg <= m_axis_tvalid_next;\n    m_axis_tready_int_reg <= m_axis_tready_int_early;\n    temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n\n    // datapath\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\n\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_rate_limit_4",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_13/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb__ConstPool_0.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_13/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.303 MB sources in 19 modules, into 0.320 MB in 17 C++ files needing 0.002 MB\n- Verilator: Walltime 1.910 s (elab=0.006, cvt=0.120, bld=1.660); cpu 0.213 s on 64 threads; alloced 151.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           420100000 TOP.tb.main: First 100 frames, mon m_tactive_count=13238, m_tinactive_count=28762, calc rate(pct)=32\n           679550000 TOP.tb.main: 2nd 100 frames, mon m_tactive_count=12972, m_tinactive_count=12973, calc rate(pct)=49.9981\n           951380000 TOP.tb.main: 3rd 100 frames, mon m_tactive_count=13591, m_tinactive_count=13592, calc rate(pct)=49.9982\n          1479090000 TOP.tb.main: 4th 100 frames, mon m_tactive_count=13193, m_tinactive_count=39578, calc rate(pct)=25.0005\n          2024180000 TOP.tb.main: 5th 100 frames, mon m_tactive_count=13772, m_tinactive_count=40737, calc rate(pct)=25.2656\n          2024190000 TOP.tb.main: Monitor queues: mon queue size=0, drv queue size=0\n          2024210000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n          2024210000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n          2024215000 TOP.tb.u_drv: num_packets_driven=500\n          2024215000 TOP.tb.u_mon: num_packets_received=500\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 2ms; walltime 4.250 s; speed 486.023 us/s\n- Verilator: cpu 4.165 s on 1 threads; alloced 505 MB\n",
    "stderr": "%Warning-TIMESCALEMOD: tb.sv:22:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n   22 | package oclib_assert_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n                       ... For warning description see https://verilator.org/warn/TIMESCALEMOD?v=5.028\n                       ... Use \"/* verilator lint_off TIMESCALEMOD */\" and lint_on around source to disable this message.\n%Warning-TIMESCALEMOD: tb.sv:686:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n  686 | package oclib_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1158:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1158 | package oclib_memory_bist_pkg;\n      |         ^~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1202:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1202 | package oclib_uart_pkg;\n      |         ^~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1221:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1221 | package ocsim_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1461:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1461 | package ocsim_packet_pkg;\n      |         ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1628:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1628 | module ocsim_tb_control #(\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:1773:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 1773 | module ocsim_axist_driver\n      |        ^~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2088:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2088 | module ocsim_axist_monitor\n      |        ^~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2363:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2363 | module oclib_axist_rate_limit\n      |        ^~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2478:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2478 | module oclib_axist_rate_limit_test;\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:2822:9: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 2822 | package local_pkg;\n      |         ^~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3293:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3293 | module oclib_ready_valid_pipe_core\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3351:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3351 | module local_axist_pipe\n      |        ^~~~~~~~~~~~~~~~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-TIMESCALEMOD: tb.sv:3447:8: Timescale missing on this module as other modules have it (IEEE 1800-2023 3.14.2.3)\n 3447 | module tb;\n      |        ^~\n                       tb.sv:3823:8: ... Location of module with timescale\n 3823 | module axis_rate_limit #\n      |        ^~~~~~~~~~~~~~~\n%Warning-REALCVT: tb.sv:3650:75: Implicit conversion of real to integer\n 3650 |                $realtime, u_mon.m_tactive_count, u_mon.m_tinactive_count, main_calc_rate);\n      |                                                                           ^~~~~~~~~~~~~~\n",
    "pass": true,
    "score": 84,
    "warnings": 16,
    "errors": 0,
    "runtime": 6.284489870071411,
    "batch_iter": 13,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_13",
    "start_time": 1733526072.3745553,
    "stop_time": 1733526078.6590452
  },
  {
    "index": 11,
    "dut": "module dut #(\n  parameter int NumPorts = 4,\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8,\n  parameter int MacTableDepth = 16,\n  parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000,\n  parameter int FifoPacketMutInBytes = 1504,\n  parameter int FifoSizeInBytes = 4096,\n  parameter int MaxNumberOfPackets = 32,\n  parameter int IngressPrefillBytes = -1\n)(\n  input logic clock,\n  input logic reset,\n  input AxiStreamType [NumPorts-1:0] inAxi4St,\n  output logic [NumPorts-1:0] inTready,\n  output AxiStreamType [NumPorts-1:0] outAxi4St,\n  input logic [NumPorts-1:0] outTready,\n  output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n  // MAC table entry type\n  typedef struct packed {\n    logic [47:0] mac_addr;\n    logic [1:0] port;\n    logic valid;\n    logic [$clog2(MacTableCyclesPerEpoch)-1:0] age_counter;\n  } mac_entry_t;\n\n  // MAC table storage\n  mac_entry_t [MacTableDepth-1:0] mac_table;\n  \n  // Packet FIFOs per output port\n  typedef struct packed {\n    AxiStreamType data;\n    logic [$clog2(FifoPacketMutInBytes)-1:0] count;\n  } fifo_entry_t;\n  \n  fifo_entry_t [NumPorts-1:0][FifoSizeInBytes-1:0] tx_fifos;\n  logic [NumPorts-1:0][$clog2(FifoSizeInBytes):0] fifo_wr_ptrs;\n  logic [NumPorts-1:0][$clog2(FifoSizeInBytes):0] fifo_rd_ptrs;\n  logic [NumPorts-1:0] fifo_full;\n  logic [NumPorts-1:0] fifo_empty;\n\n  // Input ready always asserted\n  assign inTready = {NumPorts{1'b1}};\n  \n  // Default no drops\n  assign egressFifoDropEvents = '0;\n\n  // MAC table lookup and update\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mac_table <= '{default:'0};\n      fifo_wr_ptrs <= '{default:'0};\n      fifo_rd_ptrs <= '{default:'0};\n    end\n    else begin\n      // Age MAC table entries\n      for (int i=0; i<MacTableDepth; i++) begin\n        if (mac_table[i].valid) begin\n          if (mac_table[i].age_counter == MacTableCyclesPerEpoch-1) begin\n            mac_table[i].valid <= 1'b0;\n          end\n          else begin\n            mac_table[i].age_counter <= mac_table[i].age_counter + 1;\n          end\n        end\n      end\n\n      // Process incoming packets\n      for (int i=0; i<NumPorts; i++) begin\n        if (inAxi4St[i].tvalid) begin\n          // Extract MAC addresses\n          logic [47:0] dst_mac = inAxi4St[i].tdata[47:0];\n          logic [47:0] src_mac = inAxi4St[i].tdata[95:48];\n          \n          // Update MAC table with source address\n          logic found = 0;\n          for (int j=0; j<MacTableDepth; j++) begin\n            if (mac_table[j].valid && mac_table[j].mac_addr == src_mac) begin\n              mac_table[j].port <= i[1:0];\n              mac_table[j].age_counter <= '0;\n              found = 1;\n              break;\n            end\n          end\n          \n          if (!found) begin\n            // Add new entry\n            for (int j=0; j<MacTableDepth; j++) begin\n              if (!mac_table[j].valid) begin\n                mac_table[j].mac_addr <= src_mac;\n                mac_table[j].port <= i[1:0];\n                mac_table[j].valid <= 1'b1;\n                mac_table[j].age_counter <= '0;\n                break;\n              end\n            end\n          end\n\n          // Forward packet based on destination\n          logic [NumPorts-1:0] dst_ports = '0;\n          \n          // Check if broadcast/multicast\n          if (dst_mac[0] || &dst_mac) begin\n            dst_ports = ~(1 << i); // All ports except source\n          end\n          else begin\n            // Unicast lookup\n            found = 0;\n            for (int j=0; j<MacTableDepth; j++) begin\n              if (mac_table[j].valid && mac_table[j].mac_addr == dst_mac) begin\n                dst_ports[mac_table[j].port] = 1'b1;\n                found = 1;\n                break;\n              end\n            end\n            \n            if (!found) begin\n              dst_ports = ~(1 << i); // Unknown - flood except source\n            end\n          end\n\n          // Write to output FIFOs\n          for (int p=0; p<NumPorts; p++) begin\n            if (dst_ports[p] && !fifo_full[p]) begin\n              tx_fifos[p][fifo_wr_ptrs[p]].data <= inAxi4St[i];\n              fifo_wr_ptrs[p] <= fifo_wr_ptrs[p] + 1;\n            end\n          end\n        end\n      end\n\n      // Read from FIFOs to outputs\n      for (int i=0; i<NumPorts; i++) begin\n        if (!fifo_empty[i] && outTready[i]) begin\n          outAxi4St[i] <= tx_fifos[i][fifo_rd_ptrs[i]].data;\n          fifo_rd_ptrs[i] <= fifo_rd_ptrs[i] + 1;\n        end\n        else begin\n          outAxi4St[i].tvalid <= 1'b0;\n        end\n      end\n    end\n  end\n\n  // FIFO status\n  always_comb begin\n    for (int i=0; i<NumPorts; i++) begin\n      fifo_empty[i] = (fifo_rd_ptrs[i] == fifo_wr_ptrs[i]);\n      fifo_full[i] = ((fifo_wr_ptrs[i] + 1) == fifo_rd_ptrs[i]);\n    end\n  end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module does not need to support a 'ready' output signal for backpressure for the inAxi4St inputs, it is assumed these are received Ethernet frames coming from an Ethernet MAC Rx that does not support flow control with a 'ready' signal.\nThe module does need to support 'outReady' input signals for each transmit port, since outAxi4St will connect four Ethernet MAC Transmit ports.\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n     -- parameter int FifoPacketMutInBytes = 1504\n        -- Maximum Ethernet Frame size, in bytes.\n     -- parameter int FifoSizeInBytes = 4096\n        -- Maximum FIFO size for a single FIFO within the design, in bytes. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be internally stored for any single ingress to egress AxiStreamType output bus (outAxi4St[tx_port]).\n           For Example, if NumPorts=4, and all four ports inAxi4St[3:0] have frames with Destination MAC that steer to outAxi4St[0] (egress port 0), outAxi4St[0] can only egress one data phit per cycle, while four ports are queuing a total of four data phits per cycle. It is preferred to have FIFOs on each egress port (each outAxi4S[tx_port]). This parameter specifies the maximum number of packets per FIFO.\n     -- parameter IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_router_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_l2_switch_5",
    "return_code": 0,
    "stdout": "",
    "stderr": "%Error: dut.sv:102:32: syntax error, unexpected IDENTIFIER, expecting \"'{\"\n  102 |           logic [NumPorts-1:0] dst_ports = '0;\n      |                                ^~~~~~~~~\n%Error: Exiting due to 1 error(s)\n",
    "pass": false,
    "score": 60,
    "warnings": 0,
    "errors": 2,
    "runtime": 0.6864185333251953,
    "batch_iter": 14,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_14",
    "start_time": 1733526072.4027374,
    "stop_time": 1733526073.089156
  },
  {
    "index": 16,
    "dut": "module dut #(\n    parameter type AxiStreamType = local_pkg::axi4st_8_s\n) (\n    input  logic        clock,\n    input  logic        reset,\n    input  AxiStreamType inAxi4St,\n    input  logic        inTready,\n    output logic        tfirst,\n    output logic        in_packet\n);\n\nlogic tfirst_d, tfirst_q;\nlogic in_packet_d, in_packet_q;\n\n// Combinational logic\nalways_comb begin\n    // Default keeps current value\n    tfirst_d = tfirst_q;\n    in_packet_d = in_packet_q;\n\n    // Reset tfirst after valid transfer with tlast\n    if (inAxi4St.tvalid && inTready && inAxi4St.tlast) begin\n        tfirst_d = 1'b1;\n    end\n    // Clear tfirst after first valid beat\n    else if (inAxi4St.tvalid) begin\n        tfirst_d = 1'b0;\n    end\n\n    // Set in_packet on first valid data\n    if (inAxi4St.tvalid && tfirst_q) begin\n        in_packet_d = 1'b1;\n    end\n    // Clear in_packet after last transfer\n    else if (inAxi4St.tvalid && inTready && inAxi4St.tlast) begin\n        in_packet_d = 1'b0;\n    end\nend\n\n// Sequential logic \nalways_ff @(posedge clock) begin\n    if (reset) begin\n        tfirst_q <= 1'b1;\n        in_packet_q <= 1'b0;\n    end else begin\n        tfirst_q <= tfirst_d;\n        in_packet_q <= in_packet_d;\n    end\nend\n\n// Drive outputs\nassign tfirst = tfirst_q;\nassign in_packet = in_packet_q;\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that outputs two new 1-bit flags from AXI4 Stream protocol input.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module name should be: dut\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- Module parameters:\n        -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n                -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n-- Other module inputs and outputs:\n    -- Input: inAxi4St\n       -- input AxiStreamType inAxi4St\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: inTready\n       -- input logic inTready\n       -- inTready is also an input to this module (this module acts as a passive monitor on an existing AXI4 Stream protocol, where ready is\n          \"inTready\" and valid is part of the AXI4 Stream input inAxi4St.tvalid).\n    -- Output: tfirst\n       -- output logic tfirst\n       -- is a 1 on the first valid data after reset=1, or the first valid data after inAxi4St.tvalid=1 && inTready=1 && inAxi4St.tlast=1.\n    -- Output: in_packet\n       -- output logic in_packet\n       -- is a 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. It is held at 1 until packet end\n          (inAxi4St.tvalid=1 && inAxi4St.tlast=1 && inTready=1) and is 0 the cycle after this data phit before the next inAxi4St.tvalid=1.\n       -- Note that in_packet must be 1 whenever inAxi4St.tvalid=1.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_tfirst_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_tfirst.sv), and confirm DUT outputs\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n\n  logic                   tfirst;\n  logic                   in_packet;\n\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(inAxi4St),\n     .inError(),\n     .inTready(inTready), // <-- we drive the signal inTready\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_tfirst\n    #(\n      .AxiStreamType(AxiStreamType)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n\n     .tfirst,\n     .in_packet\n     );\n\n\n  // Simple confirm DUT behavior.\n  logic                   tb_in_packet;\n  logic                   next_phit_should_be_tfirst, tb_in_packet_held;\n  always @(posedge clock) begin\n    if (reset) begin\n      next_phit_should_be_tfirst <= 1'b1;\n      tb_in_packet_held          <= '0;\n    end else begin\n      if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n          next_phit_should_be_tfirst <= 1'b1;\n          tb_in_packet_held          <= '0;\n        end else begin\n          next_phit_should_be_tfirst <= 1'b0;\n          tb_in_packet_held          <= '1;\n        end\n      end\n    end\n  end\n\n  assign tb_in_packet = tb_in_packet_held || (inAxi4St.tvalid && next_phit_should_be_tfirst);\n\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || (tfirst === next_phit_should_be_tfirst), (\"tvalid=1 means tfirst must be expected\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, tb_in_packet === in_packet, (\"DUT and TB don't agree with 'in_packet'\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || in_packet, (\"tvalid=1 implies we should be in-packet\"));\n\n  // count tfirsts, should match total packets.\n  int tb_stats__tfirst = 0;\n  int tb_stats__in_packet_at_tlast = 0;\n  int tb_stats__in_packet_starts = 0;\n\n  // count new in_packet events\n  always @(posedge clock) begin\n    if (inAxi4St.tvalid && inTready) begin\n\n      if (tfirst)\n        tb_stats__tfirst++;\n\n      if (inAxi4St.tlast && in_packet)\n        tb_stats__in_packet_at_tlast++;\n\n      if (next_phit_should_be_tfirst)\n        tb_stats__in_packet_starts++;\n\n    end\n  end\n\n\n\n\n  import ocsim_packet_pkg::packet_t;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // disable monitoring the packets:\n    u_mon.m_monitor_queue_enable = 0;\n    u_drv.m_out_tvalid_pct = 65;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    while (u_mon.busy()) repeat(100) @(posedge clock);\n\n    `OC_ASSERT(tb_in_packet === 0);\n\n    `OC_ASSERT(tb_stats__tfirst == 100);\n    `OC_ASSERT(tb_stats__in_packet_at_tlast == 100);\n    `OC_ASSERT(tb_stats__in_packet_starts == 100);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_tfirst_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_tfirst_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_tfirst_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_tfirst.sv), and confirm DUT outputs\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n\n  logic                   tfirst;\n  logic                   in_packet;\n\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(inAxi4St),\n     .inError(),\n     .inTready(inTready), // <-- we drive the signal inTready\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n\n     .tfirst,\n     .in_packet\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // Simple confirm DUT behavior.\n  logic                   tb_in_packet;\n  logic                   next_phit_should_be_tfirst, tb_in_packet_held;\n  always @(posedge clock) begin\n    if (reset) begin\n      next_phit_should_be_tfirst <= 1'b1;\n      tb_in_packet_held          <= '0;\n    end else begin\n      if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n          next_phit_should_be_tfirst <= 1'b1;\n          tb_in_packet_held          <= '0;\n        end else begin\n          next_phit_should_be_tfirst <= 1'b0;\n          tb_in_packet_held          <= '1;\n        end\n      end\n    end\n  end\n\n  assign tb_in_packet = tb_in_packet_held || (inAxi4St.tvalid && next_phit_should_be_tfirst);\n\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || (tfirst === next_phit_should_be_tfirst), (\"tvalid=1 means tfirst must be expected\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, tb_in_packet === in_packet, (\"DUT and TB don't agree with 'in_packet'\"));\n  `OC_SYNC_ASSERT_STR(clock, reset, !inAxi4St.tvalid || in_packet, (\"tvalid=1 implies we should be in-packet\"));\n\n  // count tfirsts, should match total packets.\n  int tb_stats__tfirst = 0;\n  int tb_stats__in_packet_at_tlast = 0;\n  int tb_stats__in_packet_starts = 0;\n\n  // count new in_packet events\n  always @(posedge clock) begin\n    if (inAxi4St.tvalid && inTready) begin\n\n      if (tfirst)\n        tb_stats__tfirst++;\n\n      if (inAxi4St.tlast && in_packet)\n        tb_stats__in_packet_at_tlast++;\n\n      if (next_phit_should_be_tfirst)\n        tb_stats__in_packet_starts++;\n\n    end\n  end\n\n\n\n\n  import ocsim_packet_pkg::packet_t;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // disable monitoring the packets:\n    u_mon.m_monitor_queue_enable = 0;\n    u_drv.m_out_tvalid_pct = 65;\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    while (u_mon.busy()) repeat(100) @(posedge clock);\n\n    `OC_ASSERT(tb_in_packet === 0);\n\n    `OC_ASSERT(tb_stats__tfirst == 100);\n    `OC_ASSERT(tb_stats__in_packet_at_tlast == 100);\n    `OC_ASSERT(tb_stats__in_packet_starts == 100);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_tfirst_2",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_15/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_15/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.258 MB sources in 16 modules, into 0.160 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 1.630 s (elab=0.005, cvt=0.014, bld=1.279); cpu 1.455 s on 64 threads; alloced 149.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n[120000] %Error: tb.sv:3245: Assertion failed in TOP.tb:               120000 TOP.tb: tvalid=1 implies we should be in-packet at tb.sv:3245\n%Error: tb.sv:3245: Verilog $stop\nAborting...\n",
    "stderr": "",
    "pass": false,
    "score": 80,
    "warnings": 0,
    "errors": 0,
    "runtime": 1.9855341911315918,
    "batch_iter": 15,
    "batch_uuid": "1fe87c32-45d4-4c55-9e33-5eeef24ee73f",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_1fe87c32-45d4-4c55-9e33-5eeef24ee73f_15",
    "start_time": 1733526072.4591014,
    "stop_time": 1733526074.4446356
  },
  {
    "index": 13,
    "dut": "module dut #(\n    parameter int Depth = 4096,\n    parameter int EntriesMTU = 1504, \n    parameter type AxiStreamType = axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1,\n    parameter int unsigned PacketMtuInBytes = 1500,\n    parameter int FifoSizeInBytes = 4096,\n    parameter int MaxNumberOfPackets = 32,\n    parameter int DropIngressOnAfull = 1,\n    parameter int DropEgressOnError = 1,\n    parameter int IngressPrefillBytes = -1\n)(\n    input  logic                           clock,\n    input  logic                           reset,\n    input  AxiStreamType                   inAxi4St,\n    output logic                           inTready,\n    output AxiStreamType                   outAxi4St,\n    input  logic                           outTready,\n    input  logic                           inError,\n    input  logic [ExtraDataWidth-1:0]      inExtra,\n    output logic                           outError,\n    output logic [ExtraDataWidth-1:0]      outExtra,\n    output logic                           inFifoAfull,\n    output logic                           inDropEvent,\n    output logic                           outDropEvent\n);\n\n// Track number of stored packets\nlogic [$clog2(MaxNumberOfPackets+1)-1:0] packet_count;\nlogic packet_start, packet_end;\nlogic drop_packet;\nlogic [31:0] fifo_depth;\n\n// Combine data, error and extra into fifo data type\ntypedef struct packed {\n    AxiStreamType axi4st;\n    logic error;\n    logic [ExtraDataWidth-1:0] extra;\n} fifo_data_t;\n\nfifo_data_t fifo_in, fifo_out;\nlogic fifo_push, fifo_pop;\nlogic fifo_full, fifo_empty;\n\n// Input logic\nassign packet_start = inAxi4St.tvalid && !drop_packet;\nassign packet_end = inAxi4St.tvalid && inAxi4St.tlast;\n\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        packet_count <= '0;\n        drop_packet <= 1'b0;\n        inDropEvent <= 1'b0;\n    end else begin\n        inDropEvent <= 1'b0;\n        \n        if (packet_start && !drop_packet) begin\n            // Check if we can accept packet\n            if ((packet_count >= MaxNumberOfPackets) || \n                (fifo_depth < EntriesMTU)) begin\n                drop_packet <= 1'b1;\n            end\n        end\n        \n        if (packet_end) begin\n            if (drop_packet) begin\n                inDropEvent <= 1'b1;\n                drop_packet <= 1'b0;\n            end else begin\n                packet_count <= packet_count + 1'b1;\n            end\n        end\n        \n        if (fifo_pop && outAxi4St.tlast) begin\n            packet_count <= packet_count - 1'b1;\n        end\n    end\nend\n\n// Input signals to FIFO\nassign fifo_in.axi4st = inAxi4St;\nassign fifo_in.error = inError;\nassign fifo_in.extra = inExtra;\n\nassign fifo_push = inAxi4St.tvalid && !drop_packet;\nassign fifo_pop = !fifo_empty && outTready;\n\n// Connect output signals\nassign outAxi4St = fifo_out.axi4st;\nassign outError = fifo_out.error;  \nassign outExtra = fifo_out.extra;\nassign outDropEvent = 1'b0;\n\n// Always ready to accept input\nassign inTready = 1'b1;\n\n// Almost full when can't accept MTU sized packet\nassign inFifoAfull = (fifo_depth < EntriesMTU) ||\n                    (packet_count >= MaxNumberOfPackets);\n\n// Instantiate AXI Stream FIFO\naxis_fifo #(\n    .DEPTH(Depth),\n    .DATA_WIDTH($bits(fifo_data_t)),\n    .KEEP_ENABLE(1),\n    .LAST_ENABLE(1),\n    .ID_ENABLE(0),\n    .DEST_ENABLE(0),\n    .USER_ENABLE(1),\n    .FRAME_FIFO(1)\n) u_fifo (\n    .clk(clock),\n    .rst(reset),\n    \n    // AXI input\n    .s_axis_tdata(fifo_in),\n    .s_axis_tkeep('1),\n    .s_axis_tvalid(fifo_push),\n    .s_axis_tready(),\n    .s_axis_tlast(inAxi4St.tlast),\n    .s_axis_tid('0),\n    .s_axis_tdest('0),\n    .s_axis_tuser('0),\n    \n    // AXI output  \n    .m_axis_tdata(fifo_out),\n    .m_axis_tkeep(),\n    .m_axis_tvalid(outAxi4St.tvalid),\n    .m_axis_tready(outTready),\n    .m_axis_tlast(outAxi4St.tlast),\n    .m_axis_tid(),\n    .m_axis_tdest(),\n    .m_axis_tuser(),\n    \n    // Status\n    .status_depth(fifo_depth),\n    .status_overflow(),\n    .status_bad_frame(),\n    .status_good_frame()\n);\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a store-and-forward ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported. If there is not enough free in the FIFO to store an incoming frame, then the frame must be dropped, this is determined by the Maximum Transfer Unit (MTU) size, based on a parameter EntriesMTU.\n\nBy \"store-and-forward\" the intent is that an entire frame on AXI4 Stream must be stored completely (end is determined by inAxi4St.tlast=1 inAxi4St.tvalid=1 inTready=1) before being transmitted. Once trasmit has started (outAxi4St.tvalid=1) the output tvalid must be 1 until the last final data phit of a frame is tramitted (outAxi4St.tlast=1 outAxi4St.tvalid=1 outTready=1)\n\nAdditionally, you must use an existing module named 'axis_fifo', for any internal FIFOs. Do not create your own logic to build a simple FIFO from scratch). This is how axis_fifo.v looks:\n\n\n/*\n * AXI4-Stream FIFO\n */\nmodule axis_fifo #\n(\n    // FIFO depth in words\n    // KEEP_WIDTH words per cycle if KEEP_ENABLE set\n    // Rounded up to nearest power of 2 cycles\n    parameter DEPTH = 4096,\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1,\n    // number of RAM pipeline registers\n    parameter RAM_PIPELINE = 1,\n    // use output FIFO\n    // When set, the RAM read enable and pipeline clock enables are removed\n    parameter OUTPUT_FIFO_ENABLE = 0,\n    // Frame FIFO mode - operate on frames instead of cycles\n    // When set, m_axis_tvalid will not be deasserted within a frame\n    // Requires LAST_ENABLE set\n    parameter FRAME_FIFO = 0,\n    // tuser value for bad frame marker\n    parameter USER_BAD_FRAME_VALUE = 1'b1,\n    // tuser mask for bad frame marker\n    parameter USER_BAD_FRAME_MASK = 1'b1,\n    // Drop frames larger than FIFO\n    // Requires FRAME_FIFO set\n    parameter DROP_OVERSIZE_FRAME = FRAME_FIFO,\n    // Drop frames marked bad\n    // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set\n    parameter DROP_BAD_FRAME = 0,\n    // Drop incoming frames when full\n    // When set, s_axis_tready is always asserted\n    // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set\n    parameter DROP_WHEN_FULL = 0,\n    // Mark incoming frames as bad frames when full\n    // When set, s_axis_tready is always asserted\n    // Requires FRAME_FIFO to be clear\n    parameter MARK_WHEN_FULL = 0,\n    // Enable pause request input\n    parameter PAUSE_ENABLE = 0,\n    // Pause between frames\n    parameter FRAME_PAUSE = FRAME_FIFO\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Pause\n     */\n    input  wire                   pause_req,\n    output wire                   pause_ack,\n\n    /*\n     * Status\n     */\n    output wire [$clog2(DEPTH):0] status_depth,\n    output wire [$clog2(DEPTH):0] status_depth_commit,\n    output wire                   status_overflow,\n    output wire                   status_bad_frame,\n    output wire                   status_good_frame\n);\n\nparameter ADDR_WIDTH = (KEEP_ENABLE && KEEP_WIDTH > 1) ? $clog2(DEPTH/KEEP_WIDTH) : $clog2(DEPTH);\n\nparameter OUTPUT_FIFO_ADDR_WIDTH = RAM_PIPELINE < 2 ? 3 : $clog2(RAM_PIPELINE*2+7);\n\n// check configuration\ninitial begin\n    if (FRAME_FIFO && !LAST_ENABLE) begin\n        $error(\"Error: FRAME_FIFO set requires LAST_ENABLE set (instance %m)\");\n        $finish;\n    end\n\n    if (DROP_OVERSIZE_FRAME && !FRAME_FIFO) begin\n        $error(\"Error: DROP_OVERSIZE_FRAME set requires FRAME_FIFO set (instance %m)\");\n        $finish;\n    end\n\n    if (DROP_BAD_FRAME && !(FRAME_FIFO && DROP_OVERSIZE_FRAME)) begin\n        $error(\"Error: DROP_BAD_FRAME set requires FRAME_FIFO and DROP_OVERSIZE_FRAME set (instance %m)\");\n        $finish;\n    end\n\n    if (DROP_WHEN_FULL && !(FRAME_FIFO && DROP_OVERSIZE_FRAME)) begin\n        $error(\"Error: DROP_WHEN_FULL set requires FRAME_FIFO and DROP_OVERSIZE_FRAME set (instance %m)\");\n        $finish;\n    end\n\n    if ((DROP_BAD_FRAME || MARK_WHEN_FULL) && (USER_BAD_FRAME_MASK & {USER_WIDTH{1'b1}}) == 0) begin\n        $error(\"Error: Invalid USER_BAD_FRAME_MASK value (instance %m)\");\n        $finish;\n    end\n\n    if (MARK_WHEN_FULL && FRAME_FIFO) begin\n        $error(\"Error: MARK_WHEN_FULL is not compatible with FRAME_FIFO (instance %m)\");\n        $finish;\n    end\n\n    if (MARK_WHEN_FULL && !LAST_ENABLE) begin\n        $error(\"Error: MARK_WHEN_FULL set requires LAST_ENABLE set (instance %m)\");\n        $finish;\n    end\nend\n\nlocalparam KEEP_OFFSET = DATA_WIDTH;\nlocalparam LAST_OFFSET = KEEP_OFFSET + (KEEP_ENABLE ? KEEP_WIDTH : 0);\nlocalparam ID_OFFSET   = LAST_OFFSET + (LAST_ENABLE ? 1          : 0);\nlocalparam DEST_OFFSET = ID_OFFSET   + (ID_ENABLE   ? ID_WIDTH   : 0);\nlocalparam USER_OFFSET = DEST_OFFSET + (DEST_ENABLE ? DEST_WIDTH : 0);\nlocalparam WIDTH       = USER_OFFSET + (USER_ENABLE ? USER_WIDTH : 0);\n\nreg [ADDR_WIDTH:0] wr_ptr_reg = {ADDR_WIDTH+1{1'b0}};\nreg [ADDR_WIDTH:0] wr_ptr_commit_reg = {ADDR_WIDTH+1{1'b0}};\nreg [ADDR_WIDTH:0] rd_ptr_reg = {ADDR_WIDTH+1{1'b0}};\n\n(* ramstyle = \"no_rw_check\" *)\nreg [WIDTH-1:0] mem[(2**ADDR_WIDTH)-1:0];\nreg mem_read_data_valid_reg = 1'b0;\n\n(* shreg_extract = \"no\" *)\nreg [WIDTH-1:0] m_axis_pipe_reg[RAM_PIPELINE+1-1:0];\nreg [RAM_PIPELINE+1-1:0] m_axis_tvalid_pipe_reg = 0;\n\n// full when first MSB different but rest same\nwire full = wr_ptr_reg == (rd_ptr_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});\n// empty when pointers match exactly\nwire empty = wr_ptr_commit_reg == rd_ptr_reg;\n// overflow within packet\nwire full_wr = wr_ptr_reg == (wr_ptr_commit_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});\n\nreg s_frame_reg = 1'b0;\n\nreg drop_frame_reg = 1'b0;\nreg mark_frame_reg = 1'b0;\nreg send_frame_reg = 1'b0;\nreg [ADDR_WIDTH:0] depth_reg = 0;\nreg [ADDR_WIDTH:0] depth_commit_reg = 0;\nreg overflow_reg = 1'b0;\nreg bad_frame_reg = 1'b0;\nreg good_frame_reg = 1'b0;\n\nassign s_axis_tready = FRAME_FIFO ? (!full || (full_wr && DROP_OVERSIZE_FRAME) || DROP_WHEN_FULL) : (!full || MARK_WHEN_FULL);\n\nwire [WIDTH-1:0] s_axis;\n\ngenerate\n    assign s_axis[DATA_WIDTH-1:0] = s_axis_tdata;\n    if (KEEP_ENABLE) assign s_axis[KEEP_OFFSET +: KEEP_WIDTH] = s_axis_tkeep;\n    if (LAST_ENABLE) assign s_axis[LAST_OFFSET]               = s_axis_tlast | mark_frame_reg;\n    if (ID_ENABLE)   assign s_axis[ID_OFFSET   +: ID_WIDTH]   = s_axis_tid;\n    if (DEST_ENABLE) assign s_axis[DEST_OFFSET +: DEST_WIDTH] = s_axis_tdest;\n    if (USER_ENABLE) assign s_axis[USER_OFFSET +: USER_WIDTH] = mark_frame_reg ? USER_BAD_FRAME_VALUE : s_axis_tuser;\nendgenerate\n\nwire [WIDTH-1:0] m_axis = m_axis_pipe_reg[RAM_PIPELINE+1-1];\n\nwire                   m_axis_tready_pipe;\nwire                   m_axis_tvalid_pipe = m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1];\n\nwire [DATA_WIDTH-1:0]  m_axis_tdata_pipe  = m_axis[DATA_WIDTH-1:0];\nwire [KEEP_WIDTH-1:0]  m_axis_tkeep_pipe  = KEEP_ENABLE ? m_axis[KEEP_OFFSET +: KEEP_WIDTH] : {KEEP_WIDTH{1'b1}};\nwire                   m_axis_tlast_pipe  = LAST_ENABLE ? m_axis[LAST_OFFSET] : 1'b1;\nwire [ID_WIDTH-1:0]    m_axis_tid_pipe    = ID_ENABLE   ? m_axis[ID_OFFSET +: ID_WIDTH] : {ID_WIDTH{1'b0}};\nwire [DEST_WIDTH-1:0]  m_axis_tdest_pipe  = DEST_ENABLE ? m_axis[DEST_OFFSET +: DEST_WIDTH] : {DEST_WIDTH{1'b0}};\nwire [USER_WIDTH-1:0]  m_axis_tuser_pipe  = USER_ENABLE ? m_axis[USER_OFFSET +: USER_WIDTH] : {USER_WIDTH{1'b0}};\n\nwire                   m_axis_tready_out;\nwire                   m_axis_tvalid_out;\n\nwire [DATA_WIDTH-1:0]  m_axis_tdata_out;\nwire [KEEP_WIDTH-1:0]  m_axis_tkeep_out;\nwire                   m_axis_tlast_out;\nwire [ID_WIDTH-1:0]    m_axis_tid_out;\nwire [DEST_WIDTH-1:0]  m_axis_tdest_out;\nwire [USER_WIDTH-1:0]  m_axis_tuser_out;\n\nwire pipe_ready;\n\nassign status_depth = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {depth_reg, {$clog2(KEEP_WIDTH){1'b0}}} : depth_reg;\nassign status_depth_commit = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {depth_commit_reg, {$clog2(KEEP_WIDTH){1'b0}}} : depth_commit_reg;\nassign status_overflow = overflow_reg;\nassign status_bad_frame = bad_frame_reg;\nassign status_good_frame = good_frame_reg;\n\n// Write logic\nalways @(posedge clk) begin\n    overflow_reg <= 1'b0;\n    bad_frame_reg <= 1'b0;\n    good_frame_reg <= 1'b0;\n\n    if (s_axis_tready && s_axis_tvalid && LAST_ENABLE) begin\n        // track input frame status\n        s_frame_reg <= !s_axis_tlast;\n    end\n\n    if (FRAME_FIFO) begin\n        // frame FIFO mode\n        if (s_axis_tready && s_axis_tvalid) begin\n            // transfer in\n            if ((full && DROP_WHEN_FULL) || (full_wr && DROP_OVERSIZE_FRAME) || drop_frame_reg) begin\n                // full, packet overflow, or currently dropping frame\n                // drop frame\n                drop_frame_reg <= 1'b1;\n                if (s_axis_tlast) begin\n                    // end of frame, reset write pointer\n                    wr_ptr_reg <= wr_ptr_commit_reg;\n                    drop_frame_reg <= 1'b0;\n                    overflow_reg <= 1'b1;\n                end\n            end else begin\n                // store it\n                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n                wr_ptr_reg <= wr_ptr_reg + 1;\n                if (s_axis_tlast || (!DROP_OVERSIZE_FRAME && (full_wr || send_frame_reg))) begin\n                    // end of frame or send frame\n                    send_frame_reg <= !s_axis_tlast;\n                    if (s_axis_tlast && DROP_BAD_FRAME && USER_BAD_FRAME_MASK & ~(s_axis_tuser ^ USER_BAD_FRAME_VALUE)) begin\n                        // bad packet, reset write pointer\n                        wr_ptr_reg <= wr_ptr_commit_reg;\n                        bad_frame_reg <= 1'b1;\n                    end else begin\n                        // good packet or packet overflow, update write pointer\n                        wr_ptr_commit_reg <= wr_ptr_reg + 1;\n                        good_frame_reg <= s_axis_tlast;\n                    end\n                end\n            end\n        end else if (s_axis_tvalid && full_wr && !DROP_OVERSIZE_FRAME) begin\n            // data valid with packet overflow\n            // update write pointer\n            send_frame_reg <= 1'b1;\n            wr_ptr_commit_reg <= wr_ptr_reg;\n        end\n    end else begin\n        // normal FIFO mode\n        if (s_axis_tready && s_axis_tvalid) begin\n            if (drop_frame_reg && MARK_WHEN_FULL) begin\n                // currently dropping frame\n                if (s_axis_tlast) begin\n                    // end of frame\n                    if (!full && mark_frame_reg) begin\n                        // terminate marked frame\n                        mark_frame_reg <= 1'b0;\n                        mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n                        wr_ptr_reg <= wr_ptr_reg + 1;\n                        wr_ptr_commit_reg <= wr_ptr_reg + 1;\n                    end\n                    // end of frame, clear drop flag\n                    drop_frame_reg <= 1'b0;\n                    overflow_reg <= 1'b1;\n                end\n            end else if ((full || mark_frame_reg) && MARK_WHEN_FULL) begin\n                // full or marking frame\n                // drop frame; mark if this isn't the first cycle\n                drop_frame_reg <= 1'b1;\n                mark_frame_reg <= mark_frame_reg || s_frame_reg;\n                if (s_axis_tlast) begin\n                    drop_frame_reg <= 1'b0;\n                    overflow_reg <= 1'b1;\n                end\n            end else begin\n                // transfer in\n                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n                wr_ptr_reg <= wr_ptr_reg + 1;\n                wr_ptr_commit_reg <= wr_ptr_reg + 1;\n            end\n        end else if ((!full && !drop_frame_reg && mark_frame_reg) && MARK_WHEN_FULL) begin\n            // terminate marked frame\n            mark_frame_reg <= 1'b0;\n            mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n            wr_ptr_reg <= wr_ptr_reg + 1;\n            wr_ptr_commit_reg <= wr_ptr_reg + 1;\n        end\n    end\n\n    if (rst) begin\n        wr_ptr_reg <= {ADDR_WIDTH+1{1'b0}};\n        wr_ptr_commit_reg <= {ADDR_WIDTH+1{1'b0}};\n\n        s_frame_reg <= 1'b0;\n\n        drop_frame_reg <= 1'b0;\n        mark_frame_reg <= 1'b0;\n        send_frame_reg <= 1'b0;\n        overflow_reg <= 1'b0;\n        bad_frame_reg <= 1'b0;\n        good_frame_reg <= 1'b0;\n    end\nend\n\n// Status\nalways @(posedge clk) begin\n    depth_reg <= wr_ptr_reg - rd_ptr_reg;\n    depth_commit_reg <= wr_ptr_commit_reg - rd_ptr_reg;\nend\n\n// Read logic\ninteger j;\n\nalways @(posedge clk) begin\n    if (m_axis_tready_pipe) begin\n        // output ready; invalidate stage\n        m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1] <= 1'b0;\n    end\n\n    for (j = RAM_PIPELINE+1-1; j > 0; j = j - 1) begin\n        if (m_axis_tready_pipe || ((~m_axis_tvalid_pipe_reg) >> j)) begin\n            // output ready or bubble in pipeline; transfer down pipeline\n            m_axis_tvalid_pipe_reg[j] <= m_axis_tvalid_pipe_reg[j-1];\n            m_axis_pipe_reg[j] <= m_axis_pipe_reg[j-1];\n            m_axis_tvalid_pipe_reg[j-1] <= 1'b0;\n        end\n    end\n\n    if (m_axis_tready_pipe || ~m_axis_tvalid_pipe_reg) begin\n        // output ready or bubble in pipeline; read new data from FIFO\n        m_axis_tvalid_pipe_reg[0] <= 1'b0;\n        m_axis_pipe_reg[0] <= mem[rd_ptr_reg[ADDR_WIDTH-1:0]];\n        if (!empty && pipe_ready) begin\n            // not empty, increment pointer\n            m_axis_tvalid_pipe_reg[0] <= 1'b1;\n            rd_ptr_reg <= rd_ptr_reg + 1;\n        end\n    end\n\n    if (rst) begin\n        rd_ptr_reg <= {ADDR_WIDTH+1{1'b0}};\n        m_axis_tvalid_pipe_reg <= 0;\n    end\nend\n\ngenerate\n\nif (!OUTPUT_FIFO_ENABLE) begin\n\n    assign pipe_ready = 1'b1;\n\n    assign m_axis_tready_pipe = m_axis_tready_out;\n    assign m_axis_tvalid_out = m_axis_tvalid_pipe;\n\n    assign m_axis_tdata_out = m_axis_tdata_pipe;\n    assign m_axis_tkeep_out = m_axis_tkeep_pipe;\n    assign m_axis_tlast_out = m_axis_tlast_pipe;\n    assign m_axis_tid_out   = m_axis_tid_pipe;\n    assign m_axis_tdest_out = m_axis_tdest_pipe;\n    assign m_axis_tuser_out = m_axis_tuser_pipe;\n\nend else begin : output_fifo\n\n    // output datapath logic\n    reg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\n    reg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\n    reg                  m_axis_tvalid_reg = 1'b0;\n    reg                  m_axis_tlast_reg  = 1'b0;\n    reg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\n    reg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\n    reg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_wr_ptr_reg = 0;\n    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_rd_ptr_reg = 0;\n    reg out_fifo_half_full_reg = 1'b0;\n\n    wire out_fifo_full = out_fifo_wr_ptr_reg == (out_fifo_rd_ptr_reg ^ {1'b1, {OUTPUT_FIFO_ADDR_WIDTH{1'b0}}});\n    wire out_fifo_empty = out_fifo_wr_ptr_reg == out_fifo_rd_ptr_reg;\n\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [DATA_WIDTH-1:0] out_fifo_tdata[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [KEEP_WIDTH-1:0] out_fifo_tkeep[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg                  out_fifo_tlast[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [ID_WIDTH-1:0]   out_fifo_tid[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [DEST_WIDTH-1:0] out_fifo_tdest[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [USER_WIDTH-1:0] out_fifo_tuser[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n\n    assign pipe_ready = !out_fifo_half_full_reg;\n\n    assign m_axis_tready_pipe = 1'b1;\n\n    assign m_axis_tdata_out  = m_axis_tdata_reg;\n    assign m_axis_tkeep_out  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\n    assign m_axis_tvalid_out = m_axis_tvalid_reg;\n    assign m_axis_tlast_out  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\n    assign m_axis_tid_out    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\n    assign m_axis_tdest_out  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\n    assign m_axis_tuser_out  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n    always @(posedge clk) begin\n        m_axis_tvalid_reg <= m_axis_tvalid_reg && !m_axis_tready_out;\n\n        out_fifo_half_full_reg <= $unsigned(out_fifo_wr_ptr_reg - out_fifo_rd_ptr_reg) >= 2**(OUTPUT_FIFO_ADDR_WIDTH-1);\n\n        if (!out_fifo_full && m_axis_tvalid_pipe) begin\n            out_fifo_tdata[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdata_pipe;\n            out_fifo_tkeep[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tkeep_pipe;\n            out_fifo_tlast[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tlast_pipe;\n            out_fifo_tid[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tid_pipe;\n            out_fifo_tdest[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdest_pipe;\n            out_fifo_tuser[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tuser_pipe;\n            out_fifo_wr_ptr_reg <= out_fifo_wr_ptr_reg + 1;\n        end\n\n        if (!out_fifo_empty && (!m_axis_tvalid_reg || m_axis_tready_out)) begin\n            m_axis_tdata_reg <= out_fifo_tdata[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tkeep_reg <= out_fifo_tkeep[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tvalid_reg <= 1'b1;\n            m_axis_tlast_reg <= out_fifo_tlast[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tid_reg <= out_fifo_tid[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tdest_reg <= out_fifo_tdest[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tuser_reg <= out_fifo_tuser[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            out_fifo_rd_ptr_reg <= out_fifo_rd_ptr_reg + 1;\n        end\n\n        if (rst) begin\n            out_fifo_wr_ptr_reg <= 0;\n            out_fifo_rd_ptr_reg <= 0;\n            m_axis_tvalid_reg <= 1'b0;\n        end\n    end\n\nend\n\nif (PAUSE_ENABLE) begin : pause\n\n    // Pause logic\n    reg pause_reg = 1'b0;\n    reg pause_frame_reg = 1'b0;\n\n    assign m_axis_tready_out = m_axis_tready && !pause_reg;\n    assign m_axis_tvalid = m_axis_tvalid_out && !pause_reg;\n\n    assign m_axis_tdata = m_axis_tdata_out;\n    assign m_axis_tkeep = m_axis_tkeep_out;\n    assign m_axis_tlast = m_axis_tlast_out;\n    assign m_axis_tid   = m_axis_tid_out;\n    assign m_axis_tdest = m_axis_tdest_out;\n    assign m_axis_tuser = m_axis_tuser_out;\n\n    assign pause_ack = pause_reg;\n\n    always @(posedge clk) begin\n        if (FRAME_PAUSE) begin\n            if (pause_reg) begin\n                // paused; update pause status\n                pause_reg <= pause_req;\n            end else if (m_axis_tvalid_out) begin\n                // frame transfer; set frame bit\n                pause_frame_reg <= 1'b1;\n                if (m_axis_tready && m_axis_tlast) begin\n                    // end of frame; clear frame bit and update pause status\n                    pause_frame_reg <= 1'b0;\n                    pause_reg <= pause_req;\n                end\n            end else if (!pause_frame_reg) begin\n                // idle; update pause status\n                pause_reg <= pause_req;\n            end\n        end else begin\n            pause_reg <= pause_req;\n        end\n\n        if (rst) begin\n            pause_frame_reg <= 1'b0;\n            pause_reg <= 1'b0;\n        end\n    end\n\nend else begin\n\n    assign m_axis_tready_out = m_axis_tready;\n    assign m_axis_tvalid = m_axis_tvalid_out;\n\n    assign m_axis_tdata = m_axis_tdata_out;\n    assign m_axis_tkeep = m_axis_tkeep_out;\n    assign m_axis_tlast = m_axis_tlast_out;\n    assign m_axis_tid   = m_axis_tid_out;\n    assign m_axis_tdest = m_axis_tdest_out;\n    assign m_axis_tuser = m_axis_tuser_out;\n\n    assign pause_ack = 1'b0;\n\nend\n\nendgenerate\n\nendmodule\n\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 4096\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 64, or a power-of-2 > 64.\n     -- parameter in EntriesMTU = 1504\n        -- Used by the module, at the start of a frame, if there are not at least this many free entries in the FIFO (Depth = inCount),\n           then drop the frame.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned PacketMtuInBytes = 1500\n        -- Maximum Frame size allowed on inAxi4St in Bytes. For example, if AxiStreamWidth=8, then the maximum frame size would be 1500 phits,\n           or cycles worth of data on inAxi4St. If this module's internal FIFO does not have at least this much storage available (almost full),\n           then the frame must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int FifoSizeInBytes = 4096\n        -- The total size of the FIFO in Bytes. For example, if if AxiStreamWidth=8, then it is 1 Byte per data phit, and the FIFO would be 4096 entries Deep.\n     -- parameter int MaxNumberOfPackets = 32\n        -- Maximum number of packets allowed to be stored. For Example, if 32 packets (of any size) are alread stored in the FIFO, then the ingress\n           frame on inAxi4St must be dropped in entirety, by having this module output inTready=1 from its first data phit to the last (inAxi4St.tvalid=1 and inAxi4St.tlast)\n     -- parameter int DropIngressOnAfull = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int DropEgressOnError = 1\n        -- must be set to 1, but this Design doesn't have to use it, but must exist in the parameter list.\n     -- parameter int IngressPrefillBytes = -1\n        -- must be set to -1, but this Design doesn't have to use it, but must exist in the parameter list.\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- This must be tied to 1'b1. Frames are written the FIFO is the FIFO has enough free space at the start of a frame (Depth - inCount > EntriesMTU), ootherwise they are dropped.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: inFifoAfull\n       -- output logic inFifoAfull\n       -- is 1 when the FIFO is \"almost full\" and cannot accept another packet. This is 1 when there are MaxNumberOfPackets stored in the FIFO, or when there are fewer than PacketMtuInBytes remaining in the FIFO storage for tdata.\n    -- Output: inDropEvent\n       -- output logic inDropEvent\n       -- reports a 1 if a packet is dropped to lack of FIFO space.\n          -- This can be reported as a 1 when: inAxi4St.tvalid=1 and inAxi4St.tlast=1, if it was not written to this module's FIFO.\n    -- Output: outDropEvent\n       -- output logic outDropEvent\n       -- For this design, it can be driven with 1'b0.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_storefwd_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo_test.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n  oclib_axist_storefwd_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_5_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_storefwd_fifo_5_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n//   ocsim_axist_driver.sv --(DUT)--> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  parameter int DropIngressOnAfull = `OC_VAL_ASDEFINED_ELSE(DROP_INGRESS_ON_AFULL, 0);\n  parameter int DropEgressOnError  = `OC_VAL_ASDEFINED_ELSE(DROP_EGRESS_ON_ERROR,  0);\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType axi4st_drv;\n  logic                   axi4st_drv__error;\n  logic                   axi4st_drv__tready;\n  logic                   axi4st_drv__tfirst;\n\n  AxiStreamType axi4st_mon;\n  logic                   axi4st_mon__error;\n  logic                   axi4st_mon__tready;\n\n  logic                   inFifoAfull;\n  logic                   inDropEvent;\n  logic                   outDropEvent;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(axi4st_drv),\n     .outError(axi4st_drv__error),\n     .outTready(axi4st_drv__tready)\n     );\n\n\n  // DUT\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .PacketMtuInBytes(1500),\n      .FifoSizeInBytes(4096),\n      .MaxNumberOfPackets(32),\n      .DropIngressOnAfull(DropIngressOnAfull), // 0: inTready=0 if full; 1: inTready=1 forever.\n      .DropEgressOnError(DropEgressOnError)    // 1: head drops error packets\n      )\n  u_dut\n    (.clock,\n     .reset,\n\n     .inAxi4St(axi4st_drv), // <-- Driver\n     .inError(axi4st_drv__error),\n     .inExtra(1'b0),\n     .inTready(axi4st_drv__tready),\n\n     .outAxi4St(axi4st_mon), // --> Monitor\n     .outError(axi4st_mon__error),\n     .outExtra(),\n     .outTready(axi4st_mon__tready),\n\n     .inFifoAfull,\n     .inDropEvent,\n     .outDropEvent\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_mon),\n     .inError(axi4st_mon__error),\n     .inTready(axi4st_mon__tready), // <-- from our driven outTready\n     .outTready(axi4st_mon__tready)\n     );\n\n  logic                   mon_in_pkt;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_mon_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_mon), .inTready(axi4st_mon__tready), .tfirst(),\n     .in_packet(mon_in_pkt) // get this information from the stream.\n     );\n\n  // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n  `OC_SYNC_ASSERT(clock, reset || !DropIngressOnAfull, mon_in_pkt |-> axi4st_mon.tvalid === 1);\n\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  int          tb_dropped_packets_observed = 0;\n  packet_t     dropped_packetqueue [$];\n\n\n  //\n  // Testbench logic to pick up dropped packets, with its own ocsim_axist_monitor\n  // to monitor the dropped packet at DUT ingress.\n  AxiStreamType  axi4st_drv__mon_dropped;\n  logic        is_dropped, drop_through_tlast;\n\n  // AXIStream is slightly annoying here w/out a \"tfirst\" flag on the bus, so we\n  // invent one.\n  // We know a drop happened on axi4st_drv.tvalid && inFifoAfull\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_drv_tfirst\n    (.clock, .reset, .inAxi4St(axi4st_drv), .inTready(axi4st_drv__tready),\n     .tfirst(axi4st_drv__tfirst), .in_packet());\n\n  always_ff @(posedge clock) begin\n\n    // flag to remember to drop this packet:\n    if (axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull)\n      drop_through_tlast <= 1'b1;\n    if (axi4st_drv.tvalid && axi4st_drv.tlast)\n      drop_through_tlast <= '0;\n    if (reset)\n      drop_through_tlast <= '0;\n  end\n\n  always_comb begin\n    is_dropped = '0;\n    if (DropIngressOnAfull &&\n        ((axi4st_drv.tvalid && axi4st_drv__tready && axi4st_drv__tfirst && inFifoAfull) ||\n         drop_through_tlast)) begin\n      is_dropped = 1;\n    end\n\n    axi4st_drv__mon_dropped        = axi4st_drv;\n    axi4st_drv__mon_dropped.tvalid = DropIngressOnAfull && axi4st_drv.tvalid && is_dropped;\n  end\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_mon_dropped\n    (.clock,\n     .reset,\n     .inAxi4St(axi4st_drv__mon_dropped), // Driver out --> DUT dropped it though\n     .inError(),\n     .inTready(1'b1),\n     .outTready()\n     );\n\n  // If we have any dropped packets, fish them out to the TB level\n  always @(negedge clock) begin\n\n    if (u_mon_dropped.mon_packet_queue.size() > 0) begin\n      automatic packet_t pkt = u_mon_dropped.mon_packet_queue.pop_front();\n      dropped_packetqueue.push_back(pkt);\n      tb_dropped_packets_observed++;\n      if (ocsim_pkg::info_verbosity_high()) begin\n        $display(\"%t %m: (dropped packet) pkt=%s\", $realtime,\n                 ocsim_packet_pkg::packet_as_string(pkt));\n      end\n    end\n  end\n\n  initial begin\n    if (!DropIngressOnAfull) begin\n      u_mon_dropped.m_monitor_enable = 0; // disable it\n    end\n  end\n  //\n  // Done with dropping logic\n  //\n\n\n\n  always @(negedge clock) begin\n    // deal with any dropped packets:\n    if (!reset && dropped_packetqueue.size() > 0) begin\n      deal_with_dropped_packets();\n    end\n\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  int main_dropped_packets = 0;\n  function automatic void deal_with_dropped_packets();\n    packet_t dropped_pkt;\n    if (dropped_packetqueue.size() == 0)\n      return;\n\n    // go find this packet in the driver's packetqueue and delete it.\n    dropped_pkt = dropped_packetqueue[0]; // peek at head\n    for (int j = 0; j < u_drv.mon_packet_queue.size(); j++) begin\n      if (dropped_pkt.data.size() == // head of dropped queue's packet\n          u_drv.mon_packet_queue[j].data.size() && // j-th packet of drier's packet queue.\n          dropped_pkt.data ==\n          u_drv.mon_packet_queue[j].data) begin\n\n        u_drv.mon_packet_queue.delete(j);\n        void'(dropped_packetqueue.pop_front());\n\n        main_dropped_packets++;\n\n        if (ocsim_pkg::info_verbosity_medium())\n          $display(\"%t %m: pkt=%s, was observed as dropped\",\n                   $realtime, packet_as_string(dropped_pkt));\n\n      end\n    end\n\n  endfunction : deal_with_dropped_packets\n\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (u_drv.mon_packet_queue.size() == 0) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"mon packet can't match, there is no driven packet, mon=%s\",\n                               packet_as_string(mon)));\n      // Noting to match, bail.\n      return;\n\n    end\n\n    // Check to see if this matches the driven packet.\n    drv = u_drv.mon_packet_queue[0]; // peek\n\n    if (drv.data.size() == mon.data.size() &&\n        drv.data == mon.data) begin\n      // matched the driven packet (was not dropped), compare and done.\n      void'(u_drv.mon_packet_queue.pop_front());\n\n      // If we support dropped packets, the id's won't match:\n      ocsim_packet_pkg::compare_packets(.got(mon), .want(drv),\n                                        .ignore_id(DropIngressOnAfull || DropEgressOnError));\n      return;\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  int num_pkts;\n  int main_driven_packets;\n\n  task automatic wait_for_fifo_full();\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for FIFO to be full/afull\", $realtime);\n\n    if (DropIngressOnAfull) begin\n      while (inFifoAfull !== 1) @(posedge clock); // wait for inAfull=1\n    end else begin\n      while (axi4st_drv__tready !== 0) @(posedge clock); // wait for driver tready=0\n    end\n  endtask : wait_for_fifo_full\n\n  task automatic wait_drv_mon_done(input string s=\"\");\n    // based on packets sent\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for driver to finish packets=%0d, %s\", $realtime,\n               main_driven_packets, s);\n    while (u_drv.num_packets_driven != main_driven_packets)\n      repeat(100) @(posedge clock);\n\n    // based on packets received.\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: waiting for monitor to see all packets=%0d, %s\", $realtime,\n               main_driven_packets - main_dropped_packets, s);\n    while (u_mon.num_packets_received != (main_driven_packets - main_dropped_packets))\n      repeat(100) @(posedge clock);\n  endtask : wait_drv_mon_done\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    // Send 15-20 packets and wait for it to be done.\n    num_pkts = $urandom_range(20, 15);\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    wait_drv_mon_done(\"inital 15-20 packets\");\n\n    // Fill the FIFO until full, based on number of packets, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(45, 33);\n    main_driven_packets += num_pkts; // we're set to hold 32 packets max, so send a few more\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(64), .min_size(32)));\n    end\n    wait_for_fifo_full();\n    repeat(200) @(posedge clock);\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 33-45 packets\");\n\n    // Fill the FIFO until full, based on data buffer filling, have monitor drain more slowly.\n    // Note - if DropIngressOnAfull=1, this will result in drops.\n    u_mon.m_out_tready1_pct = 0;\n    u_drv.m_out_tvalid_pct  = 95;\n    num_pkts = $urandom_range(8, 6); // we should become full after 4 1400B packets\n    main_driven_packets += num_pkts;\n    repeat(num_pkts) begin\n      void'(u_drv.add_rand_packet(.max_size(1500), .min_size(1400)));\n    end\n    wait_for_fifo_full();\n    u_mon.m_out_tready1_pct = 80;\n    u_drv.m_out_tvalid_pct  = 80;\n    wait_drv_mon_done(\"filling on 6-8 1400-1500B packets\");\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/subtrees/verilog-ethernet/verilog-ethernet/lib/axis/rtl/axis_fifo.v' \n\n/*\n\nCopyright (c) 2013-2023 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// Language: Verilog 2001\n\n`resetall\n`timescale 1ns / 1ps\n`default_nettype none\n\n/*\n * AXI4-Stream FIFO\n */\nmodule axis_fifo #\n(\n    // FIFO depth in words\n    // KEEP_WIDTH words per cycle if KEEP_ENABLE set\n    // Rounded up to nearest power of 2 cycles\n    parameter DEPTH = 4096,\n    // Width of AXI stream interfaces in bits\n    parameter DATA_WIDTH = 8,\n    // Propagate tkeep signal\n    // If disabled, tkeep assumed to be 1'b1\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    // tkeep signal width (words per cycle)\n    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),\n    // Propagate tlast signal\n    parameter LAST_ENABLE = 1,\n    // Propagate tid signal\n    parameter ID_ENABLE = 0,\n    // tid signal width\n    parameter ID_WIDTH = 8,\n    // Propagate tdest signal\n    parameter DEST_ENABLE = 0,\n    // tdest signal width\n    parameter DEST_WIDTH = 8,\n    // Propagate tuser signal\n    parameter USER_ENABLE = 1,\n    // tuser signal width\n    parameter USER_WIDTH = 1,\n    // number of RAM pipeline registers\n    parameter RAM_PIPELINE = 1,\n    // use output FIFO\n    // When set, the RAM read enable and pipeline clock enables are removed\n    parameter OUTPUT_FIFO_ENABLE = 0,\n    // Frame FIFO mode - operate on frames instead of cycles\n    // When set, m_axis_tvalid will not be deasserted within a frame\n    // Requires LAST_ENABLE set\n    parameter FRAME_FIFO = 0,\n    // tuser value for bad frame marker\n    parameter USER_BAD_FRAME_VALUE = 1'b1,\n    // tuser mask for bad frame marker\n    parameter USER_BAD_FRAME_MASK = 1'b1,\n    // Drop frames larger than FIFO\n    // Requires FRAME_FIFO set\n    parameter DROP_OVERSIZE_FRAME = FRAME_FIFO,\n    // Drop frames marked bad\n    // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set\n    parameter DROP_BAD_FRAME = 0,\n    // Drop incoming frames when full\n    // When set, s_axis_tready is always asserted\n    // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set\n    parameter DROP_WHEN_FULL = 0,\n    // Mark incoming frames as bad frames when full\n    // When set, s_axis_tready is always asserted\n    // Requires FRAME_FIFO to be clear\n    parameter MARK_WHEN_FULL = 0,\n    // Enable pause request input\n    parameter PAUSE_ENABLE = 0,\n    // Pause between frames\n    parameter FRAME_PAUSE = FRAME_FIFO\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    /*\n     * AXI input\n     */\n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]    s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]  s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    /*\n     * AXI output\n     */\n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [ID_WIDTH-1:0]    m_axis_tid,\n    output wire [DEST_WIDTH-1:0]  m_axis_tdest,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    /*\n     * Pause\n     */\n    input  wire                   pause_req,\n    output wire                   pause_ack,\n\n    /*\n     * Status\n     */\n    output wire [$clog2(DEPTH):0] status_depth,\n    output wire [$clog2(DEPTH):0] status_depth_commit,\n    output wire                   status_overflow,\n    output wire                   status_bad_frame,\n    output wire                   status_good_frame\n);\n\nparameter ADDR_WIDTH = (KEEP_ENABLE && KEEP_WIDTH > 1) ? $clog2(DEPTH/KEEP_WIDTH) : $clog2(DEPTH);\n\nparameter OUTPUT_FIFO_ADDR_WIDTH = RAM_PIPELINE < 2 ? 3 : $clog2(RAM_PIPELINE*2+7);\n\n// check configuration\ninitial begin\n    if (FRAME_FIFO && !LAST_ENABLE) begin\n        $error(\"Error: FRAME_FIFO set requires LAST_ENABLE set (instance %m)\");\n        $finish;\n    end\n\n    if (DROP_OVERSIZE_FRAME && !FRAME_FIFO) begin\n        $error(\"Error: DROP_OVERSIZE_FRAME set requires FRAME_FIFO set (instance %m)\");\n        $finish;\n    end\n\n    if (DROP_BAD_FRAME && !(FRAME_FIFO && DROP_OVERSIZE_FRAME)) begin\n        $error(\"Error: DROP_BAD_FRAME set requires FRAME_FIFO and DROP_OVERSIZE_FRAME set (instance %m)\");\n        $finish;\n    end\n\n    if (DROP_WHEN_FULL && !(FRAME_FIFO && DROP_OVERSIZE_FRAME)) begin\n        $error(\"Error: DROP_WHEN_FULL set requires FRAME_FIFO and DROP_OVERSIZE_FRAME set (instance %m)\");\n        $finish;\n    end\n\n    if ((DROP_BAD_FRAME || MARK_WHEN_FULL) && (USER_BAD_FRAME_MASK & {USER_WIDTH{1'b1}}) == 0) begin\n        $error(\"Error: Invalid USER_BAD_FRAME_MASK value (instance %m)\");\n        $finish;\n    end\n\n    if (MARK_WHEN_FULL && FRAME_FIFO) begin\n        $error(\"Error: MARK_WHEN_FULL is not compatible with FRAME_FIFO (instance %m)\");\n        $finish;\n    end\n\n    if (MARK_WHEN_FULL && !LAST_ENABLE) begin\n        $error(\"Error: MARK_WHEN_FULL set requires LAST_ENABLE set (instance %m)\");\n        $finish;\n    end\nend\n\nlocalparam KEEP_OFFSET = DATA_WIDTH;\nlocalparam LAST_OFFSET = KEEP_OFFSET + (KEEP_ENABLE ? KEEP_WIDTH : 0);\nlocalparam ID_OFFSET   = LAST_OFFSET + (LAST_ENABLE ? 1          : 0);\nlocalparam DEST_OFFSET = ID_OFFSET   + (ID_ENABLE   ? ID_WIDTH   : 0);\nlocalparam USER_OFFSET = DEST_OFFSET + (DEST_ENABLE ? DEST_WIDTH : 0);\nlocalparam WIDTH       = USER_OFFSET + (USER_ENABLE ? USER_WIDTH : 0);\n\nreg [ADDR_WIDTH:0] wr_ptr_reg = {ADDR_WIDTH+1{1'b0}};\nreg [ADDR_WIDTH:0] wr_ptr_commit_reg = {ADDR_WIDTH+1{1'b0}};\nreg [ADDR_WIDTH:0] rd_ptr_reg = {ADDR_WIDTH+1{1'b0}};\n\n(* ramstyle = \"no_rw_check\" *)\nreg [WIDTH-1:0] mem[(2**ADDR_WIDTH)-1:0];\nreg mem_read_data_valid_reg = 1'b0;\n\n(* shreg_extract = \"no\" *)\nreg [WIDTH-1:0] m_axis_pipe_reg[RAM_PIPELINE+1-1:0];\nreg [RAM_PIPELINE+1-1:0] m_axis_tvalid_pipe_reg = 0;\n\n// full when first MSB different but rest same\nwire full = wr_ptr_reg == (rd_ptr_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});\n// empty when pointers match exactly\nwire empty = wr_ptr_commit_reg == rd_ptr_reg;\n// overflow within packet\nwire full_wr = wr_ptr_reg == (wr_ptr_commit_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});\n\nreg s_frame_reg = 1'b0;\n\nreg drop_frame_reg = 1'b0;\nreg mark_frame_reg = 1'b0;\nreg send_frame_reg = 1'b0;\nreg [ADDR_WIDTH:0] depth_reg = 0;\nreg [ADDR_WIDTH:0] depth_commit_reg = 0;\nreg overflow_reg = 1'b0;\nreg bad_frame_reg = 1'b0;\nreg good_frame_reg = 1'b0;\n\nassign s_axis_tready = FRAME_FIFO ? (!full || (full_wr && DROP_OVERSIZE_FRAME) || DROP_WHEN_FULL) : (!full || MARK_WHEN_FULL);\n\nwire [WIDTH-1:0] s_axis;\n\ngenerate\n    assign s_axis[DATA_WIDTH-1:0] = s_axis_tdata;\n    if (KEEP_ENABLE) assign s_axis[KEEP_OFFSET +: KEEP_WIDTH] = s_axis_tkeep;\n    if (LAST_ENABLE) assign s_axis[LAST_OFFSET]               = s_axis_tlast | mark_frame_reg;\n    if (ID_ENABLE)   assign s_axis[ID_OFFSET   +: ID_WIDTH]   = s_axis_tid;\n    if (DEST_ENABLE) assign s_axis[DEST_OFFSET +: DEST_WIDTH] = s_axis_tdest;\n    if (USER_ENABLE) assign s_axis[USER_OFFSET +: USER_WIDTH] = mark_frame_reg ? USER_BAD_FRAME_VALUE : s_axis_tuser;\nendgenerate\n\nwire [WIDTH-1:0] m_axis = m_axis_pipe_reg[RAM_PIPELINE+1-1];\n\nwire                   m_axis_tready_pipe;\nwire                   m_axis_tvalid_pipe = m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1];\n\nwire [DATA_WIDTH-1:0]  m_axis_tdata_pipe  = m_axis[DATA_WIDTH-1:0];\nwire [KEEP_WIDTH-1:0]  m_axis_tkeep_pipe  = KEEP_ENABLE ? m_axis[KEEP_OFFSET +: KEEP_WIDTH] : {KEEP_WIDTH{1'b1}};\nwire                   m_axis_tlast_pipe  = LAST_ENABLE ? m_axis[LAST_OFFSET] : 1'b1;\nwire [ID_WIDTH-1:0]    m_axis_tid_pipe    = ID_ENABLE   ? m_axis[ID_OFFSET +: ID_WIDTH] : {ID_WIDTH{1'b0}};\nwire [DEST_WIDTH-1:0]  m_axis_tdest_pipe  = DEST_ENABLE ? m_axis[DEST_OFFSET +: DEST_WIDTH] : {DEST_WIDTH{1'b0}};\nwire [USER_WIDTH-1:0]  m_axis_tuser_pipe  = USER_ENABLE ? m_axis[USER_OFFSET +: USER_WIDTH] : {USER_WIDTH{1'b0}};\n\nwire                   m_axis_tready_out;\nwire                   m_axis_tvalid_out;\n\nwire [DATA_WIDTH-1:0]  m_axis_tdata_out;\nwire [KEEP_WIDTH-1:0]  m_axis_tkeep_out;\nwire                   m_axis_tlast_out;\nwire [ID_WIDTH-1:0]    m_axis_tid_out;\nwire [DEST_WIDTH-1:0]  m_axis_tdest_out;\nwire [USER_WIDTH-1:0]  m_axis_tuser_out;\n\nwire pipe_ready;\n\nassign status_depth = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {depth_reg, {$clog2(KEEP_WIDTH){1'b0}}} : depth_reg;\nassign status_depth_commit = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {depth_commit_reg, {$clog2(KEEP_WIDTH){1'b0}}} : depth_commit_reg;\nassign status_overflow = overflow_reg;\nassign status_bad_frame = bad_frame_reg;\nassign status_good_frame = good_frame_reg;\n\n// Write logic\nalways @(posedge clk) begin\n    overflow_reg <= 1'b0;\n    bad_frame_reg <= 1'b0;\n    good_frame_reg <= 1'b0;\n\n    if (s_axis_tready && s_axis_tvalid && LAST_ENABLE) begin\n        // track input frame status\n        s_frame_reg <= !s_axis_tlast;\n    end\n\n    if (FRAME_FIFO) begin\n        // frame FIFO mode\n        if (s_axis_tready && s_axis_tvalid) begin\n            // transfer in\n            if ((full && DROP_WHEN_FULL) || (full_wr && DROP_OVERSIZE_FRAME) || drop_frame_reg) begin\n                // full, packet overflow, or currently dropping frame\n                // drop frame\n                drop_frame_reg <= 1'b1;\n                if (s_axis_tlast) begin\n                    // end of frame, reset write pointer\n                    wr_ptr_reg <= wr_ptr_commit_reg;\n                    drop_frame_reg <= 1'b0;\n                    overflow_reg <= 1'b1;\n                end\n            end else begin\n                // store it\n                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n                wr_ptr_reg <= wr_ptr_reg + 1;\n                if (s_axis_tlast || (!DROP_OVERSIZE_FRAME && (full_wr || send_frame_reg))) begin\n                    // end of frame or send frame\n                    send_frame_reg <= !s_axis_tlast;\n                    if (s_axis_tlast && DROP_BAD_FRAME && USER_BAD_FRAME_MASK & ~(s_axis_tuser ^ USER_BAD_FRAME_VALUE)) begin\n                        // bad packet, reset write pointer\n                        wr_ptr_reg <= wr_ptr_commit_reg;\n                        bad_frame_reg <= 1'b1;\n                    end else begin\n                        // good packet or packet overflow, update write pointer\n                        wr_ptr_commit_reg <= wr_ptr_reg + 1;\n                        good_frame_reg <= s_axis_tlast;\n                    end\n                end\n            end\n        end else if (s_axis_tvalid && full_wr && !DROP_OVERSIZE_FRAME) begin\n            // data valid with packet overflow\n            // update write pointer\n            send_frame_reg <= 1'b1;\n            wr_ptr_commit_reg <= wr_ptr_reg;\n        end\n    end else begin\n        // normal FIFO mode\n        if (s_axis_tready && s_axis_tvalid) begin\n            if (drop_frame_reg && MARK_WHEN_FULL) begin\n                // currently dropping frame\n                if (s_axis_tlast) begin\n                    // end of frame\n                    if (!full && mark_frame_reg) begin\n                        // terminate marked frame\n                        mark_frame_reg <= 1'b0;\n                        mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n                        wr_ptr_reg <= wr_ptr_reg + 1;\n                        wr_ptr_commit_reg <= wr_ptr_reg + 1;\n                    end\n                    // end of frame, clear drop flag\n                    drop_frame_reg <= 1'b0;\n                    overflow_reg <= 1'b1;\n                end\n            end else if ((full || mark_frame_reg) && MARK_WHEN_FULL) begin\n                // full or marking frame\n                // drop frame; mark if this isn't the first cycle\n                drop_frame_reg <= 1'b1;\n                mark_frame_reg <= mark_frame_reg || s_frame_reg;\n                if (s_axis_tlast) begin\n                    drop_frame_reg <= 1'b0;\n                    overflow_reg <= 1'b1;\n                end\n            end else begin\n                // transfer in\n                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n                wr_ptr_reg <= wr_ptr_reg + 1;\n                wr_ptr_commit_reg <= wr_ptr_reg + 1;\n            end\n        end else if ((!full && !drop_frame_reg && mark_frame_reg) && MARK_WHEN_FULL) begin\n            // terminate marked frame\n            mark_frame_reg <= 1'b0;\n            mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;\n            wr_ptr_reg <= wr_ptr_reg + 1;\n            wr_ptr_commit_reg <= wr_ptr_reg + 1;\n        end\n    end\n\n    if (rst) begin\n        wr_ptr_reg <= {ADDR_WIDTH+1{1'b0}};\n        wr_ptr_commit_reg <= {ADDR_WIDTH+1{1'b0}};\n\n        s_frame_reg <= 1'b0;\n\n        drop_frame_reg <= 1'b0;\n        mark_frame_reg <= 1'b0;\n        send_frame_reg <= 1'b0;\n        overflow_reg <= 1'b0;\n        bad_frame_reg <= 1'b0;\n        good_frame_reg <= 1'b0;\n    end\nend\n\n// Status\nalways @(posedge clk) begin\n    depth_reg <= wr_ptr_reg - rd_ptr_reg;\n    depth_commit_reg <= wr_ptr_commit_reg - rd_ptr_reg;\nend\n\n// Read logic\ninteger j;\n\nalways @(posedge clk) begin\n    if (m_axis_tready_pipe) begin\n        // output ready; invalidate stage\n        m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1] <= 1'b0;\n    end\n\n    for (j = RAM_PIPELINE+1-1; j > 0; j = j - 1) begin\n        if (m_axis_tready_pipe || ((~m_axis_tvalid_pipe_reg) >> j)) begin\n            // output ready or bubble in pipeline; transfer down pipeline\n            m_axis_tvalid_pipe_reg[j] <= m_axis_tvalid_pipe_reg[j-1];\n            m_axis_pipe_reg[j] <= m_axis_pipe_reg[j-1];\n            m_axis_tvalid_pipe_reg[j-1] <= 1'b0;\n        end\n    end\n\n    if (m_axis_tready_pipe || ~m_axis_tvalid_pipe_reg) begin\n        // output ready or bubble in pipeline; read new data from FIFO\n        m_axis_tvalid_pipe_reg[0] <= 1'b0;\n        m_axis_pipe_reg[0] <= mem[rd_ptr_reg[ADDR_WIDTH-1:0]];\n        if (!empty && pipe_ready) begin\n            // not empty, increment pointer\n            m_axis_tvalid_pipe_reg[0] <= 1'b1;\n            rd_ptr_reg <= rd_ptr_reg + 1;\n        end\n    end\n\n    if (rst) begin\n        rd_ptr_reg <= {ADDR_WIDTH+1{1'b0}};\n        m_axis_tvalid_pipe_reg <= 0;\n    end\nend\n\ngenerate\n\nif (!OUTPUT_FIFO_ENABLE) begin\n\n    assign pipe_ready = 1'b1;\n\n    assign m_axis_tready_pipe = m_axis_tready_out;\n    assign m_axis_tvalid_out = m_axis_tvalid_pipe;\n\n    assign m_axis_tdata_out = m_axis_tdata_pipe;\n    assign m_axis_tkeep_out = m_axis_tkeep_pipe;\n    assign m_axis_tlast_out = m_axis_tlast_pipe;\n    assign m_axis_tid_out   = m_axis_tid_pipe;\n    assign m_axis_tdest_out = m_axis_tdest_pipe;\n    assign m_axis_tuser_out = m_axis_tuser_pipe;\n\nend else begin : output_fifo\n\n    // output datapath logic\n    reg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\n    reg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\n    reg                  m_axis_tvalid_reg = 1'b0;\n    reg                  m_axis_tlast_reg  = 1'b0;\n    reg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\n    reg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\n    reg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\n    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_wr_ptr_reg = 0;\n    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_rd_ptr_reg = 0;\n    reg out_fifo_half_full_reg = 1'b0;\n\n    wire out_fifo_full = out_fifo_wr_ptr_reg == (out_fifo_rd_ptr_reg ^ {1'b1, {OUTPUT_FIFO_ADDR_WIDTH{1'b0}}});\n    wire out_fifo_empty = out_fifo_wr_ptr_reg == out_fifo_rd_ptr_reg;\n\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [DATA_WIDTH-1:0] out_fifo_tdata[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [KEEP_WIDTH-1:0] out_fifo_tkeep[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg                  out_fifo_tlast[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [ID_WIDTH-1:0]   out_fifo_tid[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [DEST_WIDTH-1:0] out_fifo_tdest[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n    (* ram_style = \"distributed\", ramstyle = \"no_rw_check, mlab\" *)\n    reg [USER_WIDTH-1:0] out_fifo_tuser[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];\n\n    assign pipe_ready = !out_fifo_half_full_reg;\n\n    assign m_axis_tready_pipe = 1'b1;\n\n    assign m_axis_tdata_out  = m_axis_tdata_reg;\n    assign m_axis_tkeep_out  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};\n    assign m_axis_tvalid_out = m_axis_tvalid_reg;\n    assign m_axis_tlast_out  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;\n    assign m_axis_tid_out    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};\n    assign m_axis_tdest_out  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};\n    assign m_axis_tuser_out  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};\n\n    always @(posedge clk) begin\n        m_axis_tvalid_reg <= m_axis_tvalid_reg && !m_axis_tready_out;\n\n        out_fifo_half_full_reg <= $unsigned(out_fifo_wr_ptr_reg - out_fifo_rd_ptr_reg) >= 2**(OUTPUT_FIFO_ADDR_WIDTH-1);\n\n        if (!out_fifo_full && m_axis_tvalid_pipe) begin\n            out_fifo_tdata[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdata_pipe;\n            out_fifo_tkeep[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tkeep_pipe;\n            out_fifo_tlast[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tlast_pipe;\n            out_fifo_tid[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tid_pipe;\n            out_fifo_tdest[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdest_pipe;\n            out_fifo_tuser[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tuser_pipe;\n            out_fifo_wr_ptr_reg <= out_fifo_wr_ptr_reg + 1;\n        end\n\n        if (!out_fifo_empty && (!m_axis_tvalid_reg || m_axis_tready_out)) begin\n            m_axis_tdata_reg <= out_fifo_tdata[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tkeep_reg <= out_fifo_tkeep[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tvalid_reg <= 1'b1;\n            m_axis_tlast_reg <= out_fifo_tlast[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tid_reg <= out_fifo_tid[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tdest_reg <= out_fifo_tdest[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            m_axis_tuser_reg <= out_fifo_tuser[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];\n            out_fifo_rd_ptr_reg <= out_fifo_rd_ptr_reg + 1;\n        end\n\n        if (rst) begin\n            out_fifo_wr_ptr_reg <= 0;\n            out_fifo_rd_ptr_reg <= 0;\n            m_axis_tvalid_reg <= 1'b0;\n        end\n    end\n\nend\n\nif (PAUSE_ENABLE) begin : pause\n\n    // Pause logic\n    reg pause_reg = 1'b0;\n    reg pause_frame_reg = 1'b0;\n\n    assign m_axis_tready_out = m_axis_tready && !pause_reg;\n    assign m_axis_tvalid = m_axis_tvalid_out && !pause_reg;\n\n    assign m_axis_tdata = m_axis_tdata_out;\n    assign m_axis_tkeep = m_axis_tkeep_out;\n    assign m_axis_tlast = m_axis_tlast_out;\n    assign m_axis_tid   = m_axis_tid_out;\n    assign m_axis_tdest = m_axis_tdest_out;\n    assign m_axis_tuser = m_axis_tuser_out;\n\n    assign pause_ack = pause_reg;\n\n    always @(posedge clk) begin\n        if (FRAME_PAUSE) begin\n            if (pause_reg) begin\n                // paused; update pause status\n                pause_reg <= pause_req;\n            end else if (m_axis_tvalid_out) begin\n                // frame transfer; set frame bit\n                pause_frame_reg <= 1'b1;\n                if (m_axis_tready && m_axis_tlast) begin\n                    // end of frame; clear frame bit and update pause status\n                    pause_frame_reg <= 1'b0;\n                    pause_reg <= pause_req;\n                end\n            end else if (!pause_frame_reg) begin\n                // idle; update pause status\n                pause_reg <= pause_req;\n            end\n        end else begin\n            pause_reg <= pause_req;\n        end\n\n        if (rst) begin\n            pause_frame_reg <= 1'b0;\n            pause_reg <= 1'b0;\n        end\n    end\n\nend else begin\n\n    assign m_axis_tready_out = m_axis_tready;\n    assign m_axis_tvalid = m_axis_tvalid_out;\n\n    assign m_axis_tdata = m_axis_tdata_out;\n    assign m_axis_tkeep = m_axis_tkeep_out;\n    assign m_axis_tlast = m_axis_tlast_out;\n    assign m_axis_tid   = m_axis_tid_out;\n    assign m_axis_tdest = m_axis_tdest_out;\n    assign m_axis_tuser = m_axis_tuser_out;\n\n    assign pause_ack = 1'b0;\n\nend\n\nendgenerate\n\nendmodule\n\n`resetall\n",
    "name": "test_axist_storefwd_fifo_5",
    "return_code": 0,
    "stdout": "",
    "stderr": "%Error: dut.sv:4:36: syntax error, unexpected IDENTIFIER, expecting TYPE-IDENTIFIER\n    4 |     parameter type AxiStreamType = axi4st_8_s,\n      |                                    ^~~~~~~~~~\n%Error: dut.sv:6:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n    6 |     parameter int unsigned ExtraDataWidth = 1,\n      |     ^~~~~~~~~\n%Error: dut.sv:7:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n    7 |     parameter int unsigned PacketMtuInBytes = 1500,\n      |     ^~~~~~~~~\n%Error: dut.sv:8:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n    8 |     parameter int FifoSizeInBytes = 4096,\n      |     ^~~~~~~~~\n%Error: dut.sv:9:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n    9 |     parameter int MaxNumberOfPackets = 32,\n      |     ^~~~~~~~~\n%Error: dut.sv:10:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n   10 |     parameter int DropIngressOnAfull = 1,\n      |     ^~~~~~~~~\n%Error: dut.sv:11:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n   11 |     parameter int DropEgressOnError = 1,\n      |     ^~~~~~~~~\n%Error: dut.sv:12:5: syntax error, unexpected parameter, expecting IDENTIFIER or randomize\n   12 |     parameter int IngressPrefillBytes = -1\n      |     ^~~~~~~~~\n%Error: dut.sv:13:1: syntax error, unexpected ')', expecting ';'\n   13 | )(\n      | ^\n%Error: dut.sv:15:5: syntax error, unexpected input\n   15 |     input  logic                           reset,\n      |     ^~~~~\n%Error: dut.sv:16:5: syntax error, unexpected input\n   16 |     input  AxiStreamType                   inAxi4St,\n      |     ^~~~~\n%Error: dut.sv:18:5: syntax error, unexpected output\n   18 |     output AxiStreamType                   outAxi4St,\n      |     ^~~~~~\n%Error: dut.sv:20:5: syntax error, unexpected input\n   20 |     input  logic                           inError,\n      |     ^~~~~\n%Error: dut.sv:21:5: syntax error, unexpected input\n   21 |     input  logic [ExtraDataWidth-1:0]      inExtra,\n      |     ^~~~~\n%Error: dut.sv:22:5: syntax error, unexpected output\n   22 |     output logic                           outError,\n      |     ^~~~~~\n%Error: dut.sv:23:5: syntax error, unexpected output\n   23 |     output logic [ExtraDataWidth-1:0]      outExtra,\n      |     ^~~~~~\n%Error: dut.sv:24:5: syntax error, unexpected output\n   24 |     output logic                           inFifoAfull,\n      |     ^~~~~~\n%Error: dut.sv:25:5: syntax error, unexpected output\n   25 |     output logic                           inDropEvent,\n      |     ^~~~~~\n%Error: dut.sv:26:5: syntax error, unexpected output\n   26 |     output logic                           outDropEvent\n      |     ^~~~~~\n%Error: dut.sv:37:5: syntax error, unexpected IDENTIFIER, expecting TYPE-IDENTIFIER\n   37 |     AxiStreamType axi4st;\n      |     ^~~~~~~~~~~~~\n%Error: dut.sv:40:1: syntax error, unexpected '}'\n   40 | } fifo_data_t;\n      | ^\n%Error: dut.sv:47:1: syntax error, unexpected assign\n   47 | assign packet_start = inAxi4St.tvalid && !drop_packet;\n      | ^~~~~~\n%Error: Exiting due to 22 error(s)\n",
    "pass": false,
    "score": 0,
    "warnings": 0,
    "errors": 23,
    "runtime": 0.1883401870727539,
    "batch_iter": 0,
    "batch_uuid": "bb732651-91bf-4891-96a6-86cdc024412c",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_bb732651-91bf-4891-96a6-86cdc024412c_0",
    "start_time": 1733527789.7948122,
    "stop_time": 1733527789.9831524
  },
  {
    "index": 20,
    "dut": "module dut #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int AxiStreamWidth = 8,\n  parameter int unsigned FlopArbSel = 0,\n  parameter int unsigned FlopOutput = 0,\n  parameter int unsigned NumInputs = 4,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n) (\n  input logic clock,\n  input logic reset,\n  input AxiStreamType [NumInputs-1:0] inAxi4St,\n  output logic [NumInputs-1:0] inTready,\n  output AxiStreamType outAxi4St,\n  input logic outTready\n);\n\n  logic [NumInputs-1:0] grant;\n  logic [NumSelectBits-1:0] select;\n  logic [NumInputs-1:0] requests;\n  logic update_valid;\n  logic in_packet_on_out;\n  logic tfirst_on_out;\n\n  // Instance of round robin arbiter\n  local_rrarb #(\n    .NumInputs(NumInputs),\n    .NumSelectBits(NumSelectBits)\n  ) u_rrarb (\n    .clock(clock),\n    .reset(reset),\n    .update_valid(update_valid),\n    .requests_in(requests),\n    .grant_out(grant),\n    .select_out(select)\n  );\n\n  // Instance to track output packet status\n  local_axist_tfirst #(\n    .AxiStreamType(AxiStreamType)\n  ) u_tfirst (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(outAxi4St),\n    .inTready(outTready),\n    .tfirst(tfirst_on_out),\n    .in_packet(in_packet_on_out)\n  );\n\n  // Generate requests vector based on input tvalids\n  always_comb begin\n    for(int i=0; i<NumInputs; i++) begin\n      requests[i] = inAxi4St[i].tvalid;\n    end\n  end\n\n  // Update valid logic\n  always_ff @(posedge clock) begin\n    if(reset) begin\n      update_valid <= 1'b1;\n    end else begin\n      update_valid <= !in_packet_on_out || (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n    end\n  end\n\n  // Route selected input to output\n  always_comb begin\n    outAxi4St = inAxi4St[select];\n  end\n\n  // Generate input ready signals\n  always_comb begin\n    inTready = '0;\n    inTready[select] = outTready & grant[select];\n  end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can arbitrate among a parameterized number of AXI4 Stream protocol inputs (parameter int NumInputs = 4) and transfer the arbitrated winner to the one output AXI4 Stream protocol output. There should be zero cycles of latency from the winning input AXI4 Stream to the output AXI4 Stream.\n-- Please perform Round Robin Arbitration. This cannot be a simple priority encoder of requests. For example if input port [0] was the winner while other ports (such as [1] and [2]) are wishing to transfer data, the next winner after input port [0] has transferred a frame or packet cannot be port [0] again.\n\nAdditionally, you are required to use the following module (without revealing the internals) to perform round robin arbitration. The outputs of local_rrarb (grant_out, and select_out) are held and will not change unless input update_valid=1. When update_valid=1, a requests_in (vector of request valid bits) is also set, and a new arbitration winner is on the outputs -- grant_out is a 1-hot vector, and select_out is the encoded winner with values between 0 and NumInputs-1.\n\nmodule local_rrarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = $clog2(NumInputs) == 0 ? 1 : $clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int AxiStreamWidth = 8\n        -- This parameter does not need to be used, but must exist in the parameter list.\n        -- Tells the module how many bits are in AxiStreamType.tdata\n     -- parameter int unsigned FlopArbSel = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n     -- parameter int unsigned FlopOutput = 0\n        -- This parameter does not need to be used, but must exist in the parameter list.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumInputs - 1 : 0] inAxi4St\n       -- The AXI4 Stream inputs, and is packed array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic [NumInputs-1:0] inTready\n       -- based on which arbitrated input port winner we are transferring, and if input outTready=1 to advance the transfer.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The single AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St\n\n\nAdditionally, you are required to use the folowing module (without revealing the internals) to determine when a packet or frame starts on any of the inputs.\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n\nThis will be useful for determining how to drive helper module local_rrarb's input vector for \"update_valid\". For example, if you were to connect dut's output outAxist4St and outTready to an instance of local_axist_tfirst, you could know if the output is in the middle of sending a packet:\n\nlogic in_packet_on_outAxi4St; // from local_axist_tfirst module output\nlocig update_valid; // update_valid to input of local_rrarb module\n\nalways_ff @(posedge clock) begin\n\n  update_valid <=\n    // we are not in a packet now, safe to set update_valid=1 next cycle\n    in_packet_on_outaxi4st ||\n    // OR, we just transfered the final outbound data phit, safe to set update_valid=1 next cycle\n    (outAxi4St.tvalid && outTready && outAxi4St.tlast);\n\nend\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_rrarb_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb_test.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb_test;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n  oclib_axist_rrarb\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : oclib_axist_rrarb_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/local_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = local_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = local_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/local_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_tfirst\n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_rrarb_4_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// (Test for oclib_axist_rrarb.sv)\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n`ifndef NUM_INPUTS\n`define NUM_INPUTS 3\n`endif\n\n\n  parameter int NumInputs  = `NUM_INPUTS ;\n  parameter int FlopArbSel = `OC_VAL_ASDEFINED_ELSE(FLOP_ARB_SEL, 0);\n  parameter int FlopOutput = `OC_VAL_ASDEFINED_ELSE(FLOP_OUTPUT,  0);\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n\n\n  AxiStreamType  [15:0] inAxi4St; // support up to NumInputs=16\n  logic [15:0]          inTready;\n\n  AxiStreamType                     outAxi4St;\n  logic                     outTready;\n\n\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(.NumInputs(NumInputs),\n      .FlopArbSel(FlopArbSel),\n      .FlopOutput(FlopOutput),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.clock, .reset,\n     .inAxi4St(inAxi4St[NumInputs - 1 : 0]), // only connect NumInputs worth of our max 16 ports.\n     .inTready(inTready[NumInputs - 1 : 0]),\n     .outAxi4St,\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  generate\n    for (genvar g = 0; g < 16; g++) begin : gen_drv\n\n      // Support up to 16 drivers\n      ocsim_axist_driver\n        #(.AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth)\n          )\n      u_drv\n        (.clock,\n         .reset,\n         .outAxi4St(inAxi4St[g]), // Driver out --> DUT in\n         .outError(),\n         .outTready(inTready[g])\n         );\n\n      initial begin\n        if (g >= NumInputs) begin\n          u_drv.m_driver_enable = 0; // disable it\n        end\n      end\n\n\n    end\n\n  endgenerate\n\n\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St), // Monitor in <-- DUT out\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  // We should only be servicing one ingress port at a time, or none:\n  `OC_SYNC_ASSERT_STR(clock, !seen_rst || reset, $onehot0(inTready),\n                      $sformatf(\"inTready has mulitple bits set, check waves\"));\n\n  // Stats are already kept per monitor, but for checking that the DUT is implemented\n  // as some form of Round Robin, we can check on who had tlast serviced, when others\n  // ports had tvalid=1 tready=0.\n  // Note this check is still somewhat loose, to allow an implementation that takes > 0 cycles\n  // to arbitrate new winners. Instead we check that a port's arbitration-missed deficit cannot\n  // exceed NumInputs+1.\n  bit [NumInputs - 1 : 0][31:0] tb__tvalid_not_serviced_count = '0; // not serviced deficit.\n  int                           tb__prev_port_serviced = -1;\n  always @(posedge clock) begin\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inTready[i] && inAxi4St[i].tvalid && inAxi4St[i].tlast) begin\n          update_and_check_arb_behavior(.finished_port(i));\n        end\n    end\n  end\n\n  function automatic void update_and_check_arb_behavior(input int finished_port);\n    // clear the not-serviced-count for this port, we just finished servicing it.\n    tb__tvalid_not_serviced_count[finished_port] = '0;\n    tb__prev_port_serviced = finished_port;\n\n    // Any other ports that were valid, increment their counts.\n    // This should be ON the tlast=1 cycle for the finished_port, so this might not\n    // match the DUT if this cycle some port has tvalid=0 but next cycles has tvalid=1 AND\n    // the DUT decides that is the new winner.\n    for (int unsigned i = 0; i < NumInputs; i++) begin\n      if (inAxi4St[i].tvalid && !inTready[i] && i != finished_port) begin\n        tb__tvalid_not_serviced_count[i]++;\n      end\n\n      // At no point can any count exceed NumInputs (+1 to give some wiggle room on the DUT\n      // implementation). On a 0-latency RRARB this should be <= NumInputs - 1. This is a check\n      // on how many other ports completed a packet before we completed our packet (checked at tlast=1\n      // on the serviced port).\n      `OC_ASSERT_STR(tb__tvalid_not_serviced_count[i] <= NumInputs,\n                     $sformatf(\"Input port=%0d tvalid=1, not been serviced for %0d other packets (NumInputs=%0d)\",\n                               i, tb__tvalid_not_serviced_count[i], NumInputs));\n\n    end\n  endfunction : update_and_check_arb_behavior\n\n\n  // Keep track in this testbench of the packets we've driven, per input port\n  packet_t driven_packetqueue [int][$];\n\n  // For calls to gen_drv[g].u_drv.add_rand_packet(..) we are going to use a\n  // helper function, and since path calls need to be static (aka, gen_drv[g].u_drv.add_rand_packet(..)\n  // is not allowed, it has to be gen_drv[0].u_drv.add_rand_packet(...), we'll use\n  // helper macros.\n  int glbl_pkt_id = 0;\n  function automatic packet_t add_rand_packet(input int        port,\n                                              input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n\n    // we'll store the original ingress Port in decimal, port0: 0-9999, port1 = 10000-19999, etc\n    // the packet id:\n    packet_t ret;\n    int      id;\n    glbl_pkt_id++;\n    id = (port * 10_000) + glbl_pkt_id;\n\n    if (port >= NumInputs) begin\n      return ret;\n    end\n\n    case (port)\n    0:  ret = gen_drv[ 0].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    1:  ret = gen_drv[ 1].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    2:  ret = gen_drv[ 2].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    3:  ret = gen_drv[ 3].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    4:  ret = gen_drv[ 4].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    5:  ret = gen_drv[ 5].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    6:  ret = gen_drv[ 6].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    7:  ret = gen_drv[ 7].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    8:  ret = gen_drv[ 8].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    9:  ret = gen_drv[ 9].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    10: ret = gen_drv[10].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    11: ret = gen_drv[11].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    12: ret = gen_drv[12].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    13: ret = gen_drv[13].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    14: ret = gen_drv[14].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    15: ret = gen_drv[15].u_drv.add_rand_packet(.max_size(max_size), .min_size(min_size), .id(id));\n    default: ;\n    endcase // case (port)\n\n    if (port < NumInputs) begin\n      driven_packetqueue[port].push_back(ret);\n    end\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: port=%0d, pkt=%s, driven_packetqueue[port=%0d].size()=%0d\",\n               $realtime, port, packet_as_string(ret), port, driven_packetqueue[port].size());\n\n\n    return ret;\n  endfunction : add_rand_packet\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    int drv_port;\n    packet_t drv, mon;\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    // Sadly the packet_t.id does not survive through the HW, so the monitor doesn't really\n    // know which port it came from. We'll have to check them all.\n    drv_port = -1;\n    for (int unsigned port = 0; port < NumInputs; port++) begin\n      // peek\n      if (driven_packetqueue[port].size() > 0) begin\n        drv = driven_packetqueue[port][0];\n        // check size and data:\n        if (drv.data.size() == mon.data.size() &&\n            drv.data == mon.data) begin\n\n          drv_port = port;\n          break;\n        end\n      end\n    end\n\n    if (drv_port < 0 || drv_port >= NumInputs) begin\n      `OC_ASSERT_STR(0,\n                     $sformatf(\"drv_port=%0d didn't find a matching packet in driven_packetqueue for mon=%s\",\n                               drv_port, packet_as_string(mon)));\n      return;\n    end\n\n    void'(driven_packetqueue[drv_port].pop_front());\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: (drv_port=%0d) mon=%s drv=%s\", $realtime,\n               drv_port,\n               ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv), .ignore_id(1));\n  endfunction : check_driver_vs_monitor\n\n\n  int main_driven_packets = 0;\n\n  initial begin : main\n    @(posedge clock);\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(20) begin\n      // add 20 packets to a random port.\n      automatic int port = $urandom_range(NumInputs - 1, 0);\n      void'(add_rand_packet(.port(port), .max_size(200)));\n      main_driven_packets++;\n    end\n\n    // wait for monitor to have seen all the packets from all inputs.\n    while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n\n\n    // To avoid any queuing and having the RRARB cycle through 0, 1, 2, 0, 1 ,2, etc\n    // do a smaller number of packets.\n    repeat(10) begin\n      repeat(2) begin\n        // add 2 packets to a random port.\n        automatic int port = $urandom_range(NumInputs - 1, 0);\n        void'(add_rand_packet(.port(port), .max_size(200)));\n        main_driven_packets++;\n      end\n\n      // wait for monitor to have seen all the packets from all inputs.\n      while (u_mon.num_packets_received != main_driven_packets) repeat(100) @(posedge clock);\n    end\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    gen_drv[0].u_drv.eot_checks();\n    gen_drv[1].u_drv.eot_checks();\n    gen_drv[2].u_drv.eot_checks();\n    gen_drv[3].u_drv.eot_checks();\n    gen_drv[4].u_drv.eot_checks();\n    gen_drv[5].u_drv.eot_checks();\n    gen_drv[6].u_drv.eot_checks();\n    gen_drv[7].u_drv.eot_checks();\n    gen_drv[8].u_drv.eot_checks();\n    gen_drv[9].u_drv.eot_checks();\n    gen_drv[10].u_drv.eot_checks();\n    gen_drv[11].u_drv.eot_checks();\n    gen_drv[12].u_drv.eot_checks();\n    gen_drv[13].u_drv.eot_checks();\n    gen_drv[14].u_drv.eot_checks();\n    gen_drv[15].u_drv.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\n\nendmodule : tb\n",
    "name": "test_axist_rrarb_4",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_bb732651-91bf-4891-96a6-86cdc024412c_1/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_axist_driver__DepSet_hbd398ec9__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_axist_driver__Slow.cpp Vtb_ocsim_axist_driver__DepSet_hbd398ec9__0__Slow.cpp Vtb_ocsim_axist_driver__DepSet_h608c9d06__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_bb732651-91bf-4891-96a6-86cdc024412c_1/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.321 MB sources in 22 modules, into 1.098 MB in 20 C++ files needing 0.008 MB\n- Verilator: Walltime 2.805 s (elab=0.007, cvt=0.064, bld=2.320); cpu 1.292 s on 64 threads; alloced 159.914 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20001, error: 0, timestamp_ps=4671226772094713856, data: {size: 80, data: 02e478bc_b6e4b753 21e1c582_62351256 fdf43b58_b25c1e9e 9eee1076_63c01d22 06816378_6fcef7d1 9e776ea8_4fbb94e2 661f09e3_1f84c533 4b9cf3c9_edca5d47 24efa96d_3978eac2 5454239d_b3add52e}}, driven_packetqueue[port=2].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20002, error: 0, timestamp_ps=4671226772094713856, data: {size: 99, data: d789f6af_ef9d3fcf 2a779a0b_53af8c02 fbe8c2dd_c86461e5 21f359f5_bd7e62ca 90455810_6073fc3d 6c0ee737_4740331c b6d73a67_5384f4e4 2867953c_64958a3d 7f5bdcec_c6467904 d434bd1b_02715363 def0045f_f8238061 6157d2fc_bc7b317e ed64d4}}, driven_packetqueue[port=2].size()=2\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10003, error: 0, timestamp_ps=4671226772094713856, data: {size: 195, data: cbcbdbe9_4e244207 00d63f39_f9d77a76 7c42ae76_2b27d2a2 06090fdc_e45979ac 80f7ea8d_af8910ca c6ab784c_f75a5411 c9291014_712a318c e682866e_d96e8db8 548d69d6_6e65b257 4e6499a9_4043aaf6 e7d72253_860ee4c9 4049f309_f85b9610 826dde1b_80dd3b7a 9f0ab89c_d3b44983 dce9561f_5f658cd8 ed68193c_c56723bf 01844393_231b47e8 a96a799a_4ef32f29 f18066a9_916155e2 0486cee7_d19b4c7e 986d3184_2037d10b cfd7ac20_4dc8c2dc abbab4c6_0314de4e ab49162c_91c50798 169624}}, driven_packetqueue[port=1].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20004, error: 0, timestamp_ps=4671226772094713856, data: {size: 114, data: fc4972c0_b43c151f 8dc37444_8556cb91 eaa4bb97_054192fa 1471e190_dd5abc7f dfc2b2e4_08607d84 d1ac4b17_84e68979 a9080756_5bd44c8f acf0adee_cb380c0e ab8145be_8462cde9 b31f2220_e662fa6e a7ded685_a3a55bb9 9c71786e_59657165 da867758_3750cb24 6c0f8bec_a266d95e 37db}}, driven_packetqueue[port=2].size()=3\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10005, error: 0, timestamp_ps=4671226772094713856, data: {size: 195, data: 553c5e89_da01634e 9bccda12_1f909132 94c2c573_eca81d11 a9ad035c_08585e1a f004278b_15b80e58 be09cdc0_46309a87 4ac2cd1f_def29988 ffbfea3e_3c17508a ffdc288a_d86e3c1f 935a5c59_b59bccf8 cec85d25_68b168b0 87b12106_8e6bd938 22ffd2c2_de5f172b 9a6d40c2_07153d69 607e037e_40fedb6d 3e887dc5_c6f61368 0effee13_309a479b c6d1522d_57417f37 0bd63f1c_2d131288 a8612ecc_d7be9be5 c2c639f1_15a57a80 24e47f75_1b73326c 7960c0ec_ee33d95b 4bd14f5a_574005ad b9bbce}}, driven_packetqueue[port=1].size()=2\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 6, error: 0, timestamp_ps=4671226772094713856, data: {size: 96, data: cfe4a9fd_cba357b0 abdc957d_da5eb2a2 dcac2d5f_0955120b f45a677b_062e3354 ce2a62bc_0fe01f5d eed8c7d1_d2f8b199 a8cf8c5e_433a0a33 df8d2c81_bfe7066c c682856b_f0908540 12cabcae_430dc2ee 58bc411f_c07275d8 f6df60c7_c9601b5d}}, driven_packetqueue[port=0].size()=1\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20007, error: 0, timestamp_ps=4671226772094713856, data: {size: 176, data: 9b5c176e_33505407 3db302a7_4e45cf0f a9c954ed_41d5fb50 f02c0f06_ffb1977f bbc0e8eb_987d144e 842448e6_4e1fb34f ec9c1d87_30aa365b bc2cf4a5_7a124404 71f7560d_844ecade 2c0fb7ee_c12e6563 aeeb5a23_a49f943c e690472d_54032386 5494a34b_f3f7a6c5 3a810e58_12e671e4 790f3c47_914f6d0b 10d84089_11f9bd84 7c804bca_4cb85df2 e44451af_40e645b7 58a56ef5_64629819 18f18467_9ca4be19 b64157c7_d75faa16 459161dc_172014f8}}, driven_packetqueue[port=2].size()=4\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 8, error: 0, timestamp_ps=4671226772094713856, data: {size: 154, data: cead5e36_624b7148 e8280743_5520a660 c2352099_180483d9 336498e7_431c9d52 6fe54837_4b7238ae 3c293667_a5e4b0a6 90063ebb_d9d7611c 14bdee3a_f66ee422 5b0b5328_4165ac16 6a7e4bb0_2dd4531b 138fba9a_9d5f5c7f 98bf7b1b_eb4e86e0 55aece2b_08533d8f a6c48afd_63838295 90a82493_249875a3 28566fd0_38a59fa8 d6f5db56_f634efc8 3b7bf6b3_e3de105f 17cdc0f3_ff9bda61 855b}}, driven_packetqueue[port=0].size()=2\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10009, error: 0, timestamp_ps=4671226772094713856, data: {size: 142, data: 3e6d9791_226e1f7f 1180f269_91ee78f9 8af08984_349aa2a1 e5ffcb7f_ff1151e4 d6bab4e1_46a312d3 6d919edc_7e304ca5 a1a1daba_72ef6d58 641e6d17_1f052219 b30de20e_dbbed225 1b72989e_419e92af c7bf9343_17037aaa 9274a505_56b6fb67 8dd184d5_3a4917df bfd08fab_630ac9a5 476f00fc_67022d7d 77b49490_4927d802 45894eae_0b321591 dce9d991_6027}}, driven_packetqueue[port=1].size()=3\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10010, error: 0, timestamp_ps=4671226772094713856, data: {size: 93, data: b00a7bc8_43a8df1e 9b4b300c_386f3a56 ec120782_fc862d84 5f5c8ce4_377891f7 3e222c9c_28df1c8e 5d600612_e3bb22fa b9577d7e_1d20e65d dbf514ed_3b5be2fd 62026d88_1483a582 d58fc555_4860772a 5ae14a97_55dbf619 54e769b8_19}}, driven_packetqueue[port=1].size()=4\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10011, error: 0, timestamp_ps=4671226772094713856, data: {size: 177, data: 769addce_b60ec640 ae389d0b_d7af38d5 f556722e_50e9894d f090fa19_50963224 fa689a24_60b7f28c 86d6df68_a9850455 e7dde760_efe9bddd 58f2c9f9_3dcd605e 9731a485_39f47741 893df4f0_4d7a9efd 13b9bdd3_8770fa68 5a9346bb_e9465d93 1390df7d_f7cd2595 fe6c49f7_a471a570 45ff9b1e_98966a53 d81b1823_1c1abcf9 865a05e2_282674cb 22824d9d_ca7eed6e 0b26e083_deb5daa2 ec6148f3_dfb84bd1 84ac2e6c_d70e09e8 4b0a2348_674b4027 3b}}, driven_packetqueue[port=1].size()=5\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 12, error: 0, timestamp_ps=4671226772094713856, data: {size: 168, data: c0643af4_b57704ca ff88dcee_0e9a784f e483166d_24b56b36 ed112fef_0933189c a239a6fc_51756564 185a19ff_d5efd0b7 cfda1789_1c52fe34 37c2b179_763b651f 7e622a51_e42a1b06 6a261fdc_846abc49 6d3053eb_6f93be00 b61a9945_f8a9de8c 8be688e8_5bc3905f adbfd07f_46f5f3a1 383f7900_921ab66f fe8abb2b_61380745 ff9256b3_1cc5deac b86798a6_2cb35f8f 4a9c11cd_e4e0cbc9 d48d217c_c0833265 f8597a9f_1c8299d0}}, driven_packetqueue[port=0].size()=3\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20013, error: 0, timestamp_ps=4671226772094713856, data: {size: 170, data: 4f0654d3_81ad49f2 1ba3f61f_3f4fc2f0 16c867b4_a5df6c7f 1b53c849_c40f8e46 da13702b_04e48c85 c615f9ef_664f2f7a 19a401ec_6a20bbec c20da0ba_17adcfad 8ae0a818_d858d2b1 9ddf8820_10fa5f41 e0cb2ae4_e4e0954e 239e51fc_efd74b7a 08af3cec_26cc3afc 9e652134_525a329d 6a90bcfc_f1b81798 50c710fc_ce98198e 52241ee1_42707ee8 43b75821_788e86a8 a242304d_d201c399 d899a1cb_b354c3fb 1a799cbe_e491b1e5 2640}}, driven_packetqueue[port=2].size()=5\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20014, error: 0, timestamp_ps=4671226772094713856, data: {size: 164, data: 8252118e_a3fe2adb 1382501e_4fa17966 367dcf0f_f4a658ad af9eac63_a3bfbc9a 347a2bcd_1ead4ce3 616a1840_2e2d2312 e92cc14a_f52db61d 7ae3801b_d4af8186 2298baa0_d3e5a095 f7316f4b_9073d9d6 7fc36d36_91c02a6d 8c4175e1_3df1c554 5e1e543b_28eba30a 4ad28d91_f4296536 90238e01_673cbd0a ed98dcec_2f481980 005c96ef_09cc18e9 9b956827_1639c61e 2a775f17_57287f7e aa21e3b9_5c472385 2d50f60d}}, driven_packetqueue[port=2].size()=6\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20015, error: 0, timestamp_ps=4671226772094713856, data: {size: 134, data: 354fff1c_af606550 bc77a324_8e4e8890 6fb259cc_3f4d186c 93835846_60f40cec bf031d29_7722ffff 41d2f660_bfefea76 25d67b5d_eb895ea4 140b93c5_e8dd14e1 6451068e_46a669b1 35a6224e_974c0ebf c1c44098_c3aa4702 2b792db0_5ef34bdf 57c3d90f_1b21781e bd5cce4f_6359dc52 0126b388_dce72d43 04a971be_1a9142c2 5955e342_4bb6}}, driven_packetqueue[port=2].size()=7\n               20000 TOP.tb.add_rand_packet: port=2, pkt={id: 20016, error: 0, timestamp_ps=4671226772094713856, data: {size: 171, data: c9d7d98a_1cc7baaa 5b904f22_a1cdbe23 efaa25aa_a7c2d218 34148ec8_161fd264 660a3d49_33ad6d73 7ce428af_41b6c6fa ee8291b3_9c5cebfc 29a68d5e_1e6a8646 dd58a0d2_ddfe200f 7892db7a_3e624d49 b9bc192d_91a3257f 5a2899bd_1c6abf13 d77db86c_5dc4385b 5404848a_6c75dedf c49703d7_72b05302 05fe5744_3c09e1ec e2072519_ec6424e7 1d1c41a6_21b5f2cb 730c33a2_b4dd9710 000257d8_4ef9993e c5470ba9_26794855 1ade6c}}, driven_packetqueue[port=2].size()=8\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 17, error: 0, timestamp_ps=4671226772094713856, data: {size: 163, data: 7a2fbc93_7ae1f1c4 523b389f_142f0716 b32bbd81_9b5b3244 177fe500_031bca7f ff14adb1_32f5eb8e d21c1cc0_ee787e03 580613c7_18f4706c c716844e_a3fea752 57abb920_f51c65e5 184fd2cb_b1e62415 1004da76_bb62874f fb4eaa9b_287e3855 d794e5a5_1877cd4b a3a8d387_5b149258 44fc9b9c_b85531e0 2b087968_3149ccc6 9f3b77b6_5bb3caba e2b5e18f_5eb2c4a9 cda00e59_59f845d2 87be6492_f0dfcbfb f6b2e2}}, driven_packetqueue[port=0].size()=4\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10018, error: 0, timestamp_ps=4671226772094713856, data: {size: 107, data: fb6ea7ec_34f1aa5e 4200c0bb_58848e55 32aeaf5b_00deb716 61614cfb_101bc989 67988715_8cbae916 5b860d01_80b689b7 2d934186_ee1b0851 66b8e5fa_298a4a74 d91832b8_855c97c9 1b7f013d_cef00f05 837bca7e_d01fad67 81ac20e5_4ac06d37 55f09ccd_4d7c204c 636d8b}}, driven_packetqueue[port=1].size()=6\n               20000 TOP.tb.add_rand_packet: port=1, pkt={id: 10019, error: 0, timestamp_ps=4671226772094713856, data: {size: 86, data: 277a7c84_f8bc1623 c40953db_ca48b747 decaba69_0c73c6fa 306018f5_3604e787 a5e8f284_087e4ac0 9f2fd098_a98fef0a 86ca1d90_50ea09b0 ea6aedfe_55bdebd2 8295e841_97f33660 24acd18f_d54f191c 5d2f4b16_ebad}}, driven_packetqueue[port=1].size()=7\n               20000 TOP.tb.add_rand_packet: port=0, pkt={id: 20, error: 0, timestamp_ps=4671226772094713856, data: {size: 151, data: 036af29e_dff23933 206bdf2d_e184a041 95ef52f6_ab55ba71 c390de3e_9c6527b4 d1da5c4b_beec5305 3c144a75_6881bd9c 43ca0ad4_97f0b828 8f792bb4_dae3eb0b 0b1e1272_2b806861 d2cff17a_1093222c 9ef1553e_1b1fe196 09940813_958056ae b294a8ea_da433a85 7846bd57_bb5c45bf edca989d_c547eb25 43480199_30e893d0 b91f4894_9248ede4 9a5f2192_5d051954 d7adc634_9dfd2e}}, driven_packetqueue[port=0].size()=5\n            42020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10021, error: 0, timestamp_ps=4720908638787469312, data: {size: 79, data: 68e5afc0_2899ee2b e3f659fd_fe452be7 5ac5eaf9_26a9f0b3 4a6d3908_f27212fc 7e21b0a9_9ad1ea17 a5a18c59_647b2ed7 f38b59f3_44196cb7 4ba6ffa7_5f81db52 d0408315_d4448131 96bebd20_b72616}}, driven_packetqueue[port=1].size()=1\n            42020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10022, error: 0, timestamp_ps=4720908638787469312, data: {size: 71, data: 54f49b15_7e357569 8869b435_22bbc678 b1e7ca45_1248fb52 1c0737da_af3012b5 16a06f95_994730a3 40b83c5e_247e1c44 0254dbd8_9e653255 0969bef4_b3e96c2f 0e2f7ae1_15ef2b}}, driven_packetqueue[port=1].size()=2\n            45020000 TOP.tb.add_rand_packet: port=0, pkt={id: 23, error: 0, timestamp_ps=4721311291971469312, data: {size: 112, data: 804b72d0_046e4cc9 c043403b_3b1cd9b6 bd2041ad_851b5198 cfb76b40_18e4ba93 be1fdf73_02714ba0 afb8d0ff_42f9536d 7b3f3ede_c9090f33 0b900ad8_4078bb12 83f1755d_caf33736 38ca96d7_390b70ad 620ba590_73c88f8d a88b0f49_6471ffd1 16b0d17f_6b836f43 aa3a0c88_d6b8dfe3}}, driven_packetqueue[port=0].size()=1\n            45020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10024, error: 0, timestamp_ps=4721311291971469312, data: {size: 172, data: f6f4e4af_ae2417f2 bde43ff1_02e8afc5 6f15a7ed_b394e9ad a7fc93ed_7d513f1b a9c0dc17_b291dd0d 6f767c35_75345b62 85f71412_14e8975e 2086f8ef_50da0e38 cf699f9d_aa6dda87 3f8fcd64_782a08d8 27f63adb_0f731430 40fc973d_e65c3e06 c1869ad9_86bb4ee5 9eacb893_5352d9b1 aa56a5fd_456909c7 cd3f08b6_d6c44189 b3c34640_dc2e8aa1 d16d623a_83b59032 59d16d74_cbd9c0db 7243d6e9_17db1f43 3ced14c4_1b4bf679 411d4c7d}}, driven_packetqueue[port=1].size()=1\n            50020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20025, error: 0, timestamp_ps=4721982380611469312, data: {size: 98, data: 5f682260_806b245b 02290b38_41f3d64a 83a31207_19c751be 39a07e13_dd4da32f dea1136c_3e015613 71e303d6_e0a4deb8 91ae2a33_c87fea78 d697b3ca_c831f781 013bea7f_5794fc1d ebca04bf_5dc30c10 34991970_fb99a126 9846e3df_59d31fd5 3f44}}, driven_packetqueue[port=2].size()=1\n            50020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10026, error: 0, timestamp_ps=4721982380611469312, data: {size: 191, data: c8bac85b_99482d46 75a03732_516d3b49 b1a339fa_54c90d6e 65740d78_1b08c424 8d1ed001_d7d65634 3dd373e8_002b0d61 a5fc3c01_262ab01c 47319dd1_d23b7da8 d6436c1d_97ea9479 dc22add0_e07fe326 b6c3290f_04b2f049 0c749fd4_918b7dbc 1f01f480_d5a2ba2d 08b1b013_54ffb3b5 427fc07b_8990ef52 94371dbd_fc0ea290 8777bbc0_d9649e96 a3ea937f_f7e0bdac 921df378_def5a86a 75ead333_ae7de5d7 071923e3_abcd35c9 db800a9c_06b2c28b a5104d77_b2d30232 6d787512_1ab9c3}}, driven_packetqueue[port=1].size()=1\n            55020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10027, error: 0, timestamp_ps=4722653469251469312, data: {size: 151, data: 9322361e_45c9159a c06e7dcb_e8f99392 cae993ce_1f08efe6 69a55a9b_ae2fad58 49332e47_0d6cfff4 694de579_7305d4e7 e19fc632_5c0d6d03 6a52e1d4_9563d82a 945cf7f6_3b64edb0 69bbfcd8_01236a6a e42ee23f_9b201ded d52ccdbe_9af09dac a22d3a54_3de8c4ce 4746f587_e8f34a09 c7e3f09d_f30deb72 b2bde1d0_91d7a344 9a9da25e_a61c257f 1e5e90d0_c05d0f5f f407f24a_8d6f5b}}, driven_packetqueue[port=1].size()=1\n            55020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20028, error: 0, timestamp_ps=4722653469251469312, data: {size: 91, data: 1b587bc2_5afc85f9 9beb0c47_8609f268 81f659c0_14e798e5 d6a3db59_dc884e75 a894f96e_03f682e3 7a1c7295_1d89cfba e3a1ad38_0c05c08e 23e2d9d3_79b8d890 9cacd566_35265aed f90a238e_2871e1fa 9bb6a476_c7c3d09a 41a2f8}}, driven_packetqueue[port=2].size()=1\n            59020000 TOP.tb.add_rand_packet: port=0, pkt={id: 29, error: 0, timestamp_ps=4723190340163469312, data: {size: 169, data: 1a6b1bd0_ea823134 0f6852fa_aaef2bc2 0bd7a5a3_f3ac1d10 fc531b78_dd7055fe 152be910_474c7a76 26551a6b_c6425dfe 6aa9ac3c_7f0eaf51 b9bde0fb_0668b815 af64dcc2_e4374900 46727723_145b0dd2 1e9ca57a_6ed658f8 81c7de3c_2f7c2f66 91941ead_343d0ff2 9b3d526a_592f878d 7491933d_b94bf01d da032559_2562ad58 16b54a16_d3355d1e e633b042_2d1fd147 1769759a_4be4a337 f9186c86_0db08dd3 eed4d996_74199250 69}}, driven_packetqueue[port=0].size()=1\n            59020000 TOP.tb.add_rand_packet: port=0, pkt={id: 30, error: 0, timestamp_ps=4723190340163469312, data: {size: 157, data: b45c2d35_cba03590 eed196e2_129c0b53 ea4f152b_9043d557 f8cde632_e711c9f1 6499e7f5_27239d6d a6bf7d94_f07c4060 8a6f5737_f9e2e54b f88e05eb_78783aa7 51bba0ca_498fad31 5d637806_32f6a19d 97707525_c89ba856 e8bfc9f4_0f838d58 91aa7d0d_1e5456e3 9b6fafbd_3d4fa3cf 6dc63efa_51052c17 9a78f1bd_6b0f7e00 d31c1f23_9426de0f 8fcbb283_c2f785a4 4b4157fd_1a03064e 08e9d688_2c}}, driven_packetqueue[port=0].size()=2\n            64020000 TOP.tb.add_rand_packet: port=0, pkt={id: 31, error: 0, timestamp_ps=4723861428803469312, data: {size: 144, data: 20267708_40afc110 d1258d41_11aa645b 735682e8_fb749753 ecbf9fe0_bcc57e7f c4ce0528_13d7eb99 90921b96_46551206 264f1cb2_4595fee5 0cec43fa_01bd684b b05f9638_cb8aa4eb 38588fd3_cebca61f f57d9af3_9f9aa7d4 f395ebfb_4a35d211 210184c9_009bb96d 0a539dfc_8c2091d2 32fbf8c3_e919dfce 62525ca4_4f433519 28f98ec6_d5bbd1a6 ed6d9c96_6571f582}}, driven_packetqueue[port=0].size()=1\n            64020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10032, error: 0, timestamp_ps=4723861428803469312, data: {size: 83, data: e120dfff_e1b45bc7 c174035a_64311d1f 0728b26d_192c6b6a 72174dc2_44a9dff4 fa58d7a9_c86fa0dc 199fe8c6_c86758e1 385cc0cd_db386419 0ec6b29a_9b90b7f7 c4f24f99_958b7937 ac4845a0_d0b66187 8a8095}}, driven_packetqueue[port=1].size()=1\n            68020000 TOP.tb.add_rand_packet: port=0, pkt={id: 33, error: 0, timestamp_ps=4724337154413559808, data: {size: 102, data: c9868489_a610fb04 b26f8595_4d0d6b0d e50134ff_0f7fc2ef 91be4629_45da6be9 df94be77_69d6d5ba ad76d1a6_c4a5b0c9 b38fb783_e10413b5 0dac8fd2_023e4f4a 53e21aed_3effab27 95507f98_e47720aa 0157a94a_e3b47040 334de8e1_cdcdaacf c6740d44_4c3b}}, driven_packetqueue[port=0].size()=1\n            68020000 TOP.tb.add_rand_packet: port=0, pkt={id: 34, error: 0, timestamp_ps=4724337154413559808, data: {size: 195, data: d021d22e_2bc01c87 7bcff4e7_1d65e2a0 2e6b982b_e1e7a8a9 2d4103b0_037f4c90 6f6c4827_dcad2b6e b76b0d03_4a60fb03 89c2a588_98db0398 7ddfc2de_28a8f223 0eb6f587_4521f410 d0811cd8_155bc5bc 5c721a1e_16e7524c 04af7bda_c909fc24 1ea57b5c_0bcdda2a 285d38c4_a8d96332 990aa9dc_c23eab0e 7445828b_ebc3109d 17e7eafa_7948fc51 3635da11_2e1240c0 83429a26_d3ae059d 72b2d955_2dee6c17 9788d7fb_2b2569bc 164a25b1_be036c5e aae95bd0_5264bc34 d4716ec2_18f6fcac 80c87d}}, driven_packetqueue[port=0].size()=2\n            73020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20035, error: 0, timestamp_ps=4724672698733559808, data: {size: 176, data: 3005e909_8829a63d e3a7610c_3f98b2ea bbb73818_92dcb370 417e8ebe_920d23b0 ff743d14_6b3d07c8 d973556e_521f1c50 ef3abcf6_49975640 5bc2a958_cd04a0ec b2a6b3da_a69ee6ea cd30605e_d588ccd8 eecac504_949d268c a31ac55d_114fd323 ff18644c_dab631ab 4aefe2ff_65d5441a 752018b3_16e5c86d c74f9067_95224df9 d638503e_9b86b3eb c9c73c5c_bcd553c2 353a6270_cbac619f 5436870d_de07d978 9e23cf0a_6fd10e9a f8fc8e69_69200b1c}}, driven_packetqueue[port=2].size()=1\n            73020000 TOP.tb.add_rand_packet: port=1, pkt={id: 10036, error: 0, timestamp_ps=4724672698733559808, data: {size: 68, data: f55bdbb4_674cc8ec 8aab18b2_23db1ee2 0019f589_b2564bba f1b7cc63_e270dab4 04804971_213394f1 c9345d0f_f6254af0 ba6aa553_951fa53e 1d1ff967_7ea08af9 496e67fe}}, driven_packetqueue[port=1].size()=1\n            77020000 TOP.tb.add_rand_packet: port=0, pkt={id: 37, error: 0, timestamp_ps=4724941134189559808, data: {size: 168, data: d0c136ca_9f56457d 4cbc2156_047c5a78 860732ee_df86620d 1379dda3_4000e1c9 65e1e077_15a4a8b2 5bf57fd6_69dd8288 7ce46d94_0c225466 276d6a54_612ad533 ce0b7b50_ae21445d 74bcd68d_054d4b23 45bdac65_bd4ba358 d44fd8c7_154face4 016054aa_e68c344d a0153734_4d0e2e32 5633d257_0a04ded0 d966f87f_4c73c37b 91fb2789_b4316e6d caec95ef_a8cab959 bb9dbc8f_c353d60b 3d734e1f_08503da4 46dfb25e_6a595f28}}, driven_packetqueue[port=0].size()=1\n            77020000 TOP.tb.add_rand_packet: port=0, pkt={id: 38, error: 0, timestamp_ps=4724941134189559808, data: {size: 169, data: e72c3894_e80b3af7 a93a8583_6747ce3f 2355e90a_57990859 98c5171c_664fc581 ff6cba26_51580f57 1f390994_a6e8e239 4272fe9e_3badecea 1b10ea05_0fbbf7ca 76e36f36_27e34bd6 baffe062_9f4c757c 4fde3996_398ea046 515befbc_427a2462 2da0672a_6ed52bca 1599aa78_4ff3a3fd 861d1024_59c5f537 a27ff0d9_d4998a50 2476b76c_353ab230 4c25154e_1496b453 e929b0ff_28ffb169 6a2a5a77_595f509d 35bb75d9_47ad4493 f1}}, driven_packetqueue[port=0].size()=2\n            82020000 TOP.tb.add_rand_packet: port=2, pkt={id: 20039, error: 0, timestamp_ps=4725276678509559808, data: {size: 111, data: cdd3efb4_050dd3a3 c6a92fb0_b445da22 9926395e_e62573a4 26c21703_80e7597f 2c11d543_4ae898c3 7fa76adc_7e19b947 7ae2b380_68fc1e3e cf4a72a8_ccf49b4d 0c7e47ca_a91ee613 b0753008_81357205 ded8b308_a1e1c3d4 5c15254b_aea03491 949dae64_21ede9cd 177f9bbf_2f1b55}}, driven_packetqueue[port=2].size()=1\n            82020000 TOP.tb.add_rand_packet: port=0, pkt={id: 40, error: 0, timestamp_ps=4725276678509559808, data: {size: 136, data: 8779ca70_551c129d 3da75d80_9bb1d20d d76dd940_bfd8e2f7 b69bb1f1_1e2e214f 7655a8b7_c31d6b33 4924bd55_1c660776 ef1e77d3_aa30ede9 280f3f48_17540266 4a14a52a_65ad2d66 718cec79_dfa53f1f c8dce10c_deed3d29 33a691e6_d54c8e8a eb8a5c4c_a15ea04f 81ce348a_ee0dcae2 d6c3bf9d_a0fde39a 4d71ccb0_dee8f0f1 61e11127_84812ee4}}, driven_packetqueue[port=0].size()=1\n            86030000 TOP.tb.main: Monitor queues: mon queue size=0\n            86050000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n            86050000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n            86055000 TOP.tb.u_mon: num_packets_received=40\n            86055000 TOP.tb.gen_drv[0].u_drv: num_packets_driven=14\n            86055000 TOP.tb.gen_drv[1].u_drv: num_packets_driven=14\n            86055000 TOP.tb.gen_drv[2].u_drv: num_packets_driven=12\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 86us; walltime 0.134 s; speed 643.764 us/s\n- Verilator: cpu 0.134 s on 1 threads; alloced 505 MB\n",
    "stderr": "",
    "pass": true,
    "score": 100,
    "warnings": 0,
    "errors": 0,
    "runtime": 3.0167737007141113,
    "batch_iter": 1,
    "batch_uuid": "bb732651-91bf-4891-96a6-86cdc024412c",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_bb732651-91bf-4891-96a6-86cdc024412c_1",
    "start_time": 1733527789.8159611,
    "stop_time": 1733527792.8327348
  },
  {
    "index": 17,
    "dut": "module dut #(\n    parameter int Depth = 8,\n    parameter type AxiStreamType = local_pkg::axi4st_8_s,\n    parameter int unsigned AxiStreamWidth = 8,\n    parameter int unsigned ExtraDataWidth = 1,\n    parameter int unsigned AlmostFull = (Depth - 8),\n    parameter int unsigned AlmostEmpty = 0,\n    parameter bit PreferSrl = 0,\n    parameter int unsigned CountWidth = $clog2(Depth + 1)\n)(\n    input logic clock,\n    input logic reset,\n    input AxiStreamType inAxi4St,\n    output logic inTready,\n    output AxiStreamType outAxi4St,\n    input logic outTready,\n    output logic [CountWidth-1:0] inCount,\n    output logic [CountWidth-1:0] outCount,\n    input logic inError,\n    input logic [ExtraDataWidth-1:0] inExtra,\n    output logic outError,\n    output logic [ExtraDataWidth-1:0] outExtra,\n    output logic almostFull,\n    output logic almostEmpty\n);\n\n// Check that Depth is legal (0 or power of 2)\ninitial begin\n    if (Depth != 0) begin\n        assert((Depth & (Depth-1)) == 0) else \n            $error(\"Depth must be 0 or a power of 2\");\n        assert(Depth != 1) else\n            $error(\"Depth of 1 is not supported\");\n    end\nend\n\n// Bypass mode when Depth = 0\nif (Depth == 0) begin : bypass_gen\n    always_comb begin\n        outAxi4St = inAxi4St;\n        inTready = outTready;\n        outError = inError;\n        outExtra = inExtra;\n        inCount = '0;\n        outCount = '0;\n        almostFull = 1'b0;\n        almostEmpty = 1'b1;\n    end\nend\nelse begin : fifo_gen\n    // FIFO storage\n    typedef struct packed {\n        logic [AxiStreamWidth-1:0] tdata;\n        logic tkeep;\n        logic tuser;\n        logic tlast;\n        logic error;\n        logic [ExtraDataWidth-1:0] extra;\n    } fifo_entry_t;\n\n    fifo_entry_t [Depth-1:0] fifo_mem;\n    logic [CountWidth-1:0] write_ptr, read_ptr;\n    logic [CountWidth-1:0] count;\n    logic full, empty;\n    \n    // Input ready logic\n    assign inTready = !full;\n    \n    // Count tracking\n    assign inCount = count;\n    assign outCount = count;\n    \n    // Almost full/empty flags\n    assign almostFull = ($signed(count) >= $signed(AlmostFull));\n    assign almostEmpty = (count <= AlmostEmpty);\n    \n    // Full/empty flags\n    assign full = (count == Depth);\n    assign empty = (count == 0);\n\n    // Write logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            write_ptr <= '0;\n        end\n        else if (inAxi4St.tvalid && inTready) begin\n            fifo_mem[write_ptr] <= '{\n                tdata: inAxi4St.tdata,\n                tkeep: inAxi4St.tkeep,\n                tuser: inAxi4St.tuser,\n                tlast: inAxi4St.tlast,\n                error: inError,\n                extra: inExtra\n            };\n            write_ptr <= (write_ptr + 1'b1) % Depth;\n        end\n    end\n\n    // Output data from FIFO\n    fifo_entry_t read_data;\n    assign read_data = fifo_mem[read_ptr];\n\n    // Read pointer logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            read_ptr <= '0;\n        end\n        else if (!empty && outTready) begin\n            read_ptr <= (read_ptr + 1'b1) % Depth;\n        end\n    end\n\n    // Output assignments\n    always_comb begin\n        outAxi4St.tdata = read_data.tdata;\n        outAxi4St.tkeep = read_data.tkeep;\n        outAxi4St.tuser = read_data.tuser;\n        outAxi4St.tlast = read_data.tlast;\n        outAxi4St.tvalid = !empty;\n        outError = read_data.error;\n        outExtra = read_data.extra;\n    end\n\n    // Count logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            count <= '0;\n        end\n        else begin\n            case ({inAxi4St.tvalid && inTready, outAxi4St.tvalid && outTready})\n                2'b10: count <= count + 1'b1;\n                2'b01: count <= count - 1'b1;\n                default: count <= count;\n            endcase\n        end\n    end\nend\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that acts as a simple ready/valid FIFO for an AXI4 Stream protocol. The FIFO should support a parameterized number of entries (Depth) and a parameterized type for the input and output data (AxiStreamType). If Depth is 0, the FIFO should be bypassed and output data = input data. Depth of 1 is not supported.\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast).\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter int Depth = 8\n        -- Depth of the FIFO. If possible check that this parameter has legal values, where legal values are 0, or a power-of-2.\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int unsigned ExtraDataWidth = 1\n        -- Number of bits for module input inExtra, which is additional data that can be passed along with inAxi4St.tdata and inAxi4St.tuser.\n     -- parameter int unsigned AlmostFull = (Depth - 8)\n        -- Number of entries (less than or equal to Depth), that if this many entries or more are occupied in the FIFO, module output almostFull is set to 1.\n     -- parameter int unsigned AlmostEmpty = 0\n        -- Number of entries: that if fewer than this many entries are occupied in the FIFO, module output almostEmpty is set to 1.\n     -- parameter bit          PreferSrl = 0\n        -- Style of the underlying FIFO. This can be left at value 0 and not used internally, but must exist in the parameter list.\n     --  parameter int unsigned CountWidth     = $clog2(Depth + 1)\n        -- Width in bits for module outputs inCount and outCount.\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n       -- All fields of inAxi4St, except tvalid, must be stored in the FIFO if DEPTH > 0.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: inCount\n       -- output logic [CountWidth - 1 : 0] inCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if inCount==Depth, then inTready should be 0, because the FIFO is full.\n    -- Output: outCount\n       -- output logic [CountWidth - 1 : 0] outCount\n       -- reports the number of valid entries written in the FIFO, for example it is reset to 0,\n          -- incremented if inAxi4St.tvalid=1 and inTready=1\n          -- decremented if outAxi4St.tvalid=1 and outTready=1\n       -- if outCount==0, then outAxi4St.tvalid should be 0, because the FIFO is empty\n    -- Input: inError\n       -- input logic inError = 1'b0\n       -- Valid when inAxi4St.tvalid=1 and inAxi4St.tlast=1. This should be stored in the FIFO alongside tdata.\n    -- Input inExtra\n       -- input logic [ExtraDataWidth - 1 : 0] inExtra = '0\n       -- Valid when inAxi4St.tvalid=1. This should be stored in the FIFO alongside tdata.\n    -- Output: outError\n       -- output logic outError\n       -- Valid when outAxi4St.tvalid=1 and outAxi4St.tlast=1.\n    -- Output: outExtra\n       -- output logic [ExtraDataWidth - 1 : 0] outExtra\n       -- Valid when outAxi4St.tvalid=1.\n    -- Output: almostFull\n       -- output logic almostFull\n       -- is 1 when inCount >= AlmostFull\n    -- Output: almostEmpty\n       -- output logic almostEmpty\n       -- is 1 when outCount <= AlmostEmpty\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_simple_fifo_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_simple_fifo\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_simple_fifo_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_simple_fifo_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_simple_fifo.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   almostFull, almostEmpty;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .Depth(8)\n      )\n  u_dut\n    (.clock, .reset,\n     .almostFull,\n     .almostEmpty,\n     .inCount(),\n     .outCount(),\n     .inAxi4St,\n     .inError(1'b0),\n     .inExtra(1'b0),\n     .inTready,\n     .outAxi4St,\n     .outError(),\n     .outExtra(),\n     .outTready\n     );\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 85; // drain normally\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_axist_simple_fifo_2",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_2747ebcb-743b-48d9-b1ed-f309a09cbbff_0/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_2747ebcb-743b-48d9-b1ed-f309a09cbbff_0/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.269 MB sources in 17 modules, into 0.199 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 1.329 s (elab=0.005, cvt=0.016, bld=1.265); cpu 0.643 s on 64 threads; alloced 150.910 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n           410030000 TOP.tb.main: Monitor queues: mon queue size=0, drv queue size=0\n           410050000 TOP.oclib_assert_pkg.finish: Test finished with error_count=0\n           410050000 TOP.oclib_assert_pkg.finish: TEST PASS\n- tb.sv:69: Verilog $finish\n           410055000 TOP.tb.u_drv: num_packets_driven=100\n           410055000 TOP.tb.u_mon: num_packets_received=100\n- S i m u l a t i o n   R e p o r t: Verilator 5.028 2024-08-21\n- Verilator: $finish at 410us; walltime 0.330 s; speed 1.241 ms/s\n- Verilator: cpu 0.330 s on 1 threads; alloced 505 MB\n",
    "stderr": "",
    "pass": true,
    "score": 100,
    "warnings": 0,
    "errors": 0,
    "runtime": 1.7272276878356934,
    "batch_iter": 0,
    "batch_uuid": "2747ebcb-743b-48d9-b1ed-f309a09cbbff",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_2747ebcb-743b-48d9-b1ed-f309a09cbbff_0",
    "start_time": 1733528194.0261314,
    "stop_time": 1733528195.753359
  },
  {
    "index": 19,
    "dut": "module dut \n  #(\n  parameter type AxiStreamType = local_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8\n  )\n  (\n  input logic                  clock,\n  input logic                  reset,\n  \n  input  AxiStreamType        inAxi4St,\n  output logic                inTready,\n  \n  output AxiStreamType        outAxi4St,\n  input  logic                outTready,\n  \n  output logic                outParsedValid,\n  output logic [47:0]         outParsedDestMac,\n  output logic [47:0]         outParsedSourceMac\n  );\n  \n  // Number of stages needed for alignment\n  localparam int unsigned NumStages = (48 + AxiStreamWidth - 1) / AxiStreamWidth;\n  \n  // Counter for input bytes\n  logic [$clog2(12):0] inByteCount;\n  logic inStarted;\n  \n  // Shift registers for MAC addresses\n  logic [47:0] destMac, sourceMac;\n  \n  // Pipeline signals\n  AxiStreamType [NumStages:0] pipeAxi4St;\n  logic [NumStages:0] pipeTready;\n  \n  // Counter logic\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      inByteCount <= '0;\n      inStarted <= 1'b0;\n      destMac <= '0;\n      sourceMac <= '0;\n    end else begin\n      if (inAxi4St.tvalid && inTready) begin\n        if (inAxi4St.tlast) begin\n          inByteCount <= '0;\n          inStarted <= 1'b0;\n        end else if (!inStarted) begin\n          inStarted <= 1'b1;\n          inByteCount <= 'd1;\n        end else begin\n          inByteCount <= inByteCount + 1'd1;\n        end\n        \n        // Parse destination MAC (bytes 0-5)\n        if (inByteCount < 6) begin\n          destMac <= {destMac[39:0], inAxi4St.tdata};\n        end\n        \n        // Parse source MAC (bytes 6-11)\n        if ((inByteCount >= 6) && (inByteCount < 12)) begin\n          sourceMac <= {sourceMac[39:0], inAxi4St.tdata};\n        end\n      end\n    end\n  end\n  \n  // Valid signal for parsed data\n  always_comb begin\n    outParsedValid = outAxi4St.tvalid && (inByteCount >= 12);\n    outParsedDestMac = destMac;\n    outParsedSourceMac = sourceMac;\n  end\n  \n  // Instantiate pipeline\n  local_axist_pipe #(\n    .NumStages(NumStages),\n    .AxiStreamType(AxiStreamType)\n  ) u_pipe (\n    .clock(clock),\n    .reset(reset),\n    .inAxi4St(inAxi4St),\n    .inTready(inTready),\n    .pipeAxi4St(pipeAxi4St),\n    .pipeTready(pipeTready),\n    .outAxi4St(outAxi4St),\n    .outTready(outTready)\n  );\n  \nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module that can extract (or parse) the 6 Byte Destination MAC and 6 Byte Source MAC fields from a standard Ethernet header on an AXI4 Stream protocol. An input AXI4 Stream protocol is provided, and this module must also output an un-altered (but perhaps delayed) AXI4 Stream protocol. The two extracted fields for Destination MAC and Source MAC should be output on the first data phit on the output AXI4 Stream. For example, if the AXI Stream tdata width is 8-bits (1 Byte) then 12 Bytes must be parsed from the input AXI4 Stream, and the output AXI4 Stream must be delayed by at least 11 cycles so the extracted fields are aligned and valid on the first data phit of the output AXI4 Stream.\n\nA helper module (local_axist_pipe) to delay the output AXI4 Stream is provided for you (with the contents of the module not shown). You are required to use an instance of this module to assist in delaying the output AXI4 Stream, so the extracted fields are aligned to the first data phit of a packet.\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n-- Note that Ethernet header fields are Big Endian,\n  -- the first byte in the frame is Destination MAC bits [47:40].\n  -- the 6th byte in the frame is Destination MAC bits [7:0].\n  -- the 7th byte in the frame is Source MAC bits [47:40].\n  -- the 12th byte in the frame is Source MAC bits [7:0].\n-- In the AXI Stream protocol, a packet (or frame) is valid from the first data phit (following reset=1 or a previous tvalid=1=tlast) until the last data phit (tvalid=1=tlast). When transmitting a frame, this module cannot re-arbitrate until the last data phit (tvalid=1=tlast) is transferred on the input.\n-- The module has inputs clock and reset, where reset is a synchronous reset.\n-- The module name should be: dut\n-- Module parameters:\n     -- parameter type AxiStreamType = local_pkg::axi4st_8_s\n        -- AxiStreamType is a packed struct, with the default value having 8-bit tdata as follows:\n           typedef struct packed {\n             logic [7:0] tdata;\n             logic       tkeep;\n             logic       tuser;\n             logic       tlast;\n             logic       tvalid;\n            } axi4st_8_s;\n     -- parameter int unsigned AxiStreamWidth = 8\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType inAxi4St\n       -- The AXI4 Stream input, struct type.\n          The type is based on a module parameter named AxiStreamType.\n    -- Ouput: inTready\n       -- output logic inTready\n       -- advances the input inAxi4St when inAxi4St.tvalid=1.\n    -- Output: outAxi4St\n       -- output AxiStreamType outAxi4St\n       -- The AXI4 Stream output.\n    -- Input: outTready\n       -- input logic outTready\n       -- single input from the downstream transmitter advancing the transfer on outAxi4St.\n    -- Output: outParsedDestMac, outParsedSourceMac, outParsedValid\n       -- output logic        outParsedValid\n       -- output logic [47:0] outParsedDestMac\n       -- output logic [47:0] outParsedSourceMac\n       -- Valid on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- outParsedValid should be a 1 on the first output data phit on outAxi4St.tvalid=1 for this frame.\n       -- Note that these values may take 0 cycles of latency from inAxi4St to outAxi4St (if tdata is 128-bits) or up to 11 data phits (if tdata is 8-bits) to extract from input stream inAxi4St.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_parser_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser_test.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n  oclib_axist_eth_parser\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_parser_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_3_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_3_test_sim/local_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default local_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule local_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = local_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_oclib_axist_eth_parser_3_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// tb.sv\n// sanity test for:\n//   ocsim_axist_driver.sv ---> (DUT: oclib_axist_eth_parser.sv) --> ocsim_axist_monitor.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n\n  wire seen_rst = uCONTROL.seen_rst;\n\n  localparam int          NumStages = 3;\n  AxiStreamType [NumStages : 0] pipeAxi4St; // NumStages+1 indicies, [0] is the hot unflopped inAxi4St.\n\n  AxiStreamType           inAxi4St;\n  logic                   inTready;\n  AxiStreamType           outAxi4St;\n  logic                   outTready;\n\n  logic                   outParsedValid;\n  logic [47:0]            outParsedDestMac;   // valid at outAxi4St.valid=1 first phit.\n  logic [47:0]            outParsedSourceMac;\n\n  ocsim_axist_driver\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_drv\n    (.clock,\n     .reset,\n     .outAxi4St(inAxi4St), // --> to DUT\n     .outError(),\n     .outTready(inTready)\n     );\n\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\ndut\n    #(\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n  logic                 out_tfirst;\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_out\n    (.clock, .reset, .inAxi4St(outAxi4St), .inTready(outTready),\n     .tfirst(out_tfirst),\n     .in_packet()\n     );\n\n  // outParsedValid=1 should only happen on first data phit.\n  `OC_SYNC_ASSERT(clock, reset, outParsedValid == (outAxi4St.tvalid && out_tfirst))\n\n  ocsim_axist_monitor\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .DriveOutTready(1)\n      )\n  u_mon\n    (.clock,\n     .reset,\n     .inAxi4St(outAxi4St),\n     .inError(),\n     .inTready(outTready), // <-- from our driven outTready\n     .outTready(outTready)\n     );\n\n  import ocsim_packet_pkg::packet_t;\n\n  logic [47:0]          mon_dmac_queue[$];\n  logic [47:0]          mon_smac_queue[$];\n\n  // capture the parsed values\n  always @(posedge clock) begin\n    if (!reset && outParsedValid && outTready) begin\n      // We only want 1 transaction here, so do when outTready=1\n      mon_dmac_queue.push_back(outParsedDestMac);\n      mon_smac_queue.push_back(outParsedSourceMac);\n    end\n  end\n\n\n\n  always @(negedge clock) begin\n    if (!reset &&\n        u_mon.mon_packet_queue.size() > 0 &&\n        u_drv.mon_packet_queue.size() > 0) begin\n      // get the head packets and compare them.\n      check_driver_vs_monitor();\n    end\n  end\n\n  function automatic void check_driver_vs_monitor();\n    packet_t drv, mon;\n    drv = u_drv.mon_packet_queue.pop_front();\n    mon = u_mon.mon_packet_queue.pop_front();\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: mon=%s drv=%s\", $realtime, ocsim_packet_pkg::packet_as_string(mon), ocsim_packet_pkg::packet_as_string(drv));\n    end\n\n    ocsim_packet_pkg::compare_packets(.got(mon), .want(drv));\n\n    // Check parsed values\n    if (mon_dmac_queue.size() == 0 ||\n        mon_smac_queue.size() == 0) begin\n      `OC_ASSERT_STR(0, $sformatf(\"Don't have mon_dmac_queue.size() > 0, check outParsedValid=1 for this packet\"));\n    end else begin\n      automatic logic [47:0] exp_dmac, exp_smac, mon_dmac, mon_smac;\n      mon_dmac = mon_dmac_queue.pop_front();\n      mon_smac = mon_smac_queue.pop_front();\n      if (drv.data.size() < 12)\n        return;\n\n      // Apparently Verilator, Modelsim, and Vivado all have different interpretations of the streaming operator\n      // and/or queue slices. We'll do this more brute-force\n      for (int unsigned i = 0; i < 6; i++) begin\n        exp_dmac = { exp_dmac, 8'(drv.data[i]) };\n        exp_smac = { exp_smac, 8'(drv.data[6 + i]) };\n      end\n      `OC_ASSERT_EQUAL(exp_dmac, mon_dmac);\n      `OC_ASSERT_EQUAL(exp_smac, mon_smac);\n    end\n\n\n  endfunction : check_driver_vs_monitor\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n    u_drv.m_self_monitor_packet_queue_en = 1; // have driver queue its sent packets.\n\n    while (seen_rst === 0) @(posedge clock);\n\n    repeat(100) begin\n      void'(u_drv.add_rand_packet(.max_size(200)));\n    end\n    while (u_drv.num_packets_driven < 20) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 20) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 97; // drain faster than data arriving\n    while (u_drv.num_packets_driven < 40) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 40) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 50; // drain slowly\n    while (u_drv.num_packets_driven < 60) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 60) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 10; // drain very slowly\n    while (u_drv.num_packets_driven < 80) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 80) repeat(100) @(posedge clock);\n\n    u_mon.m_out_tready1_pct              = 100; // drain fastest\n    while (u_drv.num_packets_driven < 100) repeat(100) @(posedge clock);\n    while (u_mon.num_packets_received < 100) repeat(100) @(posedge clock);\n\n    stim_done = 1;\n    @(posedge clock);\n\n    // final checks\n    if (ocsim_pkg::info_verbosity_low()) begin\n        $display(\"%t %m: Monitor queues: mon queue size=%0d, drv queue size=%0d\", $realtime,\n                 u_mon.mon_packet_queue.size(),\n                 u_drv.mon_packet_queue.size());\n    end\n\n    u_mon.eot_checks();\n    u_drv.eot_checks();\n    `OC_ASSERT_EQUAL(mon_dmac_queue.size(), 0);\n    `OC_ASSERT_EQUAL(mon_smac_queue.size(), 0);\n\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : tb\n",
    "name": "test_eth_parser_3",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_bb732651-91bf-4891-96a6-86cdc024412c_3/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\n/usr/bin/python3 /tools/verilator/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vtb.cpp Vtb___024root__DepSet_hfe20aad3__0.cpp Vtb___024root__DepSet_ha183790c__0.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp Vtb__main.cpp Vtb___024root__Slow.cpp Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp Vtb___024root__DepSet_ha183790c__0__Slow.cpp Vtb_oclib_assert_pkg__Slow.cpp Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp Vtb_ocsim_pkg__Slow.cpp Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp Vtb_ocsim_packet_pkg__Slow.cpp Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp Vtb__Syms.cpp > Vtb__ALL.cpp\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o Vtb__ALL.o Vtb__ALL.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_bb732651-91bf-4891-96a6-86cdc024412c_3/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.319 MB sources in 21 modules, into 0.258 MB in 16 C++ files needing 0.001 MB\n- Verilator: Walltime 1.735 s (elab=0.006, cvt=0.020, bld=1.312); cpu 2.364 s on 64 threads; alloced 151.906 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.uCONTROL.main: TEST START\n[180000] %Error: tb.sv:4164: Assertion failed in TOP.tb:               180000 TOP.tb: (outParsedValid == (outAxi4St.tvalid && out_tfirst)) NOT TRUE at tb.sv:4164\n%Error: tb.sv:4164: Verilog $stop\nAborting...\n",
    "stderr": "",
    "pass": false,
    "score": 80,
    "warnings": 0,
    "errors": 0,
    "runtime": 1.9480366706848145,
    "batch_iter": 3,
    "batch_uuid": "bb732651-91bf-4891-96a6-86cdc024412c",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_bb732651-91bf-4891-96a6-86cdc024412c_3",
    "start_time": 1733527789.8580945,
    "stop_time": 1733527791.8061311
  },
  {
    "index": 18,
    "dut": "module dut #(\n    parameter int NumPorts = 4,\n    parameter type AxiStreamType = local_pkg::axi4st_128_s,\n    parameter int unsigned AxiStreamWidth = 128,  \n    parameter int MacTableDepth = 16,\n    parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n)(\n    input  logic clock,\n    input  logic reset,\n    input  AxiStreamType [NumPorts-1:0] inAxi4St,\n    output logic [NumPorts-1:0] inTready,\n    output AxiStreamType [NumPorts-1:0] outAxi4St,\n    input  logic [NumPorts-1:0] outTready,\n    output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n);\n\n    // MAC Table entry structure\n    typedef struct packed {\n        logic valid;\n        logic [47:0] mac_addr;\n        logic [1:0] port_num;  // For 4 ports\n        logic [31:0] age_count;\n    } mac_entry_t;\n\n    // MAC Table storage\n    mac_entry_t [MacTableDepth-1:0] mac_table;\n\n    // Internal signals\n    logic [47:0] rx_src_mac, rx_dst_mac;\n    logic [1:0] rx_port;\n    logic frame_valid;\n    logic is_broadcast, is_multicast;\n    logic [NumPorts-1:0] output_mask;\n\n    // MAC Table lookup/update logic\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            for (int i = 0; i < MacTableDepth; i++) begin\n                mac_table[i].valid <= 1'b0;\n                mac_table[i].mac_addr <= '0;  \n                mac_table[i].port_num <= '0;\n                mac_table[i].age_count <= '0;\n            end\n        end else begin\n            // Age counter and invalidation\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid) begin\n                    if (mac_table[i].age_count >= MacTableCyclesPerEpoch) begin\n                        mac_table[i].valid <= 1'b0;\n                    end else begin\n                        mac_table[i].age_count <= mac_table[i].age_count + 1;\n                    end\n                end\n            end\n\n            // Source MAC learning\n            if (frame_valid) begin\n                logic found = 0;\n                for (int i = 0; i < MacTableDepth; i++) begin\n                    if (mac_table[i].valid && (mac_table[i].mac_addr == rx_src_mac)) begin\n                        mac_table[i].port_num <= rx_port;\n                        mac_table[i].age_count <= '0;\n                        found = 1;\n                        break;\n                    end\n                end\n                \n                if (!found) begin\n                    for (int i = 0; i < MacTableDepth; i++) begin\n                        if (!mac_table[i].valid) begin\n                            mac_table[i].valid <= 1'b1;\n                            mac_table[i].mac_addr <= rx_src_mac;\n                            mac_table[i].port_num <= rx_port;\n                            mac_table[i].age_count <= '0;\n                            break;\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    // Frame processing logic\n    always_comb begin\n        // Extract MAC addresses from frame\n        rx_src_mac = inAxi4St[rx_port].tdata[47:0];\n        rx_dst_mac = inAxi4St[rx_port].tdata[95:48];\n        \n        // Determine broadcast/multicast\n        is_broadcast = &rx_dst_mac;\n        is_multicast = rx_dst_mac[40];  // Check multicast bit\n        \n        // Default mask excludes rx port (no loopback)\n        output_mask = '1;\n        output_mask[rx_port] = 1'b0;\n\n        // Unicast forwarding\n        if (!is_broadcast && !is_multicast) begin\n            logic found = 0;\n            for (int i = 0; i < MacTableDepth; i++) begin\n                if (mac_table[i].valid && (mac_table[i].mac_addr == rx_dst_mac)) begin\n                    output_mask = '0;\n                    output_mask[mac_table[i].port_num] = 1'b1;\n                    found = 1;\n                    break;\n                end\n            end\n        end\n    end\n\n    // Output assignments\n    always_comb begin\n        for (int i = 0; i < NumPorts; i++) begin\n            outAxi4St[i] = inAxi4St[rx_port];\n            outAxi4St[i].tvalid = inAxi4St[rx_port].tvalid && output_mask[i];\n        end\n        inTready = '1;  // Always ready to receive\n        egressFifoDropEvents = '0;  // No drop events tracked\n    end\n\nendmodule",
    "conversation": "None\n\n     Here is the module description:\n    =========\n    Problem description:\n    ======\n    Create a SystemVerilog module for a four port Layer-2 Ethernet Switch. This is an unmanaged switch with no VLAN support. It will have to manage its own 16 entry MAC address table based on observed Source MAC addresses on Rx frames (add to MAC address table). Transmit port will be determined by the Rx Destination MAC Address with the following rules:\n -- Loopback is forbidden, the transmit port(s) can never include the receive port.\n -- If the Destination MAC is found in the MAC address table, then route the frame to the port in the MAC address table;\n -- If the Destination MAC Address is not in the table, it must route the frame to all transmit ports except the Rx port that this frame arrived on (loopback is forbidden).\n -- Similarly, if the Rx Destination MAC is broadcast or multicast, it must route the frame to all transmit ports except the Rx port that this frame arrived on.\nThe module has inputs clock and reset, where reset is a synchronous reset.\n\n-- The module name should be: dut\nThe module should have four AXI4 Stream inputs is named inAxi4St, and four AXI4 Stream outputs named outAxi4St. These are struct types. The type is based on a module parameter named AxiStreamType, where the default type is local_pkg::axi4st_8_s.\nThe module can assume the following: it can drive output inTready with '1, and input outTready will be tied to '1 ('1 is a vector all all 1's for all ports in NumPorts).\n\nIt can be assumed that minimum Ethernet frame size is 60 Bytes, and the maximum size is 1504 Bytes.\n-- Module parameters:\n     -- parameter int NumPorts = 4\n        -- The Number of Ports for inAxi4St and outAxi4St.\n     -- parameter type AxiStreamType = local_pkg::axi4st_128_s\n        -- AxiStreamType is a packed struct, with the default value having 128-bit tdata as follows:\n           typedef struct packed {\n             logic [127:0] tdata;\n             logic [15:0]  tkeep;\n             logic         tuser;\n             logic         tlast;\n             logic         tvalid;\n            } axi4st_128_s;\n     -- parameter int unsigned AxiStreamWidth = 128\n        -- should match the number of bits in AxiStreamType.tdata. The module body should use AxiStreamWidth instead of $bits(AxiStreamType).\n     -- parameter int MacTableDepth = 16\n        -- Number of entries for an internal MAC table.\n     -- parameter int MacTableCyclesPerEpoch = 32'd1_750_000_000\n        -- If an entry in an internal MAC table has been valid for this many cycles without observing a Destination MAC address hitting this entry,\n           then the table entry should be invalidated (so it can be used again by a different MAC address).\n\n-- Other module inputs and outputs:\n    -- Inputs: inAxi4St\n       -- input AxiStreamType [NumPorts - 1 : 0] inAxi4St\n       -- The AXI4 Stream input, packet array of struct type.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Ouput: inTready\n       -- output logic [NumPorts - 1 : 0] inTready\n    -- Output: outAxi4St\n       -- output AxiStreamType [NumPorts - 1 : 0] outAxi4St\n       -- The AXI4 Stream output.\n          The type is based on a module parameter named AxiStreamType.\n          There are NumPorts of these.\n    -- Input: outTready\n       -- input logic [NumPorts - 1 : 0] outTready\n       -- single input, per port, from the downstream transmitters advancing the transfer on outAxi4St[tx_port].\n    -- Ouput: egressFifoDropEvents\n       -- output logic [NumPorts-1:0][NumPorts-1:0] egressFifoDropEvents\n       -- For now, this design can drive an ouput of '0 on this signal.\n\n    ======\n    Answer the questions regarding the description\n    \n    =========\n    \n    Your generated code should work standlone without any import of libraries, and should include reference to any instanstiation. Only include the code and no extra information. Make sure to check parametres and pins for all modues and their instantiation. Here are some general guidelines:\n   ==========\n   COMPREHENSIVE SYSTEMVERILOG CODING GUIDELINES\n\n1. MODULE NAMING & PORTS\n- If module name is not specified, call it \"dut\"\n- If clock port name not specified, use \"clock\" \n- If polarity not specified, signals should be active high\n- For multiple clock domains, append domain to clock/reset names (e.g., clockRead, clockWrite, resetRead, resetWrite)\n- Provide minimum required functionality - do not add extra features or ports\n- Only include clock/reset when sequential circuit (internal state feedback) is required\n\n2. DATA TYPES\nDO use SystemVerilog types: logic, bit, byte, int, longint, shortint, and enum\nExample:\nlogic [7:0] data_bus;\n\nDON'T use Verilog data types like reg and wire\nAvoid:\nreg [7:0] data_bus;  // BAD: uses Verilog reg type\n\n3. ARRAYS & INDICES\nDO properly declare and initialize arrays with valid indices:\nmodule dut;\n    logic [31:0] inAxi4St [0:7]; // Declare array with bounds  \n    integer i;\n    \n    initial begin\n        for (i = 0; i < 8; i++) begin\n            inAxi4St[i] = i * 10; // Valid index within bounds\n        end\n    end\nendmodule\n\n4. ALWAYS BLOCKS AND SIGNAL ASSIGNMENTS\n\na) Use appropriate always blocks:\n// Sequential logic\nalways_ff @(posedge clock) begin\n    q <= d;\nend\n\n// Combinational logic \nalways_comb begin\n    sum = a + b;\nend\n\nb) Ready/Valid Handshake Pattern:\nlogic value_d, value_q;\n\nalways_comb begin\n    value_d = value_q; // default for value_d is current value_q\n    if (some_condition) begin\n        value_d = 1'b0;\n    end else if (some_other_condition) begin\n        value_d = 1'b1;\n    end\nend\n\nalways_ff @(posedge clock) begin\n    if (reset) value_q <= '0; // reset value\n    else value_q <= value_d; // update value_q\nend\n\n5. VARIABLE DECLARATIONS & SCOPE\nDO declare automatic variables in begin/end blocks with default values:\nalways_comb begin\n    automatic logic [7:0] value = 2; // GOOD: automatic with default\n    if (some_condition) begin\n        automatic logic some_condition_hit = 1'b1; // GOOD\n    end\nend\n\nDON'T declare in for-loops:\nalways_comb begin\n    for (int i = 0; i < 8; i++) begin\n        int idx = i + value; // BAD: declaration without automatic\n        automatic int good_idx = i + value; // BAD: even with automatic\n    end\nend\n\n6. ASSIGNMENT RULES\n\na) Avoid multiple assignments:\nsome_struct_type_t this_is_a_struct;\n\nassign this_is_a_struct = '0;\nassign this_is_a_struct.tvalid = 1'b1; // BAD: multiple assignment\n\n// GOOD Fix using intermediate signals:\nlogic inst_tvalid;\nthis_is_a_struct inst_data;\n\nmy_module u_instance_of_my_module (\n    .clock(clock),\n    .reset(reset),\n    .output_valid(inst_tvalid),\n    .output_data(inst_data)\n);\n\nalways_comb begin\n    this_is_a_struct = inst_data;\n    this_is_a_struct.tvalid = inst_tvalid; // OK: structured override\nend\n\nb) Avoid mixing blocking/non-blocking:\nlogic foo;\nalways_ff @(posedge clock) begin\n    if (reset) begin\n        foo <= '0;\n    end else begin\n        foo = 1'b1; // BAD: mixing <= and = \n    end\nend\n\n7. ALWAYS_COMB BLOCK ORGANIZATION\nDO split always_comb blocks to avoid re-entering:\n\n// BAD: Single large block with dependencies\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\n    inTready = !fifo_full; // BAD: used before assignment\nend\n\n// GOOD: Split into multiple focused blocks\nalways_comb begin\n    fifo_in.axi4st = inAxi4St;\n    fifo_in.error = inError;\nend\n\nalways_comb begin\n    inTready = !fifo_full;\nend\n\nalways_comb begin\n    fifo_push = inAxi4St.tvalid && inTready;\n    fifo_pop = outAxi4St.tvalid && outTready;\nend\n\n8. PROHIBITED CONSTRUCTS\n- No combinational loops:\nlogic a, b, c;\nassign b = a;\nalways_comb begin\n    a = b || c; // BAD: forms combinational loop\nend\n\n- No let statements\n- No classes\n- No implicit net declarations\n- No out-of-bounds array access\n\n9. BYTE/BIT CONVENTIONS\n- 1 Byte = 8 bits\n- For bus_width parameters, specify in bits:\nparameter int N = 32; // N is bits in bus_width\nlogic [N-1:0] bus_width;\nlocalparam int B = (N + 7) / 8; // B is bytes in bus_width\n\n10. CASE STATEMENTS\nAlways include default:\nalways_comb begin\n    case (state)\n        2'b00: next_state = 2'b01;\n        2'b01: next_state = 2'b10;\n        default: next_state = 2'b00; // Required default\n    endcase\nend\n   ==========\n   The code should be inside a module called `dut`:\n    \n    module dut (...);\n       ...\n    endmodule\n    \n    The output must be a YAML object equivalent to type $ProblemSolutions, according to the following Pydantic definitions in $ProblemSolutions:\n    ======\n    class Solution(BaseModel):\n        verilog: str = Field(description=\"generated code\")\n\n\n    class $ProblemSolutions(BaseModel):\n        solution: List[Solution] = Field(max_items=1, description=\"A list of possible solution to the problem. Make sure each solution fully addresses the problem rules and goals.Just Provide the code and no extra information.\")\n    ======\n\n\n    Example YAML output:\n    ```yaml\n    solution:\n    - verilog: |\n        ...\n     ```\n\n    Answer:\n    ```yaml    ",
    "tb": "// (Start -- create_tests_jsonl.py -- header to fix some things)\n    `ifndef SIMULATION\n    `define SIMULATION\n    `endif\n    // (End -- create_tests_jsonl.py -- header finished)\n    \n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_assert_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// *****************************************************************************************\n//\n// oclib_assert_pkg.sv\n// Global error reporting helper package, called by various defines from oclib_defines.vh\n//\n// Non-synthesizable code is guarded with (define `SIMULATION)\n//\n// *****************************************************************************************\n\npackage oclib_assert_pkg;\n\n`ifdef SIMULATION\n\n  // error_count: Count of errors that have been globally reported via report_error():\n  int error_count = 0;\n\n  // error_limit: The max value of error_count before we would call internal function finish():\n  int error_limit = 1;\n\n  // set_error_limit(int) -- helper method to set the global error_limit\n  function automatic void set_error_limit(input int value);\n    error_limit = value;\n  endfunction : set_error_limit\n\n  // report_error()\n  // Returns None, may call finish()\n  // This is often invoked by oclib_defines.vh macros in addition to calling $error.\n  // For example:\n  //    assert (expr) else begin\n  //      $error(\"%t %m: some expr failed!\", $realtime);\n  //      oclib_assert_pkg::report_error();\n  //    end\n  //\n  // This has the advantage of being able to automatically fail (and $finish) a test if a global\n  // error limit is reached.\n  function automatic void report_error();\n    error_count++;\n    if (error_limit > 0 && error_count >= error_limit) begin\n      $display(\"%t %m: error_limit=%0d reached, error_count=%0d\", $realtime, error_limit, error_count);\n      $fflush();\n      finish();\n    end\n  endfunction : report_error\n\n  // finish()\n  // calls $finish and reports an overall \"TEST PASS\" or \"TEST FAIL\" message, along with the total\n  // global error_count value.\n  function automatic void finish();\n    $display(\"%t %m: Test finished with error_count=%0d\", $realtime, error_count);\n    $fflush();\n    if (error_count > 0) begin\n        $display(\"%t %m: TEST FAIL\", $realtime);\n    end else begin\n        $display(\"%t %m: TEST PASS\", $realtime);\n    end\n    $fflush();\n    $finish;\n  endfunction : finish\n\n`else\n\n  // non-SIMULATION synthesizable variants, in case these are used in design RTL.\n  function automatic void set_error_limit(input int value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n  endfunction : finish\n\n`endif // SIMULATION\n\n\nendpackage : oclib_assert_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"lib/oclib_defines.vh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n`ifndef __OCLIB_DEFINES_VH\n`define __OCLIB_DEFINES_VH\n\n// Depending on the EDA tool, not all simulators or test frameworks define\n// SIMULATION (verilator and cocotb do, Modelsim does not).\n// Synthesis tools are supposed to define SYNTHESIS, but not all do, some\n// still rely on translate-comment-guards. Translate guards are stronger than\n// the if-def preprocessing.\n\n// synopsys translate_off\n// synthesis translate_off\n`ifndef SYNTHESIS\n  `ifndef SIMULATION\n  // define SIMULATION in case the outside framework did not:\n  `define SIMULATION\n  `endif\n`endif\n// synthesis translate_on\n// synopsys translate_on\n\n\n// #Verilator things, simulation only and behavioral\n`ifdef VERILATOR\n  `ifndef OC_LIBRARY_BEHAVIORAL\n  `define OC_LIBRARY_BEHAVIORAL\n  `endif\n`endif\n// For ModelsimASE, we also run in behavioral\n`ifdef SIMULATION\n  `ifdef OC_TOOL_MODELSIM_ASE\n    `ifndef OC_LIBRARY_BEHAVIORAL\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n// For Vivado, we'd prefer to run in OC_LIBRARY_XILINX if we're not in OC_LIBRARY_BEHAVIORAL\n`ifdef SIMULATION\n  `ifndef OC_LIBRARY_BEHAVIORAL\n    `ifndef OC_LIBRARY_XILINX\n    `define OC_LIBRARY_BEHAVIORAL\n    `endif\n  `endif\n`endif\n\n// *****************************************************************************************\n// ******** UTILITY\n// *****************************************************************************************\n\n// convert a token into a string, useful for building macros that quote their arguments\n  `define OC_STRINGIFY(x) `\"x`\"\n\n// concat two tokens, useful for building module/signal/struct names\n  `define OC_CONCAT(a,b) a``b\n  `define OC_CONCAT3(a,b,c) a``b``c\n  `define OC_CONCAT4(a,b,c,d) a``b``c``d\n\n// *****************************************************************************************\n// ******** SELF DOCUMENTATION\n// *****************************************************************************************\n\n  `define OC_ANNOUNCE_MODULE(m)         $display(\"%t %m: ANNOUNCE module %-20s\",         $realtime, `OC_STRINGIFY(m));\n  `define OC_ANNOUNCE_PARAM_INTEGER(p)  $display(\"%t %m: ANNOUNCE param %-20s = %0d\",    $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_BIT(p)      $display(\"%t %m: ANNOUNCE param %-20s = %x\",     $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REAL(p)     $display(\"%t %m: ANNOUNCE param %-20s = %.3f\",   $realtime, `OC_STRINGIFY(p), p);\n  `define OC_ANNOUNCE_PARAM_REALTIME(p) $display(\"%t %m: ANNOUNCE param %-20s = %.3fns\", $realtime, `OC_STRINGIFY(p), p/1ns);\n  `define OC_ANNOUNCE_PARAM_MISC(p)     $display(\"%t %m: ANNOUNCE param %-20s = %p\",     $realtime, `OC_STRINGIFY(p), p);\n\n// *****************************************************************************************\n// ******** ASSERTIONS\n// *****************************************************************************************\n// These are guarded with ifndef, in case a project wishes to redefine them before\n// oclib_defines.vh is included.\n\n// an assertion that is executed statically (i.e. outside always, initial, etc) and\n// operates for simulation AND synthesis.  Good for checking params.\n\n// Note - we do not typically $finish or $fatal on error, but instead\n// check the oclib_assert_pkg::error_limit and error_count. The defaults\n// are 1 error and $finish, they can be adjusted using simulation plusarg: +oc_error_limit=1\n`ifndef _oc_report_error\n`define _oc_report_error(str) \\\n  `ifdef SIMULATION           \\\n  do begin $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n           oclib_assert_pkg::report_error(); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`define OC_STATIC_ASSERT(a) \\\n  `ifdef SIMULATION         \\\n  initial if (!(a)) begin   \\\n    $error(\"%t %m: (%s) NOT TRUE at %s:%0d\", $realtime, `\"a`\", `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: (%s) NOT TRUE\", `\"a`\"); \\\n  `endif // last line of macro\n\n`define OC_STATIC_ASSERT_STR(a,str)   \\\n  `ifdef SIMULATION                   \\\n  initial if (!(a)) begin             \\\n    $error(\"%t %m: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n    oclib_assert_pkg::report_error(); \\\n    $finish; \\\n  end        \\\n  `else      \\\n  if (!(a)) $fatal(1, \"%m: %s\", str); \\\n  `endif // last line of macro\n\n// an assertion that is executed within an initial, always, task, function, or final block\n// and operates for simulation ONLY\n\n\n// OC_ASSERT(expr)\n`ifndef OC_ASSERT\n`define OC_ASSERT(a)                                      \\\n  `ifdef SIMULATION                                       \\\n  do begin                                                \\\n    assert ((a) === 1) else begin                         \\\n      `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n    end                                                   \\\n  end while (0)                                           \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_STR\n`define OC_ASSERT_STR(a, str)                      \\\n  `ifdef SIMULATION                                \\\n  do begin                                         \\\n    assert ((a) === 1) else begin                  \\\n      `_oc_report_error(str);                      \\\n    end                                            \\\n  end while (0)                                    \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_EQUAL(exprA, exprB)\n`ifndef OC_ASSERT_EQUAL\n`define OC_ASSERT_EQUAL(a, b)                                   \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) === (b))) else begin                           \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT EQ (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LT(exprA, exprB)\n`ifndef OC_ASSERT_LT\n`define OC_ASSERT_LT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) < (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_LTE(exprA, exprB)\n`ifndef OC_ASSERT_LTE\n`define OC_ASSERT_LTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) <= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT LTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GT(exprA, exprB)\n`ifndef OC_ASSERT_GT\n`define OC_ASSERT_GT(a, b)                                      \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) > (b))) else begin                             \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GT (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// OC_ASSERT_GTE(exprA, exprB)\n`ifndef OC_ASSERT_GTE\n`define OC_ASSERT_GTE(a, b)                                     \\\n  `ifdef SIMULATION                                             \\\n  do begin                                                      \\\n    assert (((a) >= (b))) else begin                            \\\n      `_oc_report_error($sformatf(\"(%s) (%x) NOT GTE (%s) (%x)\", \\\n                                  `\"a`\", a, `\"b`\", b));         \\\n    end                                                         \\\n  end while (0)                                                 \\\n  `endif // last line of macro\n`endif\n\n// an assertion that partially implements an error register (without clock / reset, i.e. within !reset part of always_ff block)\n\n`ifndef OC_ASSERT_REG\n  `define OC_ASSERT_REG(a, ereg) \\\n  if (!(a)) ereg <= 1'b1;        \\\n  `ifdef SIMULATION              \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); end while (0) \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_ASSERT_REG_STR\n  `define OC_ASSERT_REG_STR(a, ereg, str) \\\n  if (!(a)) ereg <= 1'b1;                 \\\n  `ifdef SIMULATION                       \\\n  do if ((a) !== 1) begin `_oc_report_error($sformatf(str)); end while (0) \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and operates for simulation ONLY\n// OC_SYNC_* asserts use assert property, so that SVA is supported (A |-> B, A |=> B, etc)\n// If your simulator does not support this, please avoid these macros, or define\n// OC_ASSERT_PROPERTY_NOT_SUPPORTED.\n`ifndef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// it's definitely not support if we're not in SIMULATION\n`define OC_ASSERT_PROPERTY_NOT_SUPPORTED\n`endif\n`endif\n\n`ifdef SIMULATION\n`ifndef OC_ASSERT_PROPERTY_NOT_SUPPORTED\n// we're in simulation, OC_ASSERT_PROPERTY_NOT_SUPPORTED is not defined\n// therefore we support assert properties.\n`ifndef OC_ASSERT_PROPERTY_SUPPORTED\n`define OC_ASSERT_PROPERTY_SUPPORTED\n`endif\n`endif\n`endif\n\n\n`ifndef OC_SYNC_ASSERT\n  `define OC_SYNC_ASSERT(clock, reset, a) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED     \\\n  assert property (@(posedge (clock))   \\\n    disable iff ((reset) !== 1'b0) (a)) else begin  \\\n    `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n  end                                   \\\n  `endif // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_STR\n  `define OC_SYNC_ASSERT_STR(clock, reset, a, str) \\\n  `ifdef OC_ASSERT_PROPERTY_SUPPORTED              \\\n  assert property (@(posedge (clock))            \\\n    disable iff ((reset) !== 1'b0) (a)) else begin \\\n    `_oc_report_error(str);                      \\\n  end                                            \\\n  `endif // last line of macro\n`endif\n\n// an assertion that brings it's own clock and reset and fully implements an error register\n\n`ifndef OC_SYNC_ASSERT_REG\n  `define OC_SYNC_ASSERT_REG(clock,reset,a,ereg) \\\n  always_ff @(posedge clock) \\\n    if (reset) ereg <= 1'b0  \\\n    else begin               \\\n      if (!(a)) begin        \\\n        ereg <= 1'b1;        \\\n        `_oc_report_error($sformatf(\"(%s) NOT TRUE\", `\"a`\")); \\\n      end                    \\\n    end                      \\\n  end // last line of macro\n`endif\n\n`ifndef OC_SYNC_ASSERT_REG_STR\n  `define OC_SYNC_ASSERT_REG_STR(clock,reset,a,ereg,str) \\\n  always_ff @(posedge clock)    \\\n    if (reset) ereg <= 1'b0     \\\n    else begin                  \\\n      if (!(a)) begin           \\\n        ereg <= 1'b1;           \\\n        `_oc_report_error(str); \\\n      end                       \\\n    end                         \\\n  end    // last line of macro\n`endif\n\n// *****************************************************************************************\n// ******** WARNING / ERROR\n// *****************************************************************************************\n// These tasks handle:\n// - printing file and line number\n// - safe in any environment (no wrapping `ifdef SIMULATION etc)\n// - try to do the logival thing in all environment (printing all errors at time 0 before\n//     stopping simulation, printing a formatted error message in synth, etc)\n\n// ERROR / WARNING - operate within begin/end with other procedural code.\n//                 - print immediately to remain near other code that maybe printing.\n//                 - removed for elab/synth (ifdef'd out) since they run at a certain \"time\"\n//                 - ERROR is a convenience wrapper so the logfile will definitely say \"ERROR: \"\n\n`ifndef OC_ERROR\n  `define OC_ERROR(str) \\\n  `_oc_report_error($sformatf(\"ERROR: %s\", str));\n`endif\n\n`ifndef OC_WARNING\n  `define OC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  do begin $display(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); end while (0) \\\n  `endif\n`endif\n\n// STATIC_ERROR / STATIC_WARNING - operate outside begin/end blocks, i.e. \"instantiated\"\n//                               - good for dropping in an \"else\" clause of a generate that can't handle the inputs\n//                                 (this is for \"you shouldn't get here\", use OC_STATIC_ASSERT for \"is this condition true?\")\n//                               - work in all environments: sim, elab, synth\n//                               - errors, in sim, wait 0 time so all errors can be printed, then finish sim\n//                               - warnings, in sim, print at beginning and end of sim\n//                               - in elab/synth, both print as code is elaborated\n\n  `define OC_STATIC_ERROR(str) \\\n  `ifdef SIMULATION \\\n  initial $fatal(1, \"%t %m: ERROR: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $fatal(1, \"%m: ERROR: %s\", str); \\\n  `endif\n\n  `define OC_STATIC_WARNING(str) \\\n  `ifdef SIMULATION \\\n  initial $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  final   $warning(\"%t %m: WARNING: %s at %s:%0d\", $realtime, str, `__FILE__, `__LINE__); \\\n  `else \\\n  $warning(\"%m: WARNING: %s\", str); \\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP SETTING DEFINES\n// *****************************************************************************************\n\n  // ideal naming for these defines is that each word after OC_ corresponds to an argument,\n  // appearing in order.\n\n  `define OC_IFDEFUNDEF(d) \\\n  `ifdef d\\\n    `undef d\\\n  `endif\n\n  `define OC_IFDEFDEFINE_TO(d,v) \\\n  `ifdef d\\\n    `undef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEFDEFINE_TO(d,v) \\\n  `ifndef d\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE(i,d) \\\n  `ifdef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE(i,d) \\\n  `ifndef i\\\n    `define d\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO(i,d,v) \\\n  `ifdef i \\\n    `define d v\\\n  `endif\n\n  `define OC_IFNDEF_DEFINE_TO(i,d,v) \\\n  `ifndef i\\\n    `define d v\\\n  `endif\n\n  `define OC_IFDEF_DEFINE_TO_ELSE(i,d,a,b) \\\n  `ifdef i\\\n    `define d a\\\n  `else\\\n    `define d b\\\n  `endif\n\n// *****************************************************************************************\n// ******** LOGIC WHEN SETTING DEFINES\n// *****************************************************************************************\n\n  `define OC_IFDEF_ANDIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifdef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifdef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFNDEF_ANDIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n  `ifndef b\\\n    `define o\\\n  `endif\\\n  `endif\n\n  `define OC_IFNDEF_ORIFNDEF_DEFINE(a,b,o) \\\n  `ifndef a\\\n    `define o\\\n  `endif\\\n  `ifndef b\\\n    `define o\\\n  `endif\n\n  `define OC_IFDEF_ANDIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n  `ifdef b\\\n    `undef o\\\n  `endif\\\n  `endif\n\n  `define OC_IFDEF_ORIFDEF_UNDEF(a,b,o) \\\n  `ifdef a\\\n    `undef o\\\n  `endif\\\n  `ifdef b\\\n    `undef o\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM DEFINES\n// *****************************************************************************************\n\n  `define OC_VAL_ASDEFINED_ELSE(d,e) \\\n  `ifdef d\\\n    `d\\\n  `else\\\n    e\\\n  `endif\n\n  `define OC_VAL_IFDEF_THEN_ELSE(d,t,e) \\\n  `ifdef d\\\n     t\\\n  `else\\\n     e\\\n  `endif\n\n  `define OC_VAL_IFDEF(d) \\\n  `ifdef d\\\n     1'b1\\\n  `else\\\n     1'b0\\\n  `endif\n\n// idea here is to return \"true\" (i.e. 1) if \"d\" is defined as nothing, or defined as 1. Basically\n// if user does say +define+AXIM_MEM_TEST_ENABLE=0 then we don't want that to ENABLE something with that\n  `define OC_VAL_ISTRUE(d) \\\n  `ifdef d\\\n  ((1```d == 1) || (1```d == 11)) \\\n  `else\\\n     1'b0\\\n  `endif\n\n// *****************************************************************************************\n// ******** HELP GETTING VALUES FROM TYPES\n// *****************************************************************************************\n\n// we use a macro to assist with this.  The right way is comparing via type() but at least\n// Vivado prior to 2022.2 would not handle this correctly in synth when overridden, so we\n// fall back to comparing $bits, but it's not robust (watch out comparing things with\n// same amounts of bits!!!)\n`ifdef OC_TOOL_BROKEN_TYPE_COMPARISON\n  `define OC_TYPES_EQUAL(t1,t2) ($bits(t1)==$bits(t2))\n  `define OC_TYPES_NOTEQUAL(t1,t2) ($bits(t1)!=$bits(t2))\n`else\n  `define OC_TYPES_EQUAL(t1,t2) (type(t1)==type(t2))\n//  `define OC_TYPES_EQUAL(t1,t2) (t1==t2)\n  `define OC_TYPES_NOTEQUAL(t1,t2) (type(t1)!=type(t2))\n`endif\n\n// *****************************************************************************************\n// ******** CODE ASSISTANCE\n// *****************************************************************************************\n\n  `define OC_LOCALPARAM_SAFE(m) localparam integer m``Safe = (m ? m : 1)\n\n  `define OC_IFDEF_INCLUDE(d, i) \\\n  `ifdef d\\\n     i\\\n  `endif\n\n  `define OC_SYNC_CIO(c,i,o) \\\nlogic [$bits(i)-1:0] o; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i``_``o ( .clock(c), .in(i), .out(o) );\n\n  `define OC_SYNC_CI(c,i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``c``_``i ( .clock(c), .in(i), .out(i``_sync) );\n\n  `define OC_SYNC_I(i) \\\nlogic [$bits(i)-1:0] i``_sync; \\\noclib_synchronizer #(.Width($bits(i))) uSYNC_``i``_clock ( .clock(clock), .in(i), .out(i``_sync) );\n\n// *****************************************************************************************\n// ******** VENDOR RELATED\n// *****************************************************************************************\n\n// We really don't want to put too much in here, it's messy, but in some cases a library\n// just doesn't work.  The first example is VIO (Xilinx debug IP) which has special hooks\n// in the flow that grab signal names from the connected ports.  If we wrap this in an\n// \"oclib_debug_vio\" wrapper (like we'd do for a RAM or synchronizer) then we'll just see\n// the names of the nets inside \"oclib_debug_vio\" on our nice debug GUI.  So we could just\n// embed Xilinx-specific code everywhere, or put it here in one place.\n\n// That being said this should be moved into a \"vendor defines\" file.\n\n  `define OC_DEBUG_VIO(inst, clock, i_width, o_width, i_signals, o_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `undef OC_DEBUG_VIO_DONE_``inst \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [o_width-1 : $bits({ o_signals }) ] inst``_dummy_o; \\\n       xip_vio_i``i_width``_o``o_width`` inst (\\\n          .clk( clock ),\\\n          .probe_in0 ( { inst``_dummy_i , i_signals } ),\\\n          .probe_out0( { inst``_dummy_o , o_signals } ) );\\\n      `define OC_DEBUG_VIO_DONE_``inst \\\n    `endif \\\n  `endif \\\n  `ifndef OC_DEBUG_VIO_DONE_``inst \\\n       assign o_signals = '0; \\\n  `endif\n\n  `define OC_DEBUG_ILA(inst, clock, depth, i_width, t_width, i_signals, t_signals) \\\n  `ifdef OC_LIBRARY_ULTRASCALE_PLUS \\\n    `ifndef OC_LIBRARY_XILINX \\\n      `define OC_LIBRARY_XILINX \\\n    `endif \\\n  `endif \\\n  `ifdef OC_LIBRARY_XILINX \\\n    `ifndef SIMULATION \\\n       logic [i_width-1 : $bits({ i_signals }) ] inst``_dummy_i = '0; \\\n       logic [t_width-1 : $bits({ t_signals }) ] inst``_dummy_t = '0; \\\n       xip_ila_d``depth``_i``i_width``_t``t_width inst (\\\n          .clk( clock ),\\\n          .probe0( { inst``_dummy_i , i_signals } ),\\\n          .probe1( { inst``_dummy_t , t_signals } ) );\\\n    `endif \\\n  `endif\n\n`endif //  `ifndef __OCLIB_DEFINES_VH\n\n\n//(End from `include \"lib/oclib_defines.vh\")\n\n\npackage oclib_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage : oclib_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_memory_bist_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage oclib_memory_bist_pkg;\n\n  localparam MaxAxim = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_AXIM, 32);\n  localparam MaxAddressWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 34);\n  localparam MaxDataWidth = `OC_VAL_ASDEFINED_ELSE(OCLIB_MEMORY_BIST_MAX_DATA_WIDTH, 256);\n  localparam AximCountWidth = $clog2(MaxAxim);\n\n  typedef struct packed {\n    logic                                go;\n    logic [7:0]                          sts_port_select;\n    logic [7:0]                          sts_csr_select;\n    logic [5:0]                          address_port_shift;\n    logic [7:0]                          write_mode;\n    logic [7:0]                          read_mode;\n    logic [31:0]                         op_count;\n    logic [7:0]                          wait_states;\n    logic [3:0]                          burst_length;\n    logic [MaxAxim-1:0]                  axim_enable;\n    logic [7:0]                          read_max_id;\n    logic [7:0]                          write_max_id;\n    logic [MaxAddressWidth-1:0]          address;\n    logic [MaxAddressWidth-1:0]          address_inc;\n    logic [MaxAddressWidth-1:0]          address_inc_mask;\n    logic [MaxAddressWidth-1:0]          address_random_mask;\n    logic [AximCountWidth-1:0]           address_port_mask;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } cfg_s;\n\n  typedef struct packed {\n    logic                                done;\n    logic [31:0]                         signature;\n    logic [31:0]                         error;\n    logic [31:0]                         rdata;\n    logic [(MaxDataWidth/8)-1:0] [7:0]   data;\n  } sts_s;\n\nendpackage // oclib_memory_bist_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_uart_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\npackage oclib_uart_pkg;\n\n  localparam ErrorWidth = 3;\n  localparam ErrorInvalidStart = 0;\n  localparam ErrorInvalidStop = 1;\n  localparam ErrorOverflow = 2;\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_pkg.sv\n// SystemVerilog package with functions and other non-synthesizable (define `SIMULATION)\n// code.\n\npackage ocsim_pkg;\n\n  localparam DataTypeZero = 0;\n  localparam DataTypeOne = 1;\n  localparam DataTypeRandom = 2;\n\n  function automatic string CharToString (input [7:0] data);\n    if ((^data) === 1'bX) return \"<XX>\";\n    if ((^data) === 1'bZ) return \"<ZZ>\";\n    if (data == 'h00) return \"<00 NULL>\";\n    if (data == 'h0d) return \"<0d CR \\\\r>\";\n    if (data == 'h0a) return \"<0a LF \\\\n>\";\n    if (data == 'h1b) return \"<1b ESC>\";\n    if ((data >= \" \") && (data <= \"~\")) return $sformatf(\"%c\", data);\n    return \"<?>\";\n  endfunction : CharToString\n\n  function automatic int RandInt (int minimum, int maximum);\n    // for Signed numbers, otherwise use for unsigned:\n    //     $urandom_range(maximum, minimum)\n    //     $urandom_range(maximum) // if minimum=0\n    return minimum + ($urandom % (maximum - minimum + 1));\n  endfunction : RandInt\n\n  function automatic bit RandPercent (real percent);\n    // for a \"real\" percent, otherwise use:\n    //     $urandom_range(99) < percent\n    // we make sure 0.0 always returns false and 100.0 always returns true\n    return (percent > (real'(RandInt(1, 100_000_000 - 1)) / 1_000_000.0));\n  endfunction : RandPercent\n\n\n  // Because most simulators don't support std::randomize or Class.randomize()\n  // we need a better way to get $urandom data on vectors > 32 bits.\n  // Usage:\n  //   some_type_t my_t; // your signal\n  //\n  //   tb_pkg::TypeURand #($bits(some_type_t)) some_type_t_urand = new();\n  //   initial begin\n  //     my_t = $urandom; // bad\n  //     my_t = some_type_t_urand.get(); // good\n  //   end\n  class TypeURand #(int bits = 64);\n    function automatic bit[bits - 1 : 0] get();\n      bit [bits + 31 - 1 : 0] value; // overbitsd value\n      for (int unsigned words = 0; words < (bits + 31) / 32; words++) begin\n        value[words * 32 +: 32] = $urandom;\n      end\n      return bits'(value);\n    endfunction : get\n    //\n  endclass : TypeURand\n\n\n  //\n  // Global verbosity, so every module doesn't need its own custom way\n  // of handling a parameter or method for if (Debug) $display(\"foo\").\n  //\n  // An example of how to use this in your design code, or simulation / testbench code:\n  // `ifdef SIMULATION // if we are in design code\n  //\n  // initial begin\n  //   // In some non-concurrent code block\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: some_value=%0d\", $realtime, some_value);\n  // end\n  //\n  // `endif // if we are in design code\n  //\n  bit        info_verbosity_init = 0;\n  int        info_verbosity = get_info_verbosity(); // set initial verbosity to default or from plusarg.\n\n  // Verbosity.* values follows uvm_info verbosity\n  // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n  int        VerbosityNone   = 0; // means always print this, it's not affected by thresholding.\n  int        VerbosityAlways = 0;\n  int        VerbosityLow    = 100;\n  int        VerbosityMedium = 200;\n  int        VerbosityHigh   = 300;\n  int        VerbosityFull   = 400;\n  int        VerbosityDebug  = 500;\n\n\n  // get_info_verbosity()\n  // Returns: int (verbosity, between 0 and 500)\n  // Called at initial time.\n  function automatic int get_info_verbosity();\n    // Follows uvm_info verbosity\n    // (0 = print minimal, 100=low, 200=medium, 300=high, 400=full 500=debug)\n    int      value;\n    value = 0;\n\n    if (info_verbosity_init) begin\n      return info_verbosity; // do this once b/c string parsing.\n    end else if ($value$plusargs(\"verbosity=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"debug=%d\", value)) begin\n      ;\n    end else if ($value$plusargs(\"info=%d\", value)) begin\n      ;\n    end else if ($test$plusargs(\"trace\")) begin\n      value = 200; // medium, and nothing else set\n    end\n    info_verbosity_init = 1;\n    return value;\n  endfunction : get_info_verbosity\n\n  // info_verbosity_{threshold}()\n  // Returns 1 if we should display or not some informational message\n  //\n  // Example in a simulation module:\n  //   if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: Hello World we're at Debug level\", $realtime);\n  function automatic bit info_verbosity_none();\n    return (get_info_verbosity() >= VerbosityNone);\n  endfunction : info_verbosity_none\n\n  function automatic bit info_verbosity_always();\n    return (get_info_verbosity() >= VerbosityAlways);\n  endfunction : info_verbosity_always\n\n  function automatic bit info_verbosity_low();\n    return (get_info_verbosity() >= VerbosityLow);\n  endfunction : info_verbosity_low\n\n  function automatic bit info_verbosity_medium();\n    return (get_info_verbosity() >= VerbosityMedium);\n  endfunction : info_verbosity_medium\n\n  function automatic bit info_verbosity_high();\n    return (get_info_verbosity() >= VerbosityHigh);\n  endfunction : info_verbosity_high\n\n  function automatic bit info_verbosity_full();\n    return (get_info_verbosity() >= VerbosityFull);\n  endfunction : info_verbosity_full\n\n  function automatic bit info_verbosity_debug();\n    return (get_info_verbosity() >= VerbosityDebug);\n  endfunction : info_verbosity_debug\n\n\n  //\n  // Handle waves for +trace for Verilator in a global package, so this code isn't\n  // repeated in every testbench.\n  //\n  bit        trace_en_init = 0;\n  bit        trace_en      = init_trace_plusarg();\n\n  function automatic bit init_trace_plusarg();\n    if (trace_en_init) // only do this once.\n      return trace_en;\n\n    trace_en_init = 1;\n    if ($test$plusargs(\"trace\") != 0) begin\n`ifdef VERILATOR\n      $display(\"%t %m: Starting tracing to ./dump.fst\", $realtime);\n      $dumpfile(\"dump.fst\");\n      $dumpvars();\n`endif\n      return 1;\n    end\n    return 0;\n  endfunction : init_trace_plusarg\n\n  //\n  // plusarg for +oc_error_limit=value\n  //\n  bit        error_limit_init = init_error_limit_plusarg();\n\n  function automatic bit init_error_limit_plusarg();\n    int      value;\n    if ($value$plusargs(\"oc_error_limit=%d\", value)) begin\n      set_error_limit(value);\n    end\n    return 1;\n  endfunction : init_error_limit_plusarg\n\n\n  //\n  // Make oclib_assert_pkg methods callable from this package as well, for convenience\n  // (since this isn't a class)\n  //\n  function automatic void set_error_limit(input int value);\n    oclib_assert_pkg::set_error_limit(value);\n  endfunction : set_error_limit\n\n  function automatic void report_error();\n    oclib_assert_pkg::report_error();\n  endfunction : report_error\n\n  function automatic void finish();\n    oclib_assert_pkg::finish();\n  endfunction : finish\n\nendpackage : ocsim_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_packet_pkg.sv' \n\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage ocsim_packet_pkg;\n\n  typedef logic [7:0] bytequeue_t [$];\n\n  typedef struct {\n    bytequeue_t  data;\n    bit [31:0]   id;\n    bit          error;\n    bit [63:0]   timestamp_ps;\n  } packet_t;\n\n  typedef packet_t packetqueue_t [$];\n\n\n  // empty_packet(args) -\n  // returns a packet_t, default is an empty packet with '0 flags.\n  function automatic packet_t empty_packet();\n    packet_t ret;\n    ret.id = 0;\n    ret.error = 0;\n    ret.timestamp_ps = 0;\n    return ret;\n  endfunction : empty_packet\n\n  // new_packet(args) -\n  // returns a packet_t, with a global id and current timestamp\n  int global_packet_id = 0;\n  function automatic packet_t new_packet(input bytequeue_t data={},\n                                         input int        id=0,\n                                         input bit        error=0,\n                                         input bit [63:0] timestamp_ps='0,\n                                         input bit        use_global_packet_id=0);\n    packet_t ret;\n    ret.data = data;\n    ret.id = id;\n    ret.error = error;\n    ret.timestamp_ps = timestamp_ps;\n\n    if (use_global_packet_id && id <= 0)\n      ret.id = ++global_packet_id;\n    if (timestamp_ps == 0 || &timestamp_ps)\n      ret.timestamp_ps = get_timestamp_ps_now();\n\n    return ret;\n  endfunction : new_packet\n\n\n  function automatic bit [63:0] get_timestamp_ps_now();\n    bit [63:0] ret;\n    realtime   now;\n    now = $realtime * 1ps;\n    ret =$realtobits(now);\n    return ret;\n  endfunction : get_timestamp_ps_now\n\n\n  // bytequeue_as_string(bytequeue_t)\n  // returns a Big Endian formatted string of the input bytequeue_t\n  function automatic string bytequeue_as_string(input bytequeue_t bq = {});\n\n    // We'd like to hex print these things so it's not a list of 8-bit ints.\n    string       ret;\n    ret = $sformatf(\"{size: %0d, data: \", bq.size());\n\n    for (int i = 0; i < bq.size(); i++) begin\n      ret = { ret,\n              $sformatf(\"%02x\", bq[i]) };\n\n      // trailing char, either none, _, or space:\n      if (i != bq.size() - 1)\n        if (i % 8 == 7)\n          ret = { ret, \" \" };\n        else if (i % 8 == 3)\n          ret = { ret, \"_\" };\n\n    end\n    ret = { ret, \"}\" };\n    return ret;\n  endfunction : bytequeue_as_string\n\n\n  // packet_as_string(packet_t)\n  // returns a Big Endian formatted string of the input packet_t\n  function automatic string packet_as_string(input packet_t pkt=empty_packet());\n    return $sformatf(\"{id: %0d, error: %0d, timestamp_ps=%0d, data: %s}\",\n                     pkt.id, pkt.error, pkt.timestamp_ps, bytequeue_as_string(pkt.data));\n  endfunction : packet_as_string\n\n\n  // bytequeue_pprint(bytequeue_t)\n  function automatic void bytequeue_pprint(input bytequeue_t bq={});\n    $display(\"%t %m: %s\", $realtime, bytequeue_as_string(bq));\n  endfunction : bytequeue_pprint\n\n\n  // packet_pprint(packet_t)\n  function automatic void packet_pprint(input packet_t pkt=empty_packet());\n    $display(\"%t %m: %s\", $realtime, packet_as_string(pkt));\n  endfunction : packet_pprint\n\n\n  // get_rand_bytequeue(args)\n  function automatic bytequeue_t get_rand_bytequeue(input int max_size = 1500,\n                                                    input int min_size = 64);\n    bytequeue_t ret;\n    int         how_many_bytes;\n\n    ret = {};\n    how_many_bytes = $urandom_range(max_size, min_size);\n    repeat(how_many_bytes)\n      ret.push_back($urandom_range(8'hFF));\n\n    return ret;\n  endfunction : get_rand_bytequeue\n\n\n  function automatic void compare_packets(input packet_t got,\n                                          input packet_t want,\n                                          input bit      ignore_size=0,\n                                          input bit      ignore_id=0,\n                                          input bit      ignore_error=0,\n                                          input string   str=\"\");\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: %s got=%s want=%s\", $realtime, str, packet_as_string(got), packet_as_string(want));\n    end\n\n    // ignore_size=1 not implemented yet\n    `OC_ASSERT_EQUAL(got.data.size(), want.data.size());\n\n    `OC_ASSERT_STR(got.data === want.data,\n                   $sformatf(\"packet_t.data miscompare: %s got=%s want=%s\",\n                             str, packet_as_string(got), packet_as_string(want)));\n    if (!ignore_id)\n      `OC_ASSERT_EQUAL(got.id, want.id);\n    if (!ignore_error)\n      `OC_ASSERT_EQUAL(got.error, want.error);\n    // we always ignore the timestamp_ps\n\n  endfunction : compare_packets\n\n\n\n\n\nendpackage : ocsim_packet_pkg\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_tb_control.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_tb_control.sv\n// simple module for SystemVerilog unit test control.\n//\n// Outputs:\n//   -- clock, using parameter ClockPeriod (realtime)\n//   -- reset, driven randomly after time 0 based on parameter ResetCycles\n// Inputs:\n//   -- stimulusDone - vector, default 1 bit, flag from testbench indicating all drivers are finished.\n//   -- checkerDone  - vector, default 1 bit, flag from testbench indicating all monitors and\n//                     checking is finished.\n// Internals that can be monitored:\n//   -- seen_rst - testbench can monitor this by path to confirm that reset has been observed one or more\n//                 times.\n\nmodule ocsim_tb_control #(\n  parameter int      ResetCycles = 10,\n  parameter int      MaxCycles = 1_000_000,\n  parameter realtime ClockPeriod = 10ns,\n  parameter int      StimulusCount = 1,\n  parameter int      CheckerCount = 1\n                    )\n  (\n  output logic                    clock,\n  output logic                    reset,\n  input logic [StimulusCount-1:0] stimulusDone,\n  input logic [CheckerCount-1:0]  checkerDone\n   );\n\n  // verilator coverage_off\n\n  initial forever begin : clocks\n    clock = 1;\n    // Note that in event simulators this becomes `timescale dependent, for\n    // example if ClockPeriod is 1ns and timescale is 1ns, this does not\n    // work as expected. For now, using 10ns is acceptable.\n    #(ClockPeriod / 2);\n    clock = 0;\n    #(ClockPeriod - (ClockPeriod / 2));\n  end\n\n  // without adding a module port, let tb.sv's grab this signal by\n  // path.\n  bit seen_rst; // defaults to 0\n  always @(posedge clock) begin\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  realtime max_time = MaxCycles * ClockPeriod;\n  initial begin : main\n    $display(\"%t %m: TEST START\", $realtime);\n\n    // we are going to change inputs to DUT exactly 1ns after posedge (the first being at time 0)\n    #1ns;\n    reset = 1;\n    for (int iter = 0; iter < ResetCycles; iter++) begin\n      @(posedge clock);\n      #1ns;\n    end\n    reset = 0;\n\n    fork\n      begin : wait_max_cycles\n        #(max_time);\n      end\n      begin : wait_all_done\n        wait ((&stimulusDone) && (&checkerDone));\n        @(posedge clock);\n      end\n    join_any\n\n\n    if (!(&stimulusDone)) begin\n      $error(\"stimulusDone=(%b) after %0d cycles\", stimulusDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    if (!(&checkerDone)) begin\n      $error(\"checkerDone=(%b) after %0d cycles\", checkerDone, MaxCycles);\n      ocsim_pkg::report_error();\n    end\n\n    ocsim_pkg::finish();\n  end\n\n  // verilator coverage_on\n\nendmodule : ocsim_tb_control\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_driver.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_driver.sv\n// An AXI4 Stream Driver, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Egress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Egress path includes an optionl output: outError, since this is not included in\n//      common AXI4 Stream signals.\n//\n// How to use this module in a testbench:\n//\n//   ocsim_axist_driver #( /* ... */) u_driver ( /* ... */);\n//\n//   initial begin : start_sending_rand_packets_after_1000_cycles\n//     repeat(1000) @(posedge clock);\n//     // call to our u_driver (instance of ocsim_axist_driver.sv) to add 1 random packet.\n//     // This will be driven out its outputs outAxi4St based on flow control input outTready.\n//     u_driver.add_rand_packet();\n//   end\n//\n\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_driver\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits, total flattened bit width of outAxi4St.tdata\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  output AxiStreamType outAxi4St,\n  output logic         outError,\n  input  logic         outTready\n   );\n\n  // General module level global member variables (named m_.*)\n  bit                  m_driver_enable = 1;\n  bit                  m_self_monitor_packet_queue_en = 0;\n\n  bit                  m_driver_uses_global_pkt_id = 1; // 1 = let ocsim_packet_pkg track a global packet id, 0 = track it ourselves.\n  int                  m_driver_last_pkt_id = 0;\n  int                  m_out_tvalid_pct  = 80; // How often tvalid=1 following a outAxi4St.tvalid=1 && outTready=1\n\n  // stats\n  bit [31:0]           num_packets_driven = 0;\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(outAxi4St.tdata))\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n  logic [31:0]         axist__pkt_id;\n\n\n  // TODO -- add a .pcap file to the driver\n\n  // 1. Convert a packet_t to data phits (our own struct)\n  // 2. Use ready/valid semantics to drive phits on bus\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::new_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t drv_packet_queue;\n  packetqueue_t mon_packet_queue; // monitor what we drove, if m_self_monitor_packet_queue_en=1\n\n\n  localparam int unsigned AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  typedef struct packed {\n    bit [31:0]                      id; // for debug\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t drv_phit_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n\n  // Convert drv_packet_queue items to drv_phit_queue:\n  // #Verilator friendly, do this on negedge clk instead of initial-forever-wait loop\n  always @(negedge clock) begin\n    if (!reset && m_driver_enable &&\n        drv_phit_queue.size() == 0 && drv_packet_queue.size() > 0) begin\n      packet_to_phits();\n    end\n  end\n\n\n  function automatic void packet_to_phits();\n    packet_t pkt;\n    phit_t   phit;\n    int how_many_phits;\n\n    pkt = drv_packet_queue.pop_front();\n\n    if (m_self_monitor_packet_queue_en)\n      mon_packet_queue.push_back(pkt);\n\n    if (ocsim_pkg::info_verbosity_high()) $display(\"%t %m: packet=%s\", $realtime, packet_as_string(pkt));\n\n    how_many_phits = (pkt.data.size() + AxiStreamBytes - 1) / AxiStreamBytes;\n\n    for (int unsigned i = 0; i < how_many_phits; i++) begin\n      phit = '0;\n      phit.id = pkt.id;\n      phit.first = (i == 0);\n\n      for (int unsigned j = 0; j < AxiStreamBytes; j++) begin\n        // AXI Stream is Little endian, fill bytes as they are indexed in the bytequeue\n        // on phit from Right [0] to Left [AxiStreamWidth - 1]\n        phit.data[8 * j +: 8] = pkt.data.pop_front();\n        phit.keep[j]          = 1;\n        if (pkt.data.size() == 0) begin\n          phit.last = 1;\n          phit.error = pkt.error;\n          break;\n        end\n      end\n      //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: packet.id=%0d, phit=%s\",\n      //                                                $realtime, pkt.id, pprint_phit(phit));\n      drv_phit_queue.push_back(phit);\n    end\n  endfunction : packet_to_phits\n\n\n\n  always @(posedge clock) begin : ff_axistream_driver\n    if (reset) begin\n      axist         <= '0;\n      axist__error  <= '0;\n      axist__tfirst <= '0;\n      axist__pkt_id <= '0;\n    end else begin\n\n      if (!axist.tvalid || outTready) begin\n        // tvalid=0, or tvalid=1=tready, take new phit\n        if (axist.tvalid && outTready) begin\n          // default, following a tvalid=1=tready, '0 it out.\n          axist          <= '0;\n          axist__error   <= '0;\n          axist__tfirst  <= '0;\n        end\n        if (drv_phit_queue.size() > 0 &&\n            $urandom_range(99) < m_out_tvalid_pct) begin\n          automatic phit_t phit = drv_phit_queue.pop_front();\n          axist.tvalid  <= '1;\n          axist.tdata   <= phit.data;\n          axist.tlast   <= phit.last;\n          axist.tkeep   <= phit.keep;\n          axist.tuser   <= phit.user;\n          axist__error  <= phit.error; // to outError\n          axist__tfirst <= phit.first; // local for debug, aka AvalonSt SOP\n\n          axist__pkt_id  <= phit.id; // for wave debug\n          if (phit.last)\n            num_packets_driven++;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n    outAxi4St       = axist;\n  end\n\n\n  final begin\n    if (m_driver_enable) begin\n      if (ocsim_pkg::info_verbosity_low())\n        $display(\"%t %m: num_packets_driven=%0d\", $realtime, num_packets_driven);\n    end\n  end\n\n\n  //\n  // User facing API via function calls\n  // OR - directly use drv_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            drv_packet_queue.size() > 0 ||\n            drv_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d drv=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               drv_packet_queue.size(), drv_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n  // add_rand_packet( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_rand_packet(input int        max_size = 1500,\n                                              input int        min_size = 64,\n                                              input int        id=-1,\n                                              input bit        error=0,\n                                              input bit [63:0] timestamp_ps='0);\n    bytequeue_t bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n    return add_packet_from_bytequeue(.bq(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps));\n  endfunction : add_rand_packet\n\n\n  // add_packet_from_bytequeue( *args )\n  // Returns a packet_t, and adds it to the internal drv_packet_queue\n  function automatic packet_t add_packet_from_bytequeue(input bytequeue_t bq,\n                                                       input int        id=-1,\n                                                       input bit        error=0,\n                                                       input bit [63:0] timestamp_ps='0);\n    // new_packet(..) will populate the id and timestamp_ps if id=0 or timestamp_ps=0:\n    packet_t pkt = new_packet(.data(bq), .id(id), .error(error), .timestamp_ps(timestamp_ps),\n                              .use_global_packet_id(id <= 0));\n    if (!m_driver_uses_global_pkt_id && id == -1) begin\n      // we set the id to our tracked version if id=-1\n      pkt.id = m_driver_last_pkt_id + 1;\n    end\n    m_driver_last_pkt_id = pkt.id;\n    drv_packet_queue.push_back(pkt);\n    return pkt;\n  endfunction : add_packet_from_bytequeue\n\n  // TODO(drew): drive packets from pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\n\nendmodule : ocsim_axist_driver\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/sim/ocsim_axist_monitor.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_monitor.sv\n// An AXI4 Stream Monitor, as a bus-functional model.\n//\n// This module makes use of ocsim_packet_pkg.sv, for structs and functions to process\n// \"packets\" represented as ocsim_packet_pkg::bytequeue_t and ocsim_packet_pkg::packet_t;\n//\n// Ingress path is a single AXI4 Stream protoocol\n//   -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Also requires a int parameter for AxiStreamWidth (default: 8)\n//   -- Ingress path includes an optionl input: inError, since this is not included in\n//      common AXI4 Stream signals. If this is unused, connect to 1'b0.\n//\n// This module can drive an output outTready, with some randomization, by setting parameter\n// DriveOutTready=1 and controlled with module global variable m_out_tready1_pct (0 to 100).\n// If you wish to use this driven value for tready, then connect to input inTready as well.\n//\n// If you are monitoring an already existing bus, then set parameter DriveOutTready=0,\n// leave output outTready open, and simply connect to the existing bus tready to input inTready.\n//\n// This module by default will monitor and store received packets, if member vars m_monitor_enable=1\n// and m_monitor_queue_enable=1. To process packets captured by this monitor:\n//\n//\n//   ocsim_axist_monitor #( /* ... */) u_monitor ( /* ... */);\n//\n//   always @(posedge clock) begin\n//     while (u_monitor.mon_packet_queue.size() > 0) begin\n//       /* .. do something with the packet queue .. */\n//       /* get packet at head of queue, and remove from queue */\n//       automatic ocsim_packet_pkg::packet_t got = u_monitor.mon_packet_queue.pop_front();\n//\n//       /* fancy print this packet? */\n//       $display(%t %m: got packet=%s\", realtime, ocsim_packet_pkg::packet_as_string(got));\n//\n//       /* perhaps compare this packet to an expected one? */\n//       ocsim_packet_pkg::compare_packets(.got(got), .want(some_other_packet_t_struct_signal));\n//     end\n//   end\n\n\n\n//(Start from `include \"sim/ocsim_defines.vh\")\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_defines.vh\n// Helper macros for use in `define SIMULATION\n\n`ifndef __OCSIM_DEFINES_VH\n`define __OCSIM_DEFINES_VH\n\n\n// (Skipping in include contents, flagged as only-use-once: `include \"sim/ocsim_defines.vh\")\n\n`ifdef SIMULATION\n\n// OC_RAND_PERCENT(real or int between 0 and 100)\n// returns 1 or 0 based on the input percent.\n// Note if you need to do this with an int percent, you can also use\n//   ($urandom_range(99) < p)\n`define OC_RAND_PERCENT(p) ((({$urandom}%100000) < (p*1000.0)) ? 1'b1 : 1'b0)\n\n`else\n\n// synthesis friendly variants.\n`define OC_RAND_PERCENT(p) (1'b0)\n\n`endif\n\n`endif // __OCSIM_DEFINES_VH\n\n\n//(End from `include \"sim/ocsim_defines.vh\")\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule ocsim_axist_monitor\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter bit          DriveOutTready = 0  // if 1, must connect outTready, else connect inTready.\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input  AxiStreamType inAxi4St,\n  input  logic         inError = 1'b0,\n  input  logic         inTready,     // Must be connected.\n  output logic         outTready     // if we're the endpoint, connect this to inTready.\n   );\n\n\n  // General module level global member variables (named m_.*)\n  bit                  m_monitor_enable = 1;\n  bit                  m_monitor_queue_enable = 1;\n  bit                  m_drive_out_tready = DriveOutTready;\n  int                  m_out_tready1_pct  = 80;\n\n  bit                  m_rate_monitor_enable = 0;\n  bit [31:0]           m_tactive_count, m_tinactive_count;\n\n  // stats\n  bit [31:0]           num_packets_received = 0;\n\n\n  `OC_STATIC_ASSERT(AxiStreamWidth == $bits(inAxi4St.tdata))\n\n\n\n  AxiStreamType        axist;\n  logic                axist__error;\n  logic                axist__tfirst;\n\n\n  logic                tready;\n  assign tready = inTready;\n  assign axist  = inAxi4St;\n\n\n  // 1. Monitor the ready/valid bus, must have a contiguous byte stream\n  //    from first byte (after reset or previous tlast) to tlast, check behavior on\n  //    tkeep.\n  //    -- Note this module could be relaxed to support nay tkeep values.\n  // 2. Store phits from ready/valid\n  // 3. Convert phits to packet\n  // 4. Save packet in queue for external user (testbench) to check.\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packetqueue_t;\n  import ocsim_packet_pkg::empty_packet;\n  import ocsim_packet_pkg::packet_as_string;\n\n  packetqueue_t mon_packet_queue;\n\n  int                  glbl_pkt_id = 0;\n\n  localparam int unsigned                 AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n  localparam bit [AxiStreamBytes - 1 : 0] FullKeepVec = '1;\n\n  typedef struct packed {\n    logic                           first; // not part of AXI Stream, but helps for debug\n    logic                           last;\n    logic                           user;\n    logic                           error;\n    logic [AxiStreamBytes - 1 : 0]  keep;\n    logic [AxiStreamWidth - 1 : 0]  data;\n  } phit_t;\n\n  phit_t      mon_phit_queue [$];\n  bit [63:0]  mon_sop_timestamp_queue [$];\n\n  // #Verilator $display %p isn't quite working how I'd like, so making our\n  // own local pretty print functions.\n\n  function automatic string pprint_phit(input phit_t p);\n    return $sformatf(\"{first=%0d, last=%0d, user=%0d, error=%0d, keep=0x%0x, data=0x%0x}\",\n                     p.first, p.last, p.user, p.error, p.keep, p.data);\n  endfunction : pprint_phit\n\n  // Do we need to drive 'tready' via outTready?\n  always @(posedge clock) begin : ff__drive_tready\n    if (reset || !DriveOutTready || !m_monitor_enable) begin\n      outTready <= '0;\n    end else begin\n      if (!outTready || axist.tvalid) begin\n        // either outTready=0, or outTready=1=tvalid\n        // re-randomize. Once set it must stay high.\n        outTready <= $urandom_range(99) < m_out_tready1_pct;\n      end\n    end\n  end\n\n  bit prev_phit_had_tlast;\n  always @(posedge clock) begin : ff__monitor_axist\n    if (reset || !m_monitor_enable) begin\n      prev_phit_had_tlast <= 1;\n    end else begin\n      if (axist.tvalid && tready) begin\n        enqueue_phit();\n        prev_phit_had_tlast <= axist.tlast;\n      end\n    end\n  end\n\n\n  always @(posedge clock) begin : ff__rate_monitor_axist\n    if (reset || !m_rate_monitor_enable) begin\n      m_tactive_count = '0;\n      m_tinactive_count = '0;\n    end else begin\n      // nominally check the transfer active rate using both tvalid and tready.\n      if (axist.tvalid && tready) begin\n        m_tactive_count++;\n      end else begin\n        m_tinactive_count++;\n      end\n    end\n  end\n\n  function automatic real get_calc_rate(input bit as_pct=1 /* 100x */ );\n    real ret;\n    ret = real'(u_mon.m_tactive_count) / (real'(u_mon.m_tactive_count) + real'(u_mon.m_tinactive_count));\n    if (as_pct)\n      ret *= 100.0;\n    return ret;\n  endfunction : get_calc_rate\n\n\n\n\n  function automatic void enqueue_phit();\n    phit_t phit;\n    phit.first = prev_phit_had_tlast;\n    phit.last  = axist.tlast;\n    phit.user  = axist.tuser;\n    phit.error = inError;\n    phit.keep  = axist.tkeep;\n    phit.data  = axist.tdata;\n    mon_phit_queue.push_back(phit);\n\n    if (phit.first) begin\n      // store this on First data phit.\n      mon_sop_timestamp_queue.push_back(ocsim_packet_pkg::get_timestamp_ps_now());\n    end\n\n\n    //if (ocsim_pkg::info_verbosity_debug()) $display(\"%t %m: phit=%s\",\n    //                                                $realtime, pprint_phit(phit));\n\n    if (phit.last) begin\n      process_phits_to_packet();\n    end\n\n\n  endfunction : enqueue_phit\n\n  function automatic void process_phits_to_packet();\n    packet_t pkt;\n    phit_t   phit;\n\n    // Confirm head has first=1, tail has tlast=1\n    // Confirm keep is all '1 if tlast=0\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      if (i == 0)\n        `OC_ASSERT(phit.first === 1);\n\n      if (i == mon_phit_queue.size() - 1) begin\n        `OC_ASSERT(phit.last === 1);\n        `OC_ASSERT(phit.keep !== 0);\n      end else begin\n        `OC_ASSERT(phit.last === 0);\n        `OC_ASSERT(phit.keep === FullKeepVec);\n      end\n    end\n\n\n    // copy to pkt\n    pkt = empty_packet();\n    pkt.id = ++glbl_pkt_id;\n    pkt.error = mon_phit_queue[$].error;\n    pkt.timestamp_ps = mon_sop_timestamp_queue.pop_front();\n\n    foreach (mon_phit_queue[i]) begin\n      phit = mon_phit_queue[i];\n      for (int j = 0; j < AxiStreamBytes; j++) begin\n        if (phit.keep[j]) begin\n          pkt.data.push_back(phit.data[8 * j +: 8]);\n        end\n      end\n    end\n\n    // delete the mon_phit_queue[i]\n    mon_phit_queue.delete();\n\n    if (m_monitor_queue_enable)\n      mon_packet_queue.push_back(pkt);\n\n    num_packets_received++;\n\n  endfunction : process_phits_to_packet\n\n\n  final begin\n    if (ocsim_pkg::info_verbosity_low())\n      $display(\"%t %m: num_packets_received=%0d\", $realtime, num_packets_received);\n  end\n\n  //\n  // User facing API via function calls\n  // OR - directly use mon_packet_queue (SV queue operations)\n  //\n  function automatic bit busy();\n    return (mon_packet_queue.size() > 0 ||\n            mon_phit_queue.size() > 0 ||\n            axist.tvalid);\n  endfunction : busy\n\n  function automatic bit idle();\n    return !(busy());\n  endfunction : idle\n\n  // directly check for wait statements (in case your Simulator doesn't support wait on a\n  // custom function):\n  bit m_idle;\n  always @(posedge clock) begin\n    m_idle <= idle();\n  end\n\n\n  function automatic void eot_checks();\n    if (busy())\n      $display(\"%t %m: axist.tvalid=%0d, queue sizes: mon=%0d phit=%0d\",\n               $realtime, axist.tvalid, mon_packet_queue.size(),\n               mon_phit_queue.size());\n\n    `OC_ASSERT(idle());\n  endfunction : eot_checks\n\n\n\n  // TODO(drew): write monitored packets to pcap.\n  function automatic void add_pcap();\n  endfunction : add_pcap\n\n\n\nendmodule : ocsim_axist_monitor\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_ready_valid_pipe_core.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Single stage data, outReady --> InReady comb path.\n\nmodule oclib_ready_valid_pipe_core\n  #(\n  parameter int Width = 1,\n  parameter bit ResetData = oclib_pkg::False\n    )\n  (\n  input                    clock,\n  input                    reset,\n  input logic [Width-1:0]  inData,\n  input                    inValid,\n  output logic             inReady,\n  output logic [Width-1:0] outData,\n  output logic             outValid,\n  input                    outReady\n   );\n\n\n  assign inReady = !outValid || outReady;\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      outValid <= 1'b0;\n    end else begin\n      case ({inValid && inReady, outValid && outReady})\n      2'b10: outValid <= 1'b1; // count++\n      2'b01: outValid <= 1'b0; // count--\n      default: ;\n      endcase // case ({inValid && inReady, outValid && outReady})\n\n    end\n  end\n  always_ff @(posedge clock) begin\n    if (ResetData && reset)\n      outData <= '0;\n    else if (inValid && inReady)\n      outData <= inData;\n  end\n\nendmodule : oclib_ready_valid_pipe_core\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_pipe.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_pipe.sv\n// AXIStream - pipeline NumStages worth of clock cycles to delay the inputs to the outputs, and\n// present all pipe stages as outputs\n//   -- Ingress path is AXI4 Stream protocol\n//     -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//   -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//   -- output pipeAxi4St is NumStages + 1 worth of tap points from inAxi4St --> outAxi4St, where [0] is\n//      the unflopped tap (inAxi4St) and [NumStages] is the final output tap (outAxi4St).\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_pipe\n  #(\n  parameter int unsigned NumStages = 1,\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input logic                          clock,\n  input logic                          reset,\n\n\n  input AxiStreamType                  inAxi4St,\n  output logic                         inTready,\n\n  // pipeAxi4St: [0] is unflopped (inAxi4St), [NumStages] is outAxi4St.\n  // aka, there are NumStages + 1 indicies.\n  output AxiStreamType [NumStages : 0] pipeAxi4St,\n  output logic [NumStages : 0]         pipeTready,\n\n  output AxiStreamType                 outAxi4St,\n  input  logic                         outTready\n\n   );\n\n\n  generate if (NumStages == 0) begin : gen_comb\n\n    assign inTready = outTready;\n    assign pipeAxi4St[0] = inAxi4St;\n    assign outAxi4St     = inAxi4St;\n\n  end else begin : gen_stages\n\n    logic [NumStages : 0] in__valids;\n    logic [NumStages : 0] in__readys;\n    AxiStreamType [NumStages : 0] int_pipeAxi4St;\n\n    assign in__readys[NumStages] = outTready;\n\n    assign in__valids[0]         = inAxi4St.tvalid;\n    assign int_pipeAxi4St[0]     = inAxi4St;\n\n    for (genvar g = 0; g < NumStages; g++) begin : gen_pipes\n\n      logic stage_out_valid, stage_out_ready;\n\n      oclib_ready_valid_pipe_core\n        #(.Width($bits(AxiStreamType)),\n          .ResetData(0)\n          )\n      u_stage\n        (.clock, .reset,\n         .inData(int_pipeAxi4St[g]),\n         .inValid(in__valids[g]),\n         .inReady(in__readys[g]),\n         .outData(int_pipeAxi4St[g + 1]),\n         .outValid(stage_out_valid),\n         .outReady(stage_out_ready)\n         );\n\n      assign in__valids[g + 1] = stage_out_valid;\n      assign stage_out_ready   = in__readys[g + 1];\n\n\n      always_comb begin\n        pipeAxi4St[g]        = int_pipeAxi4St[g];\n        pipeAxi4St[g].tvalid = stage_out_valid;\n      end\n\n    end\n\n    always_comb begin\n      inTready         = in__readys[0];\n      outAxi4St        = int_pipeAxi4St[NumStages];\n      outAxi4St.tvalid = in__valids[NumStages];\n    end\n\n    assign pipeTready = in__readys;\n\n  end endgenerate\n\n\nendmodule : oclib_axist_pipe\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_priarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_priarb.sv\n// Priority arbiter, where reqeusts_in[ index = 0 ] is the highest priority.\n// This is entirely combinatorial, grant_out is not held.\n\nmodule oclib_priarb\n  #(\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  generate\n\n    if (NumInputs == 1) begin : gen_1input\n\n      assign grant_out = 1'b1;\n      assign select_out   = '0;\n\n    end else if (NumInputs <= 6) begin : gen_6input\n\n      // If we only have a few inputs, implementation should be a simple look-up table:\n      logic [5:0] req, gnt;\n      logic [2:0] sel;\n      always_comb begin\n        req = 6'(requests_in);\n        casez(req)\n        6'b?????1: begin gnt = 6'b000001; sel = 3'd0; end\n        6'b????10: begin gnt = 6'b000010; sel = 3'd1; end\n        6'b???100: begin gnt = 6'b000100; sel = 3'd2; end\n        6'b??1000: begin gnt = 6'b001000; sel = 3'd3; end\n        6'b?10000: begin gnt = 6'b010000; sel = 3'd4; end\n        6'b100000: begin gnt = 6'b100000; sel = 3'd5; end\n        default:   begin gnt = '0; sel = '0; end\n        endcase // casez (req)\n\n        grant_out = NumInputs'(gnt);\n        select_out = NumSelectBits'(sel);\n      end\n\n    end else begin : gen_Ninput\n\n      // Use A & (-A) to priority select\n      // Also have to perfom a lookup for the select_out\n\n      logic [NumInputs - 1 : 0] gnt, req;\n      always_comb begin\n        req = requests_in;\n        gnt = req & (~req + 1'b1);\n\n        select_out = '0;\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (gnt[i])\n            select_out = NumSelectBits'(i);\n        end\n        grant_out = gnt;\n\n      end\n\n    end\n\n\n  endgenerate\n\n\nendmodule : oclib_priarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_rrarb.sv\n// Round robin arbiter\n// When update_valid=1, this module has a cut-through combinatorial path from\n// requests_in --> {grant_out, select_out}.\n// {grant_out, select_out} is determined by previous winners and the current requests_in vector.\n//\n// Note that grant_out can be '0, and it is legal to set update_valid=1 with requests_in=0.\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_rrarb\n  #(\n  parameter int unsigned FlopOutputs = 0,\n  parameter int unsigned NumInputs = 3,\n  parameter int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs)\n    )\n  (\n  input logic                         clock,\n  input logic                         reset,\n  input logic                         update_valid,\n  input logic [NumInputs - 1 : 0]     requests_in,\n  output logic [NumInputs - 1 : 0]    grant_out,\n  output logic [NumSelectBits - 1 :0] select_out\n   );\n\n\n  // To perform a round-robin-arb, we will keep a state that is 2x the Number of Inputs,\n  // where there's a continuous range of NumInputs 1's.\n  //   -- For example, if using 4 inputs, the initial state is:\n  //      -- 8'b1111_0000\n  //   -- This Can also be represented as {~small_state, small_state};\n  //\n  // This is an enable mask we apply to {requests_in, requests_in}.\n  //   -- For example, if our current state is 8'b0001_1110, and we have a requests_in=4'b0011,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0011, 4'b0011} = 8'b0001_0010\n  //      -- This results in index [1] being the highest priority, if priority treats lowest\n  //         index as the highest priority.\n  //   -- Another example, if current state is 8'b0001_1110, and we have a requests_in=4'b0001,\n  //      we would like to preform a priority arb on:\n  //      -- 8'b0001_1110 & {4'b0001, 4'b0001} = 8'b0001_0000\n  //      -- This results in index [4] being the highest priority. However, there is no index=4,\n  //         so we simply treat this as index [0].\n  //\n  // After a new arbitration, our state value is also updated\n  localparam int unsigned Num2xInputs     = NumInputs * 2;\n  localparam int unsigned Num2xSelectBits = oclib_pkg::safe_clog2(Num2xInputs);\n\n  `OC_SYNC_ASSERT(clock, reset, $onehot0(grant_out))\n\n  generate if (NumInputs == 1) begin : gen_1input\n\n    assign grant_out = 1'b1;\n    assign select_out   = '0;\n\n  end else begin : gen_Ninput\n\n    logic [NumInputs - 1 : 0]           grant_d, grant_q;\n    logic [NumSelectBits - 1 :0]        select_d, select_q;\n    logic [Num2xInputs - 1 : 0]         full_state_d, full_state_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        // init by saying max index was the previous winner\n        grant_q                <= '0;\n        grant_q[NumInputs - 1] <= 1'b1;\n        select_q               <= NumSelectBits'(NumInputs - 1);\n\n        full_state_q[Num2xInputs - 1 : NumInputs] <= '1;\n        full_state_q[NumInputs - 1 : 0]           <= '0;\n      end else begin\n        grant_q      <= grant_d;\n        select_q     <= select_d;\n        full_state_q <= full_state_d;\n      end\n    end\n\n    logic [Num2xInputs - 1 : 0]           priarb_grant;\n    logic [Num2xSelectBits - 1 :0]        priarb_select;\n    oclib_priarb\n      #(.NumInputs(2 * NumInputs),\n        .NumSelectBits(2 * NumSelectBits)\n        )\n    u_priarb\n      (.requests_in({requests_in, requests_in} & full_state_q),\n       .grant_out(priarb_grant),\n       .select_out(priarb_select)\n       );\n\n    if (FlopOutputs == 0) begin : gen_comb_out\n      assign grant_out  = grant_d;\n      assign select_out = select_d;\n    end else begin : gen_flop_out\n      assign grant_out  = grant_q;\n      assign select_out = select_q;\n    end\n\n\n    always_comb begin\n      grant_d      = grant_q;\n      select_d     = select_q;\n      full_state_d = full_state_q;\n\n      if (update_valid) begin\n        // Update grant. This is the logical | of our 2x wider grant from priarb.\n        grant_d = priarb_grant[Num2xInputs - 1 : NumInputs] |\n                  priarb_grant[NumInputs - 1 : 0];\n\n        // Update select. This will be recalculated from the 1 hot grant_d vector\n        for (int i = NumInputs - 1;  i >= 0; i--) begin\n          if (grant_d[i])\n            select_d = NumSelectBits'(i);\n        end\n\n        // Update full_state\n        // Example:\n        // -- If we just granted [NumInputs - 1], for example grant_d=4'b1000 select_d=3, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b1111_0000\n        // -- If we just granted [0], for example grant_d=4'b0001 select_d=0, we'd like\n        //    our new state to be ready for index [0], which is full state 8'b0001_1110.\n        // -- This {NumInputs{1'b1}} << (select_d + 1);\n        //    May need further timing optimization\n        full_state_d = {NumInputs{1'b1}} << 1;\n        full_state_d <<= select_d;\n\n      end\n    end\n\n    `OC_SYNC_ASSERT_STR(clock, reset, $countones(full_state_q) == NumInputs,\n                        $sformatf(\"full_state_q=0x%0x, needs to have NumInputs=%0d bits set\",\n                                  full_state_q, NumInputs))\n\n\n  end endgenerate // block: gen_Ninput\n\nendmodule : oclib_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_fifo\n  #(\n  parameter int  Width             = 32,\n  parameter int  Depth             = 32,\n  parameter type DataType          = logic [Width-1:0],\n  parameter int  AlmostFull        = (Depth-8),\n  parameter int  AlmostEmpty       = 8,\n  parameter bit  BlockSimReporting = oclib_pkg::False,\n  parameter bit  PreferSrl         = 0,\n  parameter int  CountWidth        = oclib_pkg::safe_clog2(Depth + 1)\n    )\n  (\n  input  logic                      clock,\n  input  logic                      reset,\n  output logic                      almostFull,\n  output logic                      almostEmpty,\n  output logic [CountWidth - 1 : 0] inCount,\n  output logic [CountWidth - 1 : 0] outCount,\n\n  input  DataType                   inData,\n  input  logic                      inValid,\n  output logic                      inReady,\n\n  output DataType                   outData,\n  output logic                      outValid,\n  input  logic                      outReady\n   );\n\n  localparam integer DataWidth = $bits(inData);\n  localparam integer AddressWidth = $clog2(Depth);\n\n  // wow this is ugly, will find a better way\n  localparam bit     UsingSrl = (Depth <= 32 &&\n                                 (PreferSrl ||\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_SRL\n                                 1 ||\n  `endif\n`endif\n                                 0));\n\n  localparam bit     UsingXpm = (\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n  `ifndef OCLIB_FIFO_DISABLE_XPM\n                                 1 ||\n  `endif\n`endif\n                                 0);\n\n  logic                sim_reset_busy;\n\n\n  if (Depth == 0) begin : gen_depth0\n    assign outData = inData;\n    assign outValid = inValid;\n    assign inReady = outReady;\n\n    assign outCount = '0;\n    assign inCount = '0;\n\n    assign sim_reset_busy = 1'b0;\n  end\n  else if (UsingSrl) begin : gen_srl\n\n    // This should map efficiently into SRLs for 32-deep FIFOs\n    logic [DataWidth-1:0]    mem [Depth-1:0];\n    logic                    write;\n    logic                    read;\n    logic                    full, fullNext;\n    logic                    empty, emptyNext;\n    logic [AddressWidth-1:0] readPointer, readPointerNext;\n    logic                    readPointerZero;\n    logic [CountWidth-1:0]   countNext, count;\n\n    assign sim_reset_busy = 1'b0;\n\n    assign outData = mem[readPointer];\n\n    assign write = (inValid && inReady);\n    assign read = (outValid && outReady);\n\n    always @(posedge clock) begin\n      // specific coding style to infer SRL\n      if (write) begin\n        for (int i=0; i<(Depth-1); i++) begin\n          mem[i+1] <= mem[i];\n        end\n        mem[0] <= inData;\n      end\n    end\n\n    always_comb begin\n      readPointerNext = readPointer;\n      countNext     = count;\n\n      case ({read, write})\n      2'b01: begin\n        countNext++;\n        if (!empty) // write, but empty: keep readPointer=0\n          readPointerNext = readPointer + 1;\n      end\n      2'b10: begin\n        countNext--;\n        if (!readPointerZero) // read: decrement but don't underflow\n          readPointerNext = readPointer - 1;\n      end\n      default: ;\n      endcase // case ({read, write})\n\n      fullNext        = (readPointerNext == (Depth-1));\n\n      emptyNext       = (empty && write) ? 1'b0 :\n                        (readPointerZero && read && ~write) ? 1'b1 :\n                        empty;\n    end\n\n    always @(posedge clock) begin\n      readPointerZero <= (readPointerNext == 0);\n      full            <= fullNext;\n      inReady         <= !fullNext; // have inReady and outValid as separate flops from full/empty\n      almostEmpty     <= (readPointer <= AlmostEmpty);\n      almostFull      <= (readPointer >= AlmostFull);\n    end\n\n    always @(posedge clock) begin\n      if (reset) begin\n        empty       <= 1'b1;\n        outValid    <= 1'b0;\n        readPointer <= '0;\n        count       <= '0;\n      end else begin\n        empty       <= emptyNext;\n        outValid    <= !emptyNext;\n        readPointer <= readPointerNext;\n        count       <= countNext;\n      end\n    end\n\n    assign inCount  = count;\n    assign outCount = count;\n\n  end // if (UsingSrl)\n  else if (UsingXpm) begin : gen_xpm\n\n    // we can't get in here without this being set, but we still need to skip during compilations\n`ifdef OC_LIBRARY_ULTRASCALE_PLUS\n\n    logic full, empty, busyWriteRst, busyReadRst;\n\n    xpm_fifo_sync #(\n                    .FIFO_MEMORY_TYPE(\"bram\"), // need to make this smarter (LUTRAM, URAM)\n                    .READ_DATA_WIDTH(DataWidth),\n                    .WRITE_DATA_WIDTH(DataWidth),\n                    .FIFO_WRITE_DEPTH(Depth),\n                    .READ_MODE(\"fwft\"),\n                    .FIFO_READ_LATENCY(0),  // needed given READ_MODE=\"fwft\"\n                    .PROG_EMPTY_THRESH(AlmostEmpty),\n                    .PROG_FULL_THRESH(AlmostFull),\n                    .RD_DATA_COUNT_WIDTH(1),\n                    .WR_DATA_COUNT_WIDTH(1),\n                    .FULL_RESET_VALUE(0),\n                    .WAKEUP_TIME(0),\n                    .DOUT_RESET_VALUE(\"0\"),\n                    .USE_ADV_FEATURES(\"0202\"),\n                    .ECC_MODE(\"no_ecc\")\n                    )\n    uXPM (\n          .almost_empty(), // these only give one entry notice\n          .almost_full(),\n          .data_valid(),\n          .dbiterr(),\n          .din(inData),\n          .dout(outData),\n          .empty(empty),\n          .full(full),\n          .injectdbiterr(1'b0),\n          .injectsbiterr(1'b0),\n          .overflow(),\n          .prog_empty(almostEmpty),\n          .prog_full(almostFull),\n          .rd_data_count(),\n          .rd_en(outReady),\n          .rd_rst_busy(busyReadRst),\n          .rst(reset),\n          .sbiterr(),\n          .sleep(1'b0),\n          .underflow(),\n          .wr_ack(),\n          .wr_clk(clock),\n          .wr_data_count(),\n          .wr_en(inValid),\n          .wr_rst_busy(busyWriteRst)\n          );\n\n    assign inReady = !full && !busyWriteRst;\n    assign outValid = !empty;\n\n    assign sim_reset_busy = busyWriteRst || busyReadRst;\n\n    // XPMs tend to not advertised their rd_data_count or wr_data_count immediately, so\n    // we'll track it on the side.\n    logic [CountWidth-1:0] count_d, count_q;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        count_q  <= '0;\n      end else begin\n        count_q  <= count_d;\n      end\n    end\n\n    always_comb begin\n      count_d = count_q;\n\n      case ({inValid && inReady,\n             outValid && outReady})\n      2'b10: count_d++; // write\n      2'b01: count_d--; // read\n      default: ;\n      endcase // case ({inValid && inReady,...\n    end\n\n    always_comb begin\n      inCount = count_q;\n\n      if (full && !busyWriteRst)\n        // full=1 after a reset=1, so we don't want our count to go to max value\n        // coming out a reset. However, if we naturally fill the FIFO and XPM reports\n        // full=1, we'd like inCount to reflect that.\n        inCount = Depth;\n    end\n\n    always_comb begin\n      outCount = count_q;\n\n      if (empty)\n        outCount = '0;\n    end\n\n\n    /*\n      USE_ADV_FEATURES\n     // write side\n     0 : overflow\n     1 : prog_full\n     2 : wr_data_count\n     3 : almost_full\n     4 : wr_ack\n     // read side\n     8 : underflow\n     9 : prog_empty\n     10 : rd_data_count\n     11 : almost_empty\n     12 : data_valid\n     */\n\n`endif // OC_LIBRARY_ULTRASCALE_PLUS\n\n  end // if (UsingXpm)\n  else begin : gen_default\n    // This is a basic RTL implementation, for sim (or unsupported library situations, but this is intended for simplicity\n    // and for now isn't really optimized for timing, power, etc).  Even latency isn't ideal.\n\n    logic write;\n    assign write = inValid && inReady;\n    logic read;\n    assign read = outValid && outReady;\n\n    logic [AddressWidth:0]   depth;\n    logic [AddressWidth:0]   depthNext;\n    logic [AddressWidth-1:0] readPointer;\n    logic [AddressWidth-1:0] readPointerNext;\n    logic [AddressWidth-1:0] writePointer;\n    logic [AddressWidth-1:0] writePointerNext;\n\n    logic [DataWidth-1:0]    mem [Depth];\n\n    assign sim_reset_busy = 1'b0;\n\n    always_comb begin\n      depthNext        = (depth + {'0,write} - {'0,read});\n      writePointerNext = writePointer;\n\n      if (write) begin\n        writePointerNext = writePointer + 1'b1;\n        if (writePointer == Depth - 1)\n          writePointerNext = '0;\n      end\n\n      readPointerNext = readPointer;\n      if (read) begin\n        readPointerNext = readPointer + 1'b1;\n        if (readPointer == Depth - 1)\n          readPointerNext = '0;\n      end\n    end\n\n    assign inCount  = depth;\n    assign outCount = depth;\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        depth <= '0;\n        readPointer <= '0;\n        writePointer <= '0;\n        inReady <= 1'b0;\n        outValid <= 1'b0;\n        almostFull <= 0;\n        almostEmpty <= 1;\n      end\n      else begin\n        depth <= depthNext;\n        readPointer <= readPointerNext;\n        writePointer <= writePointerNext;\n        inReady <= (depthNext < Depth);\n        outValid <= (depthNext > 0);\n        almostFull <= (depthNext >= AlmostFull);\n        almostEmpty <= (depthNext <= AlmostEmpty);\n      end\n    end\n\n    always_ff @(posedge clock) begin\n      if (write) begin\n        mem[writePointer] <= inData;\n      end\n      outData <= ((write && ((depth==0) || (read && (depth==1)))) ? inData :\n                  mem[readPointerNext]);\n    end\n\n  end // else: !if(UsingXpm)\n\n\n`ifdef SIMULATION\n  // during sims this will always be here, regardless of implementation above, so testbench/waves can always refer to it\n  int simDepth;\n  if (Depth == 0) begin\n    initial simDepth = 0;\n  end\n  else begin\n    always @(posedge clock) simDepth <= (reset ? '0: (simDepth + (inValid&&inReady) - (outValid&&outReady)));\n  end\n  `ifdef SIM_FIFO_DEPTH_REPORT\n  int simMaxDepth;\n  longint simTotalDepth;\n  int simTotalSamples;\n  always @(posedge clock) begin\n    if (reset) begin\n      simMaxDepth <= 0;\n      simTotalDepth <= 0;\n      simTotalSamples <= 0;\n    end\n    else begin\n      simMaxDepth <= ((simDepth > simMaxDepth) ? simDepth : simMaxDepth);\n      simTotalDepth <= (simTotalDepth + simDepth);\n      simTotalSamples <= (simTotalSamples + 1);\n    end\n  end\n  always begin\n    #( `OC_FROM_DEFINE_ELSE(SIM_REPORT_INTERVAL_NS, 5000) * 1ns);\n    if (!BlockSimReporting) begin\n      $display(\"%t %m: Depth=%4d/%4d (Max=%4d, Avg=%6.1f)\", $realtime, simDepth, Depth, simMaxDepth,\n               (real'(simTotalDepth) / real'(simTotalSamples)));\n    end\n  end\n  `endif // ifdef SIM_FIFO_DEPTH_REPORT\n\n  bit seen_rst; // defaults to 0\n  logic [1:0] reset_q;\n  always @(posedge clock) begin\n    reset_q <= {reset_q, reset || sim_reset_busy};\n    if (reset) begin\n      seen_rst   <= 1'b1;\n    end\n  end\n\n  // We need to wait an extra cycle AFTER reset (in some parameter situations) before inReady goes 0 -> 1\n  // Vivado simulations report assert properties differently, need an extra cycle of reset avoidance,\n  // and implication works better in Vivado, vs doing: inReady == (inCount < Depth)\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, inReady |-> (inCount < Depth))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !inReady |-> (inCount == Depth))\n\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, outValid |-> (outCount > 0))\n  `OC_SYNC_ASSERT(clock, !seen_rst || reset_q !== 0 || Depth == 0, !outValid |-> (outCount == 0))\n\n`endif // ifdef SIMULATION\n\nendmodule : oclib_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_rrarb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_rrarb.sv\n// AXIStream Round robin arbiter\n//   -- Ingress path is NumInputs (parameter) count of AXI4 Stream protocols\n//   -- Egress path is a single AXI4 Stream protoocol.\n//   -- Entire packets (from first data phit through outAxi4St.tlast=1) must be\n//      kept intact without alterting the arbitrated winner.\n//\n// Tested with oclib_axist_nto1_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_rrarb\n  #(\n  parameter int unsigned NumInputs  = 3,\n  parameter int unsigned FlopArbSel = 0, // Incurs one cycle latency between packets.\n  parameter int unsigned FlopOutput = 0, // Adds shallow 2-deep Srl style FIFO on egress.\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready\n\n   );\n\n\n\n  logic [NumInputs - 1 : 0] in_tvalids;\n\n  typedef enum { kIdle, kPacket } state_t;\n  state_t      state_d, state_q;\n\n  localparam int unsigned NumSelectBits = oclib_pkg::safe_clog2(NumInputs);\n  logic [NumInputs - 1 : 0]     rrarb_grant;\n  logic [NumSelectBits - 1 : 0] rrarb_select;\n  logic                         rrarb_update_valid;\n\n  AxiStreamType                 winner_axist;\n  logic                         winner_tready;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_comb begin\n    for (int unsigned i = 0; i < NumInputs; i++)\n      in_tvalids[i] = inAxi4St[i].tvalid;\n  end\n\n  // flop layer ready/valid from winner_axist --> outAxi4St\n  // and winner_tready <-- outTready.\n\n  AxiStreamType                     f_outAxi4St;\n  logic                             f_out_tvalid;\n  always_comb begin\n    // have to use the actual FIFO tvalid output:\n    outAxi4St = f_outAxi4St;\n    outAxi4St.tvalid = f_out_tvalid;\n  end\n\n  oclib_fifo\n    #(.Width($bits(inAxi4St)),\n      .Depth(FlopOutput ? 2 : 0),\n      .DataType(AxiStreamType),\n      .PreferSrl(1) // cheap flop layer, still has a readPointer 2:1 mux select.\n      )\n  u_egress_fifo\n    (.clock, .reset,\n     .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(winner_axist),\n     .inValid(winner_axist.tvalid),\n     .inReady(winner_tready),\n     .outData(f_outAxi4St),\n     .outValid(f_out_tvalid),\n     .outReady(outTready)\n     );\n\n  always_comb begin\n    winner_axist = inAxi4St[rrarb_select];\n\n    if (FlopArbSel && state_q == kIdle)\n      // If FlopArbSel > 0, rrarb_select is not valid in kIdle,\n      // don't hold the previous arb'd value with its tvalid maybe = 1\n      winner_axist.tvalid = 1'b0;\n\n  end\n\n  always_comb begin\n    state_d = state_q;\n    rrarb_update_valid = 1'b0;\n\n    inTready = '0;\n\n    case (state_q)\n    kIdle: begin\n      if (|in_tvalids) begin\n        rrarb_update_valid = 1'b1;\n\n        if (FlopArbSel == 0) begin\n          inTready[rrarb_select] = winner_tready;\n        end\n\n        // If the winner was a single phit packet with tkeep > 0 and tlast=1, then\n        // stay in kIdle. We don't check tkeep here.\n        if (FlopArbSel == 0 && winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n          ;\n        end else begin\n          // if outTready=0, which leads to winner_tready=0, do not stay in to re-arbitrate,\n          // advance to kPacket.\n          state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      inTready[rrarb_select] = winner_tready;\n      // wait for egress tlast\n      if (winner_axist.tvalid && winner_tready && winner_axist.tlast) begin\n        state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state_q)\n  end\n\n\n  oclib_rrarb\n    #(.FlopOutputs(FlopArbSel),\n      .NumInputs(NumInputs)\n      )\n  u_rrarb\n    (.clock,\n     .reset,\n     .update_valid(rrarb_update_valid),\n     .requests_in(in_tvalids),\n     .grant_out(rrarb_grant),\n     .select_out(rrarb_select)\n     );\n\n\nendmodule : oclib_axist_rrarb\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_simple_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_simple_fifo.sv\n//\n// This is a wrapper module around oclib_fifo.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//    -- module parameters to determine when the FIFO is almost full, or almost empty\n//       -- module outputs 1-bit signals for almostFull, almostEmpty.\n//    -- module outputs the number of occupied entries:\n//       -- inCount: number of occupied entries as viewed from the ingress side\n//       -- outCount: number of occupied entries as viewed from the egress side\n//    -- Additional parameterized metadata per data phit is provided for ExtraDataWidth bits\n//       -- inExtra, inError: additional ingress metadata, stored alongside inAxi4St.tdata.\n//       -- outExtra, outError: additional egressm etadata, output alongside outAxi4St.tdata.\n//\n// Tested with oclib_axist_simple_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_simple_fifo\n  #(\n  parameter type         AxiStreamType  = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n  parameter int unsigned Depth          = 8,\n  parameter int unsigned AlmostFull     = (Depth-8),\n  parameter int unsigned AlmostEmpty    = 8,\n  parameter bit          PreferSrl      = 0,\n  parameter int unsigned CountWidth     = oclib_pkg::safe_clog2(Depth + 1),\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  output logic                             almostFull,\n  output logic                             almostEmpty,\n  output logic [CountWidth - 1 : 0]        inCount,\n  output logic [CountWidth - 1 : 0]        outCount,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError = 1'b0,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready\n   );\n\n  `OC_STATIC_ASSERT($bits(inAxi4St.tdata) == AxiStreamWidth)\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n\n  logic                      data_in_fifo_valid;\n  logic                      data_in_fifo_ready;\n  logic [ExtraDataWidth : 0] data_in_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_in_fifo_data;\n  logic                      data_out_fifo_valid;\n  logic                      data_out_fifo_ready;\n  logic [ExtraDataWidth : 0] data_out_fifo_extra_error; // ExtraDataWidth + 1 (error bit)\n  AxiStreamType              data_out_fifo_data;\n\n  always_comb begin\n    data_in_fifo_extra_error = {inExtra, inError}; // error bit + ExtraDataWidth\n\n    outError = data_out_fifo_extra_error[0];\n    outExtra = data_out_fifo_extra_error >> 1;\n  end\n\n  // add error bit + ExtraDataWidth\n  localparam int unsigned CalcWidth = $bits(data_in_fifo_data) + $bits(data_in_fifo_extra_error);\n  oclib_fifo\n    #(.Width(CalcWidth),\n      .Depth(Depth),\n      .AlmostFull(AlmostFull),\n      .AlmostEmpty(AlmostEmpty),\n      .PreferSrl(PreferSrl)\n      )\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull, .almostEmpty, .inCount, .outCount,\n     .inData({data_in_fifo_extra_error,\n              data_in_fifo_data}),\n     .inValid(data_in_fifo_valid),\n     .inReady(data_in_fifo_ready),\n     .outData({data_out_fifo_extra_error,\n               data_out_fifo_data}),\n     .outValid(data_out_fifo_valid),\n     .outReady(data_out_fifo_ready)\n     );\n\n  always_comb begin\n    inTready = data_in_fifo_ready;\n    data_in_fifo_data  = inAxi4St;\n    data_in_fifo_valid = inAxi4St.tvalid;\n\n    data_out_fifo_ready = outTready;\n    outAxi4St           = data_out_fifo_data;\n    outAxi4St.tvalid    = data_out_fifo_valid;\n  end\n\nendmodule : oclib_axist_simple_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_storefwd_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_storefwd_fifo.sv\n// AXI4-Stream Store and Forward FIFO.\n//    -- Ingress and Egress paths are AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- If parameter DropIngressOnAfull=1, the FIFO will tail drop at ingress if we don't have MTU\n//       space available (based on parameter PacketMtuInBytes). This is also reported on output inFifoAfull.\n//       In this mode, output inTready is tied to 1, and is suitable to connect to an Ethernet MAC Rx bus\n//       that cannot be backpressured with inTready=0.\n//    -- If parameter DropEgressOnError=1, the FIFO will head drop at egress if the Packet had an error\n//       flagged on from ingress inAxi4St.tlast (inError=1 when inAxi4St.tvalid=1 inAxi4St.tlast=1).\n//    -- uses oclib_fifo\n//    -- Supports IngressPrefillBytes >= 0 if you don't want to wait for complete store-and-forward.\n//       -- Useful if you'd like to safely egress without worrying about underrun, if downstream\n//          outTready behavior is known.\n\n// Not yet supported:\n//  -- Ram Style choice?\n//  -- optional timing break layer on egress or ingress.\n\n// Tested with oclib_axist_storefwd_fifo_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_storefwd_fifo\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n  parameter int unsigned ExtraDataWidth = 0,\n\n    // Need a system MTU, how many MTUs FIFO can hold, and\n    // overall number of bytes in the FIFO (instead of Width + Depth)\n    // b/c we're dealing with parameterized Types.\n    // Additionally, we'd like to fit nicely in Xilinx BRAM/URAM if possible\n  parameter int unsigned PacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n\n    // Drop ingress on afull (tail drop if FIFO lacks space)\n  parameter int unsigned DropIngressOnAfull = 1,\n    // Drop egress on error (ingress packet had inError=1 inAxi4St.tlast=1), aka \"head drop\"\n  parameter int unsigned DropEgressOnError = 1,\n    // Allow egress if we've seen enough data bytes (-1 means wait for EOP)\n  parameter int          IngressPrefillBytes = -1,\n\n  parameter int unsigned ExtraDataWidthUse = (ExtraDataWidth == 0) ? 1 : ExtraDataWidth\n    )\n  (\n  input  logic                             clock,\n  input  logic                             reset,\n\n  input AxiStreamType                      inAxi4St,\n  input  logic                             inError,  // valid at Tlast=1\n  input  logic [ExtraDataWidthUse - 1 : 0] inExtra = '0,\n  output logic                             inTready,\n\n  output AxiStreamType                     outAxi4St,\n  output logic                             outError,\n  output logic [ExtraDataWidthUse - 1 : 0] outExtra,\n  input  logic                             outTready,\n\n  output logic                             inFifoAfull, // optional status.\n  output logic                             inDropEvent, // FIFO afull, drop packet at ingress (tail drop)\n  output logic                             outDropEvent // Packet had error at Tlast, drop at egress (head drop)\n   );\n\n  // Ideally, we'd like to fit into BRAM or URAM. If doing URAM, at 4Kx72bit\n  // we'd like to up-convert if our Width is smaller than 8B --> FIFO --> convert back.\n  // TODO(dranck): consider this for the future.\n\n  localparam int unsigned AxiStreamWidthBytes = (AxiStreamWidth + 7) / 8;\n  localparam int unsigned PacketMtuInPhits = ((PacketMtuInBytes + AxiStreamWidthBytes - 1) /\n                                              AxiStreamWidthBytes);\n\n  localparam int unsigned FifoDepth      = FifoSizeInBytes / AxiStreamWidthBytes;\n  localparam int unsigned FifoCountWidth = oclib_pkg::safe_clog2(FifoDepth + 1);\n  localparam int          IngressPrefillPhits = ((IngressPrefillBytes <= 1) ? 1 :\n                                                 (IngressPrefillBytes + AxiStreamWidthBytes - 1) / AxiStreamWidthBytes\n                                                 );\n\n  logic                      data_in_fifo_write_allowed;\n  logic                      data_in_fifo_ready;\n  logic                      data_in_fifo_afull;\n  AxiStreamType              data_in_fifo_data;\n\n  logic                      data_out_fifo_ready;\n  AxiStreamType              data_out_fifo_data;\n  logic [FifoCountWidth-1:0] data_out_fifo_count;\n\n  oclib_axist_simple_fifo\n    #(.AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .ExtraDataWidth(ExtraDataWidth),\n      .Depth(FifoDepth),\n      .AlmostFull(FifoDepth - PacketMtuInPhits))\n  u_data_fifo\n    (.clock,\n     .reset,\n     .almostFull(data_in_fifo_afull),\n     .almostEmpty(),\n     .inCount(),\n     .outCount(data_out_fifo_count),\n\n     .inAxi4St(data_in_fifo_data),\n     .inError,\n     .inExtra,\n     .inTready(data_in_fifo_ready),\n\n     .outAxi4St(data_out_fifo_data),\n     .outError,\n     .outExtra,\n     .outTready(data_out_fifo_ready)\n     );\n\n  logic                   tlast_in_fifo_valid;\n  logic                   tlast_in_fifo_ready;\n  logic                   tlast_in_fifo_error;\n  logic                   tlast_out_fifo_valid;\n  logic                   tlast_out_fifo_ready;\n  logic                   tlast_out_fifo_error;\n\n  always_comb begin\n    tlast_in_fifo_error = inError;\n    tlast_in_fifo_valid = data_in_fifo_data.tvalid && data_in_fifo_ready &&\n                          data_in_fifo_data.tlast;\n  end\n\n  oclib_fifo\n    #(.Width(1), // inError bit\n      .Depth(MaxNumberOfPackets)\n      )\n  u_tlast_fifo\n    (.clock,\n     .reset, .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n     .inData(tlast_in_fifo_error),\n     .inValid(tlast_in_fifo_valid),\n     .inReady(tlast_in_fifo_ready),\n     .outData(tlast_out_fifo_error),\n     .outValid(tlast_out_fifo_valid),\n     .outReady(tlast_out_fifo_ready)\n     );\n\n\n  typedef enum { kIdle, kPacket, kDrop } state_t;\n  state_t      state_d, state_q;\n  logic        ingress_drop_event_d, ingress_drop_event_q;\n  logic        egress_drop_event_d, egress_drop_event_q;\n\n  always_ff @(posedge clock) begin\n    if (reset)\n      state_q <= kIdle;\n    else\n      state_q <= state_d;\n  end\n\n  always_ff @(posedge clock) begin\n    ingress_drop_event_q <= ingress_drop_event_d;\n    egress_drop_event_q  <= egress_drop_event_d;\n  end\n  assign inDropEvent  = (DropIngressOnAfull) ? ingress_drop_event_q : 1'b0;\n  assign outDropEvent = (DropEgressOnError) ? egress_drop_event_q : 1'b0;\n  assign inFifoAfull  = !tlast_in_fifo_ready || // hit our max packets\n                        data_in_fifo_afull; // data fifo doesn't have MTU space.\n\n\n  always_comb begin\n    inTready            = '1;  // accept or tail drop if DropIngressOnAfull=1\n    if (!DropIngressOnAfull) begin\n      inTready = data_in_fifo_ready && tlast_in_fifo_ready; // both have space at ingress.\n    end\n\n    egress_drop_event_d = '0;\n\n    // IngressPrefillBytes == -1, store/fwd mode, pop if we've seen tlast for this packet.\n    outAxi4St         =  data_out_fifo_data;\n    outAxi4St.tvalid  &= tlast_out_fifo_valid;\n    data_out_fifo_ready = outTready && tlast_out_fifo_valid;\n\n    // For a prefill mode (aka, advertise egress tvalid=1 prior to ingress seeing\n    // tlast=1), wait until we have enough \"phits\" based on the parameter settings.\n    if (IngressPrefillBytes > 0 && // -1 means disabled, 0 means prefill is immediately available.\n        data_out_fifo_count >= IngressPrefillPhits) begin\n      outAxi4St.tvalid    = 1'b1;\n      data_out_fifo_ready = outTready;\n    end\n    if (IngressPrefillBytes == 0) begin\n      outAxi4St.tvalid    = data_out_fifo_data.tvalid;\n      data_out_fifo_ready = outTready;\n    end\n\n\n\n    // If we want to drop egress on some tlast \"error\" flag,\n    // then make outAxi4St.valid=0 while we set data_out_fifo_ready=1.\n    // This mode does not work with using IngressPrefillBytes >= 0.\n    if (IngressPrefillBytes == -1 &&\n        DropEgressOnError &&\n        tlast_out_fifo_valid && tlast_out_fifo_error) begin\n      data_out_fifo_ready = 1'b1;\n      outAxi4St.tvalid = 1'b0; // kill egress valid, flush to EOP.\n\n      if (data_out_fifo_data.tvalid && outAxi4St.tlast)\n        egress_drop_event_d = 1'b1;\n    end\n\n    // pop the tlast flag on final phit of data\n    tlast_out_fifo_ready = data_out_fifo_data.tvalid && data_out_fifo_ready && outAxi4St.tlast;\n\n  end\n\n\n  always_comb begin\n    data_in_fifo_write_allowed = 1'b1; // default\n\n    case (state_q)\n\n    kIdle: begin\n      if (DropIngressOnAfull &&\n          (data_in_fifo_afull || !tlast_in_fifo_ready)) begin\n        data_in_fifo_write_allowed = '0;\n      end else if (!data_in_fifo_ready || !tlast_in_fifo_ready) begin\n        data_in_fifo_write_allowed = '0;\n      end\n    end\n    kDrop: begin\n      data_in_fifo_write_allowed = '0;\n    end\n\n    default: ;\n    endcase // case (state_q)\n\n\n    data_in_fifo_data  = inAxi4St;\n    if (DropIngressOnAfull) begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && data_in_fifo_write_allowed;\n    end else begin\n      data_in_fifo_data.tvalid = inAxi4St.tvalid && tlast_in_fifo_ready;\n    end\n\n  end\n\n\n  always_comb begin : comb_ingress_fsm\n\n    state_d      = state_q;\n    ingress_drop_event_d = '0;\n\n    case (state_q)\n\n    kIdle: begin\n      if (inAxi4St.tvalid) begin\n        if (DropIngressOnAfull) begin\n          if (!data_in_fifo_write_allowed) begin\n            // If tvalid=1, but our FIFO is full, afull, or tlast fifo is full,\n            // then we have to drop this packet\n            ingress_drop_event_d = 1'b1;\n            if (!data_in_fifo_data.tlast)\n              state_d = kDrop;\n          end else begin\n            if (!data_in_fifo_data.tlast)\n              state_d = kPacket;\n            // else, state in kIdle for next packet\n          end\n        end else begin\n          if (data_in_fifo_ready && tlast_in_fifo_ready && !inAxi4St.tlast)\n            state_d = kPacket;\n        end\n      end\n    end\n\n    kPacket: begin\n      if (DropIngressOnAfull) begin\n        if (inAxi4St.tvalid && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end else begin\n        if (inAxi4St.tvalid && data_in_fifo_ready && inAxi4St.tlast && inAxi4St)\n          state_d = kIdle;\n      end\n    end\n\n    kDrop: begin\n      if (inAxi4St.tvalid && inAxi4St.tlast) begin\n          state_d = kIdle;\n      end\n    end\n\n    default: ;\n    endcase // case (state)\n\n  end\n\nendmodule : oclib_axist_storefwd_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_nto1_fifo.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_nto1_fifo.sv\n// Brute force (N=NumInputs) N Store/Forward AXIStream FIFOs + N:1 round robin arb\n// -- Ingress path is [NumInputs] (unpacked) AXI4 Stream protocols.\n//    -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n// -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n// -- Internal storage / queuing.\n//    -- If parameter DropIngressOnAfull=1, this module will \"tail drop\" if an Ingress Packet does\n//       not have MTU space to be stored (based on FifoPacketMtuInBytes bytes empty upon the first\n//       data phit write of the packet).\n//    -- If an ingress packet is dropped, it will be flagged in output inDropEvents.\n//    -- On Egress, if a stored packet has inError=1 from ingress inAxi4St.tvalid=1 and inAxi4St.tlast=1,\n//       it will be dropped on egress if parameter DropEgressOnError=1. This is flagged on output\n//       outDropEvents, per port.\n//\n// Tested with oclib_axist_nto1_fifo_test.sv\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_nto1_fifo\n  #(\n  parameter int unsigned NumInputs  = 3,\n\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned FifoMaxNumberOfPackets = 32,\n\n  parameter int unsigned DropIngressOnAfull = 1,\n  parameter int unsigned DropEgressOnError = 1,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                              clock,\n  input logic                              reset,\n\n  input AxiStreamType  [NumInputs - 1 : 0] inAxi4St,\n  input  logic         [NumInputs - 1 : 0] inError = '0,\n  output logic         [NumInputs - 1 : 0] inTready,\n\n  output AxiStreamType                     outAxi4St,\n  input  logic                             outTready,\n\n  output logic [NumInputs - 1 : 0]         inDropEvents,\n  output logic [NumInputs - 1 : 0]         outDropEvents\n   );\n\n\n  AxiStreamType [NumInputs - 1 : 0]        f_axi4st;\n  logic [NumInputs - 1 : 0]                f_axi4st__tready;\n\n  generate\n    for (genvar g = 0; g < NumInputs; g++) begin : gen_fifo\n\n      oclib_axist_storefwd_fifo\n        #(\n          .AxiStreamType(AxiStreamType),\n          .AxiStreamWidth(AxiStreamWidth),\n          .PacketMtuInBytes(FifoPacketMtuInBytes),\n          .FifoSizeInBytes(FifoSizeInBytes),\n          .MaxNumberOfPackets(FifoMaxNumberOfPackets),\n          .DropIngressOnAfull(DropIngressOnAfull),\n          .DropEgressOnError(DropEgressOnError),\n          .IngressPrefillBytes(IngressPrefillBytes)\n          )\n      u_fifo\n        (\n         .clock, .reset,\n         .inAxi4St(inAxi4St[g]),\n         .inError(inError[g]),\n         .inExtra(1'b0),\n         .inTready(inTready[g]),\n         .outAxi4St(f_axi4st[g]),\n         .outError(),\n         .outExtra(),\n         .outTready(f_axi4st__tready[g]),\n         .inFifoAfull(),\n         .inDropEvent(inDropEvents[g]),\n         .outDropEvent(outDropEvents[g])\n         );\n\n    end\n\n  endgenerate\n\n\n  oclib_axist_rrarb\n    #(\n      .NumInputs(NumInputs),\n      .FlopArbSel(1),\n      .FlopOutput(1),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth)\n      )\n  u_arb\n    (.clock, .reset,\n     .inAxi4St(f_axi4st),\n     .inTready(f_axi4st__tready),\n     .outAxi4St,\n     .outTready\n     );\n\n\nendmodule : oclib_axist_nto1_fifo\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_tfirst.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_tfirst.sv\n// Small module to create a tfirst flag on an AXI4 Stream protocol (tfirst=1 on data phit after tlast or reset).\n//\n//    -- Ingress path is AXI4 Stream protocol\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- There is no egress AXI4 Stream\n//    -- outputs two signals:\n//       -- tfirst (1-bit): is 1 on the next valid data phit after reset, or after a packet end (inAxi4St.tvalid=1,\n//          inAxi4St.tlast=1, inTready=1).\n//       -- in_packet (1-bit): is 1 on the cycle that inAxi4St.tvalid=1 && tfirst=1. Held at 1 until packet end\n//          (inAxi4St.tvalid=1, inAxi4St.tlast=1, inTready=1) and is 0 the cycle after this data phit.\n\n// Tested with oclib_axist_tfirst_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_tfirst\n  #(\n  parameter type AxiStreamType = oclib_pkg::axi4st_8_s\n    )\n  (\n  input  logic    clock,\n  input  logic    reset,\n\n  input AxiStreamType  inAxi4St,\n  input logic          inTready,\n\n  output logic         tfirst,\n  output logic         in_packet\n   );\n\n  logic                in_packet_q;\n\n  assign in_packet = in_packet_q || (inAxi4St.tvalid && tfirst);\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      tfirst      <= 1'b1;\n      in_packet_q <= 1'b0;\n    end else begin\n\n      if (inAxi4St.tvalid && inTready) begin\n        in_packet_q <= !inAxi4St.tlast;\n        tfirst      <= inAxi4St.tlast;\n      end\n\n    end\n  end\n\nendmodule : oclib_axist_tfirst\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_parser.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_parser.sv\n// AXIStream - Eth address parser\n// -- parses DestMac and SourceMac from IEEE-802 Ethernet header,\n// -- cut-through, inAxi4St.tdata --> outParsedSourceMac (final byte(s)) are unflopped\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- Egress path is AXI4 Stream protocol, same struct as the ingress path.\n//       -- The egress packet stream must match the ingress packet stream.\n//       -- No dropping\n//       -- Is delayed by 0 or more cycles, to account for cycles taken to extract the outputs for\n//          outParsedDestMac and outParsedSourceMac.\n//       -- outParsedValid=1 on the first output data phit (outAxi4St.tvalid=1 for phit after reset=1 or outAxi4St.tlast=1)\n//       -- If the AxiStreamWidth >= 128 (16B) then the outAxi4St should equal the inAxi4St, because the\n//          outParsedDestMac and outParsedSourceMac are immediately avaiable on first phit of inAxi4St.tdata[127:0].\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_parser\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8 // in bits\n    )\n  (\n  input logic           clock,\n  input logic           reset,\n\n  input AxiStreamType   inAxi4St,\n  output logic          inTready,\n\n  output AxiStreamType  outAxi4St, // egress stream, delayed.\n  input  logic          outTready,\n\n  output logic          outParsedValid, // valid at outAxi4St.tvalid=1 first phit.\n  output logic [47:0]   outParsedDestMac,\n  output logic [47:0]   outParsedSourceMac\n\n   );\n\n  // Queue up enough data phits for the first 12B of the Ethernet frame, if necessary.\n  `OC_STATIC_ASSERT_STR(AxiStreamWidth % 8 == 0, $sformatf(\"AxiStreamWidth=%0d must be in multiples of 8\", AxiStreamWidth));\n  localparam int unsigned AxiStreamBytes = AxiStreamWidth / 8; // must be divisible by 8.\n  localparam int unsigned NumPhitsNeeded = (12 + (AxiStreamBytes - 1)) / AxiStreamBytes - 1; // can be 0, round up and subtract 1.\n  localparam int unsigned NumPhitsCountBits = oclib_pkg::safe_clog2(NumPhitsNeeded) + 1;\n\n  // Figure out tfirst (sop) from inAxi4St:\n  logic                   in__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst\n    (.clock, .reset, .inAxi4St, .inTready,\n     .tfirst(in__tfirst),\n     .in_packet()\n     );\n\n\n  // For ease of IEEE 802 network byte ordering, we're going to reverse the data bus (AXIStream\n  // little endian.\n  function automatic logic [AxiStreamWidth - 1 : 0] flip_endian_data (input logic [AxiStreamBytes * 8 - 1 : 0] value);\n    logic [AxiStreamWidth - 1 : 0] ret;\n    for (int unsigned i = 0; i < AxiStreamBytes; i++)\n      ret[AxiStreamWidth - (i * 8) - 1 -: 8] = value[i * 8 + 7 -: 8];\n    return ret;\n  endfunction : flip_endian_data\n\n  logic [AxiStreamWidth - 1 : 0]                   data_big;\n\n  always_comb begin\n    data_big = flip_endian_data(inAxi4St.tdata);\n  end\n\n  generate if (NumPhitsNeeded == 0) begin : gen_no_storage\n\n    // AxiStreamWidth >= 16, use the hot values on the first phit b/c we have first 12B\n\n    assign outAxi4St = inAxi4St;\n    assign inTready = outTready;\n\n    always_comb begin\n      outParsedDestMac     = data_big[$bits(data_big) - 1 -: 48];\n      outParsedSourceMac   = data_big[$bits(data_big) - 48 - 1 -: 48];\n      outParsedValid = 1'b0;\n\n      if (inAxi4St.tvalid && in__tfirst) begin\n        outParsedValid = 1'b1; // valid for 1 cycle.\n      end\n    end\n\n  end else begin : gen_storage\n\n    // For bus width flexibility, the safest thing to do is\n    // extract at ingress. Queue up ingress data in a shallow enough\n    // FIFO, but don't advance that FIFO until we've parsed what we need to.\n    // Note - we probably could optimize this further if we knew outTready is\n    // forever tied to 1 (could instead use a shift reg instead of simple fifo).\n\n    // There are 0 cycles of latency from inAxi4St critical parsed byte -->\n    // outParsedValid.\n\n    // Note that runt (< 12B) will hang until the next packet received.\n\n    logic                 f_out_tready;\n    AxiStreamType         f_out_axist;\n    logic                 f_out_afull;\n\n    oclib_axist_simple_fifo\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .Depth(NumPhitsNeeded + 1), // +1 in depth to avoid unnecessary inTready=0, aka avoid full.\n        .AlmostFull(NumPhitsNeeded)\n        )\n    u_axist_simple_fifo\n      (.clock, .reset,\n       .almostFull(f_out_afull),\n       .almostEmpty(),\n       .inCount(), .outCount(),\n       .inAxi4St,\n       .inTready,\n       .outAxi4St(f_out_axist),\n       .outError(),\n       .outExtra(),\n       .outTready(f_out_tready)\n       );\n\n    logic                 f_out_tfirst;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_axist_tfirst_out\n      (.clock, .reset, .inAxi4St(f_out_axist), .inTready(f_out_tready),\n       .tfirst(f_out_tfirst),\n       .in_packet()\n     );\n\n    logic                 this_tvalid_have_enough_phits_q;\n    logic                 this_tvalid_have_enough_phits_q2;\n    logic [NumPhitsCountBits - 1 : 0] phit_counter_q;\n\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_d;\n    logic [(NumPhitsNeeded + 1) * AxiStreamWidth - 1 : 0] phit_storage_q;\n\n\n    `OC_STATIC_ASSERT_STR($bits(phit_storage_d) >= 12 * 8,\n                          $sformatf(\"Need to hold two 6B values, but phit_storage_d bits=%0d\",\n                                    $bits(phit_storage_d)));\n\n\n    always_ff @(posedge clock) begin\n      if (reset) begin\n        phit_counter_q     <= '0; // ingress phit counter.\n\n        this_tvalid_have_enough_phits_q  <= '0;\n        this_tvalid_have_enough_phits_q2 <= '0;\n      end else begin\n\n\n        if (inAxi4St.tvalid && inTready) begin\n\n          this_tvalid_have_enough_phits_q2 <= this_tvalid_have_enough_phits_q;\n\n          if (phit_counter_q == NumPhitsNeeded - 1) begin\n            // Note that phit_counter_q=0 on first phit, so this is the final phit.\n            // runt packets will not result in a parsed output.\n            this_tvalid_have_enough_phits_q <= 1'b1;\n          end else if (inAxi4St.tlast && NumPhitsNeeded >= 2 && phit_counter_q < NumPhitsNeeded - 1) begin\n            this_tvalid_have_enough_phits_q <= 1'b1;\n\n            `OC_ASSERT_STR(0, $sformatf(\"pkt too short: phit_counter_q=%0d and tlast=1, can't parse\",\n                                        phit_counter_q));\n          end\n\n\n          if (!(&phit_counter_q)) // default: +1, saturate\n            phit_counter_q <= phit_counter_q + 1'b1;\n          if (inAxi4St.tlast)\n            phit_counter_q   <= '0;\n        end\n\n        if (outTready && outParsedValid) begin\n          // hold parsed_valid until egress sees it.\n          // Note this behavior is a little odd, if outTready=0 and parsed_valid=1,\n          // we have to hold parsed_valid=1 otherwise the values would be lost at\n          // the downstream consumer.\n          this_tvalid_have_enough_phits_q  <= 1'b0;\n          this_tvalid_have_enough_phits_q2 <= 1'b0;\n        end\n\n      end\n    end\n\n    logic [47:0] parsed_dmac, parsed_smac;\n    logic        parsed_valid;\n    always_comb begin\n      phit_storage_d = phit_storage_q;\n      if (inAxi4St.tvalid && !this_tvalid_have_enough_phits_q2)\n        // update until we've had enough. (stop updating AFTER parse_valid=1)\n        phit_storage_d = {phit_storage_q, data_big};\n\n      // parsed_dmac, parsed_smac come hot from the inputs (and some flops)\n      parsed_valid = '0;\n      parsed_dmac = phit_storage_d[$bits(phit_storage_d) - 1 -: 48];\n      parsed_smac = phit_storage_d[$bits(phit_storage_d) - 48 - 1 -: 48];\n\n      if ((inAxi4St.tvalid && this_tvalid_have_enough_phits_q) || // cut-through critical bytes\n          this_tvalid_have_enough_phits_q2) begin // or held critcal bytes until egress has advanced.\n        parsed_valid = 1'b1;\n      end\n    end\n\n    // in-line check, we should be prefilled enough when parsed_valid=1 (and ingress tvalid=1)\n    // We still use this_tvalid_have_enough_phits_q b/c better for timing using a single flop.\n    logic f_out_first_and_afull__and_in_tvalid; // should be 1 with outParsedValid=1\n    assign f_out_first_and_afull__and_in_tvalid = f_out_axist.tvalid && f_out_tfirst &&\n                                                  f_out_afull &&\n                                                  inAxi4St.tvalid;\n\n    `OC_SYNC_ASSERT_STR(clock, reset, f_out_first_and_afull__and_in_tvalid |-> parsed_valid,\n                        $sformatf(\"f_out_first_and_afull__and_in_tvalid |-> parsed_valid\"));\n\n    assign outParsedValid       = parsed_valid && f_out_axist.tvalid && f_out_tfirst;\n    assign outParsedDestMac     = parsed_dmac;\n    assign outParsedSourceMac   = parsed_smac;\n\n    always_ff @(posedge clock) begin\n      if (inAxi4St.tvalid && inTready &&\n          // hold the storage if we have enough phits. This does not\n          // hold until egress outAxi4St.tlast=1 though (b/c this is captured at\n          // ingress).\n          !this_tvalid_have_enough_phits_q2) begin\n        phit_storage_q <= phit_storage_d; // truncate lefmost (oldest) phit\n      end\n    end\n\n    always_comb begin\n      // Need to wait until we have a parsed value (when f_out_tfirst=1)\n      // Or advance if this isn't the first phit (f_out_tfirst=0).\n\n      // Note: this could be simplified if outTready is tied to 1,\n      // we could prefill until we had enough phits (fifo count, or full||afull)\n      // with head entry being tfirst before allowing it downstream.\n      // It's a bit of a gray area on how early parsed_valid=1 happens (can happen\n      // on previous packet tlast=1, due to our FIFO needing Depth=NumPhitsNeeded+1,\n      // which is why outParsedValid=1 waits for egress f_out_tfirst=1.\n\n      outAxi4St        = f_out_axist;\n      outAxi4St.tvalid = f_out_axist.tvalid &&\n                         (parsed_valid || !f_out_tfirst);\n      f_out_tready = outTready && f_out_axist.tvalid &&\n                     (parsed_valid || !f_out_tfirst);\n    end\n\n\n\n  end // block: gen_storage\n  endgenerate\n\n  `OC_SYNC_ASSERT_STR(clock, reset,\n                      outParsedValid && $past(outParsedValid) |->\n                      {outParsedDestMac, outParsedSourceMac} ===\n                      $past({outParsedDestMac, outParsedSourceMac}),\n                      $sformatf(\"parsed values must be stable while outParsedValid=1\"));\n\nendmodule : oclib_axist_eth_parser\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_route_table.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_route_table.sv\n// Implementation of a MAC table.\n// -- Per ingress port L2 routing table.\n//    -- Ingress path and Egress path are AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//    -- It is assumed that up-stream of Ingress (inAxi4St input) there exists an Ethernet header\n//       DestMac and SourceMac parser such as oclib_axist_eth_parser.sv, that has parsed data available\n//       and aligned to the first data phit of the AXI4 Stream on inAxi4St.tvalid.\n//    -- The Egress path is transparently passed from Ingress, with the addition of a vector output\n//       outDestsValid[NumPorts-1:0]. This indicates to downstream Egress ports whether or not to accept\n//       the packet (an Egress port can examine outAxi4St.tvalid=1 and outDestsValid[their_port_index]=1).\n// -- Table:\n//    -- 1 read port for the Ingress --> Egress AXI Stream path\n//       -- NumWrPorts (default: 4) write ports (from other ingress ports + ourself) for smac --> ingress port\n//        (arbitrated, only 1 write at a time).\n//    -- This is designed as an unmanaged table and cannot support Loopback, otherwise another Loopback would\n//       potentially corrupt the table (we advertised the same SourceMac address on our Rx on the Loopback port,\n//       that was previously advertised on a different Rx port).\n//    -- default 8 entry, flops.\n//    -- VLAN is not supported, Ethertype is not examined in this module.\n\n// Note - this module is not unit tested, but is covered in:\n//  -- oclib_axist_eth_router_test\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\n\nmodule oclib_axist_eth_route_table\n  #(\n  parameter type         AxiStreamType = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth = 8, // in bits\n\n  parameter int unsigned ThisPort        = 0,\n  parameter int unsigned TableDepth      = 8,\n  parameter int unsigned NumPorts        = 4, // including this port (determines Dest bits)\n  parameter int unsigned NumWrPorts      = NumPorts,\n  parameter int unsigned PortIndexBits   = oclib_pkg::safe_clog2(NumPorts),\n  parameter int unsigned CyclesPerEpoch  = 32'd1_750_000_000\n    )\n  (\n  input logic                                              clock,\n  input logic                                              reset,\n\n  input AxiStreamType                                      inAxi4St,\n  output logic                                             inTready,\n  input logic                                              inParsedValid, // 1 on first phit.\n  input logic [47:0]                                       inParsedDestMac,\n  input logic [47:0]                                       inParsedSourceMac,\n\n  output AxiStreamType                                     outAxi4St, // egress stream, delayed.\n  output logic [NumPorts - 1 : 0]                          outDestsValid,\n  input  logic                                             outTready,\n\n\n  input  logic [NumWrPorts - 1 : 0]                        inWriteValid,\n  input  logic [NumWrPorts - 1 : 0][47:0]                  inWriteAddr,   // source mac address\n  input  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inWriteSource, // physical source port\n\n  output logic                                             outWriteValid, // To all other tables.\n  output logic [47:0]                                      outWriteAddr,  // source mac address\n  output logic [PortIndexBits - 1 : 0]                     outWriteSource // == ThisPort\n   );\n\n  localparam int unsigned TableIndexBits = oclib_pkg::safe_clog2(TableDepth);\n\n  // Shallow queue the writes. Service them as long as we're not servicing ourself.\n  // If we're full, drop the write.\n\n  logic [NumWrPorts - 1 : 0]                        f_write_valid, f_write_ready;\n  logic [NumWrPorts - 1 : 0][47:0]                  f_write_addr;\n  logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] f_write_source;\n\n  generate for (genvar g = 0; g < NumWrPorts; g++) begin : gen_write_queues\n\n    logic int_in_write_ready;\n    oclib_fifo\n      #(.Width(48 + PortIndexBits),\n        .Depth(2),\n        .PreferSrl(1)\n        )\n    u_fifo\n      (.clock, .reset,\n       .almostFull(), .almostEmpty(), .inCount(), .outCount(),\n       .inData({inWriteAddr[g], inWriteSource[g]}),\n       .inValid(inWriteValid[g]),\n       .inReady(int_in_write_ready),\n       .outData({f_write_addr[g], f_write_source[g]}),\n       .outValid(f_write_valid[g]),\n       .outReady(f_write_ready[g]));\n\n\n    ///`OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> inWriteSource[g] != ThisPort,\n    ///                    $sformatf(\"Ext write cannot be for ThisPort: g=%0d, inWriteSource[g]=%0d, ThisPort=%0d\",\n    ///                              g, inWriteSource[g], ThisPort));\n    `OC_SYNC_ASSERT_STR(clock, reset, inWriteValid[g] |-> int_in_write_ready,\n                        $sformatf(\"u_fifo was full when written, a write update was lost, g=%0d (inWriteValid[g]=1 ready=0)\",\n                                  g));\n\n  end\n  endgenerate\n\n  localparam WrPortIndexBits = oclib_pkg::safe_clog2(NumWrPorts);\n  logic [WrPortIndexBits - 1 : 0] ext_write_sel;\n\n  oclib_priarb\n    #(.NumInputs(NumWrPorts))\n  u_priarb_ext_write\n    (\n     .requests_in(f_write_valid),\n     .grant_out(f_write_ready),\n     .select_out(ext_write_sel)\n     );\n\n  // Select chosen external write.\n  logic                         ext_write_valid;\n  logic [47:0]                  ext_write_addr;\n  logic [PortIndexBits - 1 : 0] ext_write_source;\n  always_ff @(posedge clock) begin\n    ext_write_valid  <= '0;\n    ext_write_addr   <= '0;\n    ext_write_source <= '0;\n    if (|f_write_ready) begin\n      ext_write_valid  <= 1'b1;\n      ext_write_addr   <= f_write_addr[ext_write_sel];\n      ext_write_source <= f_write_source[ext_write_sel];\n    end\n  end\n\n\n  typedef struct packed {\n    logic [47:0]              addr;\n    logic [NumPorts - 1 : 0]  dests_valid;\n    logic [NumPorts - 1 : 0]  time_epoch;\n  } table_entry_t;\n\n  table_entry_t [TableDepth - 1 : 0] mem_d, mem_q;\n\n\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      mem_q <= '0;\n    end else begin\n      mem_q <= mem_d;\n    end\n  end\n\n  // Maintain an epoch timer, to know when we can evict entries.\n  // For now, we'll assume our clock is in the 100-350MHz range, and\n  // we'd like to maintain entries for several seconds (5 seconds)\n  // 350MHz = 2.857ns\n  // 5seconds / 2.857ns/cycle = 5e9 / 2.857 = 1_750_087_504\n  // a 32-bit cycle counter should be sufficient.\n  logic [31:0] cycle_counter_q;\n  logic [3:0]  current_epoch_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      cycle_counter_q <= '0;\n      current_epoch_q <= '0;\n    end else begin\n      cycle_counter_q <= cycle_counter_q + 1'b1;\n      if (cycle_counter_q >= CyclesPerEpoch) begin\n        cycle_counter_q <= '0;\n        current_epoch_q <= current_epoch_q + 1'b1;\n      end\n    end\n  end\n\n  logic inAxi4St__tfirst;\n\n  oclib_axist_tfirst\n    #(.AxiStreamType(AxiStreamType))\n  u_axist_tfirst_in\n    (.clock, .reset,\n     .inAxi4St, .inTready,\n     .tfirst(inAxi4St__tfirst),\n     .in_packet());\n\n  `OC_SYNC_ASSERT(clock, reset, inParsedValid |-> inAxi4St__tfirst);\n\n\n  logic                           read_valid;\n  logic                           read_existing_avail;\n  logic [TableIndexBits - 1 : 0]  read_existing_index;\n  logic [NumPorts - 1 : 0]        read_dests;\n\n  always_comb begin : comb__mem_read\n\n    read_valid = inAxi4St.tvalid && inAxi4St__tfirst;\n\n    read_existing_avail  = 1'b0;\n    read_existing_index  = '0;\n    read_dests           = '1;  // default send to everyone but ourselves if table miss.\n\n    if (read_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find existing entry.\n        if (mem_q[i].addr == inParsedDestMac) begin\n          read_existing_avail = 1'b1;\n          read_existing_index = TableIndexBits'(i);\n          // read from an existing entry:\n          read_dests = mem_q[read_existing_index].dests_valid;\n        end\n      end\n    end\n\n    // Note - we cannot allow for same port unicast loopback, b/c we are not a\n    // L3 Switch. If we loop packet back to a switch similar to us, that uses\n    // SourceMac as discovery, then it will also loop the packet back to us\n    // (we are L2, we are not decrementing ttl).\n\n    read_dests[ThisPort] = 1'b0; // can never send to ourselves.\n\n    // The above line also helps with dropping packets that ThisPort\n    // recognized as needing to be looped back. We only allow 1 bit\n    // to be set in the \"dests_valid\" field, if there was a \"hit\" in the table.\n  end\n\n  `OC_SYNC_ASSERT(clock, reset, read_valid && read_existing_avail |-> $onehot0(read_dests))  // src -> dst, no loopback.\n  `OC_SYNC_ASSERT(clock, reset, read_valid && !read_existing_avail |-> $onehot(~read_dests)) // broadcast\n\n\n\n  oclib_axist_pipe\n    #(.NumStages(1), .AxiStreamType(AxiStreamType))\n  u_axist_pipe\n    (.clock, .reset,\n     .inAxi4St,\n     .inTready,\n     .pipeAxi4St(),\n     .pipeTready(),\n     .outAxi4St,\n     .outTready\n     );\n\n\n  always_ff @(posedge clock) begin\n    // set and hold the Dest Mac on ingress inAxi4St first data phit (when inParsedValid=1)\n    if (reset) begin\n      outDestsValid <= '0;\n    end else begin\n      if (read_valid) begin\n        outDestsValid <= read_dests; // set and hold on tfirst.\n      end\n    end\n  end\n\n  logic                          scan_perfomed_d;\n  logic [TableIndexBits - 1 : 0] scan_index_q;\n  always_ff @(posedge clock) begin\n    if (reset) begin\n      scan_index_q <= '0;\n    end else if (scan_perfomed_d)  begin\n      scan_index_q <= scan_index_q + 1'b1;\n    end\n  end\n\n\n  logic                           write_free_avail;\n  logic [TableIndexBits - 1 : 0]  write_free_index;\n  logic                           write_existing_avail;\n  logic [TableIndexBits - 1 : 0]  write_existing_index;\n\n\n  logic [NumPorts - 1 : 0][3:0]  epoch_diff;\n\n  always_comb begin : comb__mem_writes\n    mem_d = mem_q;\n\n    write_existing_avail = 1'b0;\n    write_existing_index = '0;\n    write_free_avail     = 1'b0;\n    write_free_index     = '0;\n    scan_perfomed_d      = 1'b0;\n\n    epoch_diff = '0;\n\n    if (ext_write_valid) begin\n      for (int unsigned i = 0; i < TableDepth; i++) begin\n        // find first available entry\n        if (mem_q[i].dests_valid == 0) begin\n          write_free_avail = 1'b1;\n          write_free_index = TableIndexBits'(i);\n        end\n        // find existing entry.\n        if (mem_q[i].addr == ext_write_addr) begin\n          write_existing_avail = 1'b1;\n          write_existing_index = TableIndexBits'(i);\n        end\n      end\n    end\n\n    if (write_existing_avail) begin\n\n      // don't write a free/unused entry, update the existing entry.\n      mem_d[write_existing_index].dests_valid = '0; // we only want 1 entry for this (unicast) MAC address.\n      mem_d[write_existing_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_existing_index].time_epoch = 4'(current_epoch_q);\n\n\n    end else if (write_free_avail) begin\n\n      // else write at a free/unused entry. If there was no free entry,\n      // too bad.\n      mem_d[write_free_index].addr = ext_write_addr;\n      mem_d[write_existing_index].dests_valid = '0;\n      mem_d[write_free_index].dests_valid[ext_write_source] = 1'b1;\n      mem_d[write_free_index].time_epoch = 4'(current_epoch_q);\n\n    end else begin\n\n      // Background table maintenance to free entries.\n      scan_perfomed_d = 1'b1;\n      epoch_diff = current_epoch_q - mem_q[scan_index_q].time_epoch;\n\n      if (mem_q[scan_index_q].dests_valid > 0 && epoch_diff > 2) begin\n        // free entry if it's valid.\n        mem_d[scan_index_q].dests_valid = '0;\n      end\n\n    end\n\n  end\n\n\n  always_ff @(posedge clock) begin\n\n    outWriteValid  <= inAxi4St.tvalid && inParsedValid && inTready;\n    outWriteAddr   <= inParsedSourceMac;\n    outWriteSource <= PortIndexBits'(ThisPort);\n\n    // Do not perform writes if we have a bad SourceMac (such as broadcast or multicast)\n    // these will remain unclassified in our tables so they go to all Tx dest ports\n    // (but not our own).\n    outWriteValid <= 'b0;\n    if (inAxi4St.tvalid && inParsedValid && inTready) begin\n      outWriteValid <= 1'b1;\n      if (inParsedSourceMac[40] == 1'b1)\n        // multicast, 0x01_00_5E_--_--_--\n        // broadcast, 0xff_ff_ff_ff_ff_ff\n        outWriteValid <= 1'b0;\n    end\n\n  end\n\n`ifdef SIMULATION\n\n  always @(posedge clock) begin\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      if (write_existing_avail) begin\n        $display(\"%t %m: Table existing entry updated by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_existing_index, ext_write_addr, current_epoch_q);\n      end else if (write_free_avail) begin\n        $display(\"%t %m: Table free entry written by source port=%0d, table index=%0d, addr(smac)=0x%12x, new epoch=%0d\",\n                 $realtime, ext_write_source, write_free_index, ext_write_addr, current_epoch_q);\n      end else if (scan_perfomed_d) begin\n        if (scan_perfomed_d && epoch_diff > 2) begin\n          $display(\"%t %m: Table scan updated - entry %0d (existing mac 0x%12x) has expired epoch\",\n                   $realtime, scan_index_q, mem_q[scan_index_q].addr, mem_q[scan_index_q].dests_valid);\n        end\n\n      end\n\n      if (read_valid) begin\n        $display(\"%t %m: Table read (incoming packet) dmac=0x%12x will go to dests=0x%x\",\n                 $realtime, inParsedDestMac, read_dests);\n      end\n\n\n    end\n\n  end\n\n`endif\n\n\n\nendmodule : oclib_axist_eth_route_table\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/oclib_axist_eth_router.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// oclib_axist_eth_router.sv\n// -- NumPorts instances of oclib_axist_eth_route_table.sv\n//    -- Ingress path is AXI4 Stream protocol.\n//       -- This is a struct using parameter AxiStreamType, default oclib_pkg::axi4st_8_s (8-bit data)\n//         -- For 1G applications, consider clock as 125MHz using oclib_pkg::axi4st_8_s\n//         -- For 10G applications, consider clock as 161MHz using oclib_pkg::axi4st_64_s\n//         -- tvalid is contained within the struct\n//    -- Each Ingress Port gets its own routing table.\n//    -- Each routing table takes writes from all other Ingress Ports.\n// -- NumPorts instances of oclib_axist_nto1_fifo\n//    -- Egress path is AXI4 Stream protocol, same structs as the ingress path.\n//    -- Each egress path gets NumPorts axistreams, writing is qualified (or squashed)\n//       based on the ingress routing table results.\n\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router\n  #(\n  parameter int unsigned NumPorts        = 4,\n  parameter type         AxiStreamType   = oclib_pkg::axi4st_8_s,\n  parameter int unsigned AxiStreamWidth  = 8, // in bits\n  parameter int unsigned MacTableDepth   = 16,\n  parameter int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000,\n\n  // FIFO settings per egress Port (NumPorts x NumPorts total FIFOs)\n  parameter int unsigned FifoPacketMtuInBytes = 1500,\n  parameter int unsigned FifoSizeInBytes = 4096,\n  parameter int unsigned MaxNumberOfPackets = 32,\n  parameter int          IngressPrefillBytes = -1\n    )\n  (\n  input logic                                        clock,\n  input logic                                        reset,\n\n  input AxiStreamType  [NumPorts - 1 : 0]            inAxi4St,\n  output logic         [NumPorts - 1 : 0]            inTready,\n\n  output AxiStreamType [NumPorts - 1 : 0]            outAxi4St,\n  input  logic         [NumPorts - 1 : 0]            outTready, // outTready must be tied to '1.\n\n  output logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents // [i][j]=1: Port i dropped pkt from port [j].\n   );\n\n  localparam int unsigned PortIndexBits = oclib_pkg::safe_clog2(NumPorts);\n  localparam int unsigned NumWrPorts = NumPorts;\n\n  logic [NumPorts - 1 : 0]                        outTables_WriteValid;\n  logic [NumPorts - 1 : 0][47:0]                  outTables_WriteAddr;\n  logic [NumPorts - 1 : 0][PortIndexBits - 1 : 0] outTables_WriteSource;\n\n  AxiStreamType [NumPorts - 1 : 0]           outTables_Axi4St;\n  logic [NumPorts - 1 : 0][NumPorts - 1 : 0] outTables_DestsValid;\n  logic [NumPorts - 1 : 0]                   outTables_Tready;\n\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_ports\n\n    logic [NumWrPorts - 1 : 0]                        inTable_WriteValid;\n    logic [NumWrPorts - 1 : 0][47:0]                  inTable_WriteAddr;\n    logic [NumWrPorts - 1 : 0][PortIndexBits - 1 : 0] inTable_WriteSource;\n\n    for (genvar p = 0; p < NumPorts; p++) begin : gen_write_buses;\n        assign inTable_WriteValid[p]  = outTables_WriteValid[p];\n        assign inTable_WriteAddr[p]   = outTables_WriteAddr[p];\n        assign inTable_WriteSource[p] = outTables_WriteSource[p];\n    end\n\n\n    AxiStreamType            parserAxi4St;\n    logic                    parserTready;\n    logic                    parserParsedValid;\n    logic [47:0]             parserParsedDestMac;\n    logic [47:0]             parserParsedSourceMac;\n\n\n    oclib_axist_eth_parser\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_eth_parser\n      (.clock, .reset,\n       .inAxi4St(inAxi4St[g]),\n       .inTready(inTready[g]),\n       .outAxi4St(parserAxi4St),\n       .outTready(parserTready),\n       .outParsedValid(parserParsedValid),\n       .outParsedDestMac(parserParsedDestMac),\n       .outParsedSourceMac(parserParsedSourceMac)\n       );\n\n    oclib_axist_eth_route_table\n      #(\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .ThisPort(g),\n        .TableDepth(MacTableDepth),\n        .NumPorts(NumPorts),\n        .NumWrPorts(NumWrPorts),\n        .CyclesPerEpoch(MacTableCyclesPerEpoch)\n        )\n    u_route_table\n        (\n         .clock, .reset,\n\n         .inAxi4St(parserAxi4St),\n         .inTready(parserTready),\n         .inParsedValid(parserParsedValid),\n         .inParsedDestMac(parserParsedDestMac),\n         .inParsedSourceMac(parserParsedSourceMac),\n\n         .outAxi4St(outTables_Axi4St[g]),\n         .outDestsValid(outTables_DestsValid[g]),\n         .outTready(outTables_Tready[g]),\n\n         .inWriteValid(inTable_WriteValid),\n         .inWriteAddr(inTable_WriteAddr),\n         .inWriteSource(inTable_WriteSource),\n\n         .outWriteValid(outTables_WriteValid[g]),\n         .outWriteAddr(outTables_WriteAddr[g]),\n         .outWriteSource(outTables_WriteSource[g])\n         );\n\n    assign outTables_Tready[g] = 1'b1;  // requirement, but allowed b/c egress FIFO is store/fwd.\n\n\n    AxiStreamType [NumPorts - 1 : 0]           inEgressFifos_Axi4St;\n    logic [NumPorts - 1 : 0]                   inEgressFifos_Tready;\n\n    // Lastly, we need to steer the correct outTables_Axi4St + outTables_DestsValid --> inEgressFifos_Axi4St.\n    // For example, port g=2 might have:\n    //   outTables_Axi4St[g=2].tvalid=1\n    //   outTables_DestsValid[g=2] = 4'b0011;\n    // This implies, port 2 wants to write this packet to egress ports 0 and 1, but not 2 and 3.\n    //\n    // This is at the egress port though, so to see who wants to write to us:\n    //   - look at all outTables_Axi4St[i]\n    //   - look at all outTables_DestsValid[i], and if they have bit [g] set, then we write it.\n    always_comb begin\n      for (int unsigned i = 0; i < NumPorts; i++) begin\n        // copy the axistream:\n        inEgressFifos_Axi4St[i] = outTables_Axi4St[i]; // from ingress port i\n\n        // Only write this packet if the outTables_DestsValid[i] bit is set for this path.\n        inEgressFifos_Axi4St[i].tvalid &= outTables_DestsValid[i][g];\n\n        // Note this section does support loopback on Rx Port i --> Tx Port i, which\n        // is determined by oclib_axist_eth_route_table.sv behavior. We enforce that behiavor here\n        // as well\n        if (i == g)\n          inEgressFifos_Axi4St[i].tvalid = 1'b0;\n      end\n    end\n\n    logic [NumPorts - 1 : 0] tie0_inError;\n    assign tie0_inError = '0;\n\n    oclib_axist_nto1_fifo\n      #(\n        .NumInputs(NumPorts),\n        .AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .FifoPacketMtuInBytes(FifoPacketMtuInBytes),\n        .FifoSizeInBytes(FifoSizeInBytes),\n        .FifoMaxNumberOfPackets(MaxNumberOfPackets),\n        .DropIngressOnAfull(IngressPrefillBytes >= 0),\n        .IngressPrefillBytes(IngressPrefillBytes)\n        )\n    u_nto1_fifo\n      (.clock, .reset,\n       .inAxi4St(inEgressFifos_Axi4St),\n       .inError(tie0_inError),\n       .inTready(), // Tail drops, inTready is tied to 1.\n\n       .outAxi4St(outAxi4St[g]),\n       .outTready(outTready[g]),\n\n       .inDropEvents(egressFifoDropEvents[g]),\n       .outDropEvents() // not used, we do not drop on Error.\n       );\n\n  end // block: gen_ports\n  endgenerate\n\n\nendmodule : oclib_axist_eth_router\n\n\n// src_file='/home/drew/github/eth-puzzles/opencos/lib/tests/oclib_axist_eth_router_test.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for oclib_axist_eth_router.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule oclib_axist_eth_router_test;\n\n\n\n//(Start from `include \"sim/ocsim_axist_width_type.svh\")\n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// ocsim_axist_width_type.svh\n// This is a convenience code snippet that can be included a the top of testbenches\n// to create some localparams for\n//    AxiStreamWidth (int)\n//    AxiStreamType (type, such as oclib_pkg::axi4st_{int}_s)\n//\n// Intent is to include this in the testbench module body.\n\n`ifndef AXI_STREAM_WIDTH\n`define AXI_STREAM_WIDTH 8\n`endif\n\n`ifndef AXI_STREAM_TYPE\n  // Vivado simulation needs this set via a define.\n`define AXI_STREAM_TYPE oclib_pkg::axi4st_8_s\n`endif\n\n  localparam int AxiStreamWidth = `AXI_STREAM_WIDTH;\n\n`ifdef OC_TOOL_VIVADO\n  // Vivado simulation doesn't handle types well at all. Functions returning a type\n  // are considered syntax errors, and a conditional is also problematic. The\n  // define method of: oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s  also does not work.\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n`ifdef OC_TOOL_MODELSIM_ASE\n  // Modelsim ASE has the same behavior as Vivado:\n  localparam type AxiStreamType = `AXI_STREAM_TYPE;\n`else\n  // #Verilator doesn't have a great way of returning types from functions, so\n  // using defines to achieve this :(\n  localparam type AxiStreamType = oclib_pkg::axi4st_```AXI_STREAM_WIDTH``_s;\n`endif\n`endif\n\n\n//(End from `include \"sim/ocsim_axist_width_type.svh\")\n\n// Sets AxiStreamWidth and AxiStreamType\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  oclib_axist_eth_router\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    `OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n                        $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n                                  g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    `OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 90;\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule : oclib_axist_eth_router_test\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_6_test_sim/local_pkg.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\npackage local_pkg;\n\n  localparam bit True = 1;\n  localparam bit False = 0;\n\n  localparam byte ResetChar = \"~\";\n  localparam byte SyncChar = \"|\";\n\n  localparam integer DefaultCsrAlignment = 4;\n\n  function automatic int unsigned safe_clog2(input int unsigned a);\n    return a <= 2 ? 1 : $clog2(a);\n  endfunction : safe_clog2\n\n\n  function automatic logic [7:0] HexToAsciiNibble (input [3:0] hex);\n    if (hex > 'd9) return \"a\" + (hex - 'd10);\n    else return \"0\" + hex;\n  endfunction : HexToAsciiNibble\n\n\n  function automatic logic [3:0] AsciiToHexNibble (input [7:0] ascii);\n    if ((ascii >= \"0\") && (ascii <= \"9\")) return (ascii - \"0\");\n    if ((ascii >= \"a\") && (ascii <= \"f\")) return (ascii - \"a\" + 10);\n    if ((ascii >= \"A\") && (ascii <= \"F\")) return (ascii - \"A\" + 10);\n    return 4'hX; // can't convert, but not much else to do in this context\n  endfunction : AsciiToHexNibble\n\n\n\n  // ***********************************************************************************************\n  // TOP INFO bus\n  // ***********************************************************************************************\n\n  typedef struct packed {\n    logic        tick1us; // currently pulses for 5 clockTop but maybe should be stretched or toggle?\n    logic        tick1ms;\n    logic        tick1s;\n    logic        halt;\n    logic        error;\n    logic        clear;\n    logic [7:0]  unlocked; // support for unlocking 8 separate functions\n    logic        thermalError;\n    logic        thermalWarning;\n  } chip_status_s;\n\n  typedef struct packed {\n    /* verilator lint_off SYMRSVDWORD */\n    logic        interrupt;\n    /* verilator lint_on SYMRSVDWORD */\n    logic        halt;\n    logic        error;\n  } chip_status_fb_s;\n\n  typedef struct packed {\n    logic        error;\n    logic        done;\n  } user_status_s;\n\n  // ***********************************************************************************************\n  // BYTE CHANNEL protocols\n  // ***********************************************************************************************\n\n  // This protocol encapsulates the task of sending a byte stream.\n\n  // 8-bit synchronous byte channel with ready/valid semantics\n  // this is generally the default that is assumed, esp interfacing with other blocks.  The async\n  // versions are really for transport of the byte stream between blocks, chips, etc.\n\n  // The \"dummy\" stuff is because we compare types all over the place.  Broken tools don't compare\n  // types consistently, so for those we compare the width of the structs, and hence the widths must\n  // be unique.  The \"dummy\" signals will be compiled out.  We only \"uniquify\" the forward path, not\n  // the *Fb, since we only do comparisons on forward path.\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n    logic        ready;\n  } bc_8b_bidi_s; // 10 bit\n\n  typedef struct packed {\n    logic [7:0]  data;\n    logic        valid;\n  } bc_8b_s; // 9 bit\n\n  typedef struct packed {\n    logic        ready;\n  } bc_8b_fb_s;\n\n  // 8-bit asynchronous byte channel with req/ack semantics\n\n  // Source puts DATA on bus, asserts REQ\n  // Sink raises ACK (doesn't sample data yet!)\n  // Source sees ACK, de-asserts REQ\n  // Sink sees REQ de-assert, samples data, de-asserts ACK\n  // Source sees ACK de-assert, and knows (a) slave got the data, (b) it can start a new transaction\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n    logic        ack;\n  } bc_async_8b_bidi_s; // 10 -> 12 bit\n\n  typedef struct packed {\n    `OC_IFDEF_INCLUDE(OC_TOOL_BROKEN_TYPE_COMPARISON, logic[1:0]dummy; )\n    logic [7:0]  data;\n    logic        req;\n  } bc_async_8b_s; // 9 -> 11 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_8b_fb_s;\n\n  // Serial asynchronous byte channel\n\n  // Source toggles data0 or data1 to indicate a bit being transferred\n  // Sink acks with XOR of data0 and data1, so it will flip polarity when either is transmitted,\n  // and doesn't require state (i.e. if ack == (data0^data1) then we are ready to send data).\n\n  typedef struct packed {\n    logic [1:0]  data;\n    logic        ack;\n  } bc_async_1b_bidi_s; // 3 bit\n\n  typedef struct packed {\n    logic [1:0]  data;\n  } bc_async_1b_s; // 2 bit\n\n  typedef struct packed {\n    logic        ack;\n  } bc_async_1b_fb_s;\n\n  // ***********************************************************************************************\n  // CSR protocols\n  // ***********************************************************************************************\n\n  localparam int                  CsrIdBits = 16;\n\n  localparam [CsrIdBits-1:0]      CsrIdPll = 'd1;\n  localparam [CsrIdBits-1:0]      CsrIdChipMon = 'd2;\n  localparam [CsrIdBits-1:0]      CsrIdProtect = 'd3;\n  localparam [CsrIdBits-1:0]      CsrIdDummy = 'd4;\n  localparam [CsrIdBits-1:0]      CsrIdIic = 'd5;\n  localparam [CsrIdBits-1:0]      CsrIdLed = 'd6;\n  localparam [CsrIdBits-1:0]      CsrIdGpio = 'd7;\n  localparam [CsrIdBits-1:0]      CsrIdFan = 'd8;\n  localparam [CsrIdBits-1:0]      CsrIdHbm = 'd9;\n  localparam [CsrIdBits-1:0]      CsrIdCmac = 'd10;\n  localparam [CsrIdBits-1:0]      CsrIdPcie = 'd11;\n  localparam [CsrIdBits-1:0]      CsrIdEth1g = 'd12;\n  localparam [CsrIdBits-1:0]      CsrIdEth10g = 'd13;\n\n  localparam integer              BlockIdBits = 16; // must be multiple of 8\n\n  localparam [BlockIdBits-1:0]    BcBlockIdAny = {(BlockIdBits){1'b1}};\n  localparam [BlockIdBits-1:0]    BcBlockIdUser = {1'b1, {(BlockIdBits-1){1'b1}} };\n\n  localparam integer              SpaceIdBits = 4; // 2X this (space+id) must be multiple of 8\n\n  localparam [SpaceIdBits-1:0]    BcSpaceIdAny = {(SpaceIdBits){1'b1}};\n\n  // Like the BC structs, we need these to have unique widths in forward path.  So far they all do.\n\n  // SIMPLE PARALLEL CSR PROTOCOL\n\n  typedef struct                  packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_noc_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [BlockIdBits-1:0] fromblock;\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_noc_fb_s;\n\n  typedef struct            packed {\n    logic [BlockIdBits-1:0] toblock;\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_tree_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_tree_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [31:0]            address;\n    logic [31:0]            wdata;\n  } csr_32_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [31:0]            rdata;\n  } csr_32_fb_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   write;\n    logic                   read;\n    logic [SpaceIdBits-1:0] space;\n    logic [SpaceIdBits-1:0] id;\n    logic [63:0]            address;\n    logic [63:0]            wdata;\n  } csr_64_s;\n\n  typedef struct            packed {\n    logic [5:0]             reserved;\n    logic                   error;\n    logic                   ready;\n    logic [63:0]            rdata;\n  } csr_64_fb_s;\n\n  // DRP PROTOCOL (XILINX IP)\n\n  typedef struct packed {\n    logic        enable;\n    logic [15:0] address;\n    logic        write;\n    logic [15:0] wdata;\n  } drp_s;\n\n  typedef struct packed {\n    logic [15:0] rdata;\n    logic        ready;\n  } drp_fb_s;\n\n  // APB PROTOCOL (AXI PERIPHERAL BUS)\n\n  typedef struct packed {\n    logic        select;\n    logic        enable;\n    logic [31:0] address;\n    logic        write;\n    logic [31:0] wdata;\n  } apb_s;\n\n typedef struct packed {\n    logic [31:0] rdata;\n    logic        ready;\n    logic        error;\n  } apb_fb_s;\n\n  // AXI-LITE 32-BIT PROTOCOL\n\n  typedef struct packed {\n    logic [31:0] awaddr;\n    logic [2:0]  awprot;\n    logic        awvalid;\n    logic [31:0] araddr;\n    logic [2:0]  arprot;\n    logic        arvalid;\n    logic [31:0] wdata;\n    logic [3:0]  wstrb;\n    logic        wvalid;\n    logic        rready;\n    logic        bready;\n  } axil_32_s;\n\n  typedef struct packed {\n    logic [31:0] rdata;\n    logic [1:0]  rresp;\n    logic        rvalid;\n    logic [1:0]  bresp;\n    logic        bvalid;\n    logic        awready;\n    logic        arready;\n    logic        wready;\n  } axil_32_fb_s;\n\n  // ***********************************************************************************************\n  // AXI3 PROTOCOL (currently used for HBM interfaces, which need to migrate to AXI4 below...)\n  // ***********************************************************************************************\n\n  localparam Axi3IdWidth = 6;\n  localparam Axi3AddressWidth = 33;\n  localparam Axi3DataWidth = 256;\n  localparam Axi3DataBytes = (Axi3DataWidth/8);\n\n  typedef struct packed {\n    logic [Axi3AddressWidth-1:0] addr;\n    logic [Axi3IdWidth-1:0]      id;\n    logic [1:0]                  burst;\n    logic [2:0]                  size;\n    logic [3:0]                  len;\n  } axi3_a_s;\n\n  typedef struct packed {\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [Axi3DataBytes-1:0]       strb;\n    logic                           last;\n  } axi3_w_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0]         id;\n    logic [Axi3DataBytes-1:0] [7:0] data;\n    logic [1:0]                     resp;\n    logic                           last;\n  } axi3_r_s;\n\n  typedef struct packed {\n    logic [Axi3IdWidth-1:0] id;\n    logic [1:0]             resp;\n  } axi3_b_s;\n\n  typedef struct packed {\n    axi3_a_s aw;\n    logic    awvalid;\n    axi3_a_s ar;\n    logic    arvalid;\n    axi3_w_s w;\n    logic    wvalid;\n    logic    rready;\n    logic    bready;\n  } axi3_s;\n\n  typedef struct packed {\n    axi3_r_s r;\n    logic    rvalid;\n    axi3_b_s b;\n    logic    bvalid;\n    logic    awready;\n    logic    arready;\n    logic    wready;\n  } axi3_fb_s;\n\n  // ***********************************************************************************************\n  // AXI4-MEMORY MAPPED PROTOCOL (typically used for Memory Interfaces)\n  // ***********************************************************************************************\n\n`define OC_LOCAL_AXI4MM_UNROLL(width) \\\n \\\n  localparam Axi4M``width``IdWidth = 6; /* i.e. Axi4M256IdWidth */ \\\n  localparam Axi4M``width``AddressWidth = 64; /* i.e. Axi4M256AddressWidth */ \\\n  localparam Axi4M``width``DataBytes = (width / 8); /* i.e. Axi4M256DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``AddressWidth-1:0]    addr; \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               burst; \\\n    logic [2:0]                               prot; \\\n    logic [2:0]                               size; \\\n    logic [7:0]                               len; \\\n    logic                                     lock; \\\n    logic [3:0]                               cache; \\\n  } axi4m_``width``_a_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [Axi4M``width``DataBytes-1:0]       strb; \\\n    logic                                     last; \\\n  } axi4m_``width``_w_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [Axi4M``width``DataBytes-1:0] [7:0] data; \\\n    logic [1:0]                               resp; \\\n    logic                                     last; \\\n  } axi4m_``width``_r_s; \\\n \\\n  typedef struct packed { \\\n    logic [Axi4M``width``IdWidth-1:0]         id; \\\n    logic [1:0]                               resp; \\\n  } axi4m_``width``_b_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_a_s                       aw; \\\n    logic                                     awvalid; \\\n    axi4m_``width``_a_s                       ar; \\\n    logic                                     arvalid; \\\n    axi4m_``width``_w_s                       w; \\\n    logic                                     wvalid; \\\n    logic                                     rready; \\\n    logic                                     bready; \\\n  } axi4m_``width``_s; \\\n \\\n  typedef struct packed { \\\n    axi4m_``width``_r_s                       r; \\\n    logic                                     rvalid; \\\n    axi4m_``width``_b_s                       b; \\\n    logic                                     bvalid; \\\n    logic                                     awready; \\\n    logic                                     arready; \\\n    logic                                     wready; \\\n  } axi4m_``width``_fb_s;\n\n  `OC_LOCAL_AXI4MM_UNROLL(32)\n  `OC_LOCAL_AXI4MM_UNROLL(64)\n  `OC_LOCAL_AXI4MM_UNROLL(128)\n  `OC_LOCAL_AXI4MM_UNROLL(256)\n  `OC_LOCAL_AXI4MM_UNROLL(512)\n`undef OC_LOCAL_AXI4MM_UNROLL\n\n  // TODO(drew): We *might* be better off generating these using a cogapp or jinja\n  // template, because #Verilator isn't handling the %p nicely in $display, it would\n  // be easier to generate our own pprint wrapper.\n\n\n  // ***********************************************************************************************\n  // AXI4-STREAM PROTOCOL (Ethernet MAC, etc)\n  // ***********************************************************************************************\n\n  // the \"reset\" signals could use some explanation.  Since AXI4ST is often used for MACs, which like\n  // to signal reset when the link is down, we carry this in the AXI bus.  RX side will drive the\n  // reset in parallel with the data, TX side will drive reset \"backwards\" to user on the _fb channel.\n\n  // Flags for {tuser, tlast, tvalid, reset} are in bits[3:0], so any struct can be cast as\n  // axi4st_8_s to check for flags.\n\n `define OC_LOCAL_AXI4ST_UNROLL(width) \\\n \\\n  localparam Axi4St``width``DataBytes = (width / 8); /* i.e. Axi4St512DataBytes */ \\\n \\\n  typedef struct packed { \\\n    logic [Axi4St``width``DataBytes * 8 - 1 : 0] tdata; \\\n    logic [Axi4St``width``DataBytes     -1  : 0] tkeep; \\\n    logic                                        tuser; \\\n    logic                                        tlast; \\\n    logic                                        tvalid; \\\n   } axi4st_``width``_s; \\\n\\\n  typedef struct packed { \\\n    logic         tready; \\\n    logic         reset; \\\n  } axi4st_``width``_fb_s;\n\n  `OC_LOCAL_AXI4ST_UNROLL(8)\n  `OC_LOCAL_AXI4ST_UNROLL(16)\n  `OC_LOCAL_AXI4ST_UNROLL(32)\n  `OC_LOCAL_AXI4ST_UNROLL(64)\n  `OC_LOCAL_AXI4ST_UNROLL(128)\n  `OC_LOCAL_AXI4ST_UNROLL(256)\n  `OC_LOCAL_AXI4ST_UNROLL(512)\n  `undef OC_LOCAL_AXI4ST_UNROLL\n\nendpackage\n\n\n// src_file='/home/drew/github/eth-puzzles/test_l2_switch_lite_6/custom_tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule custom_tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 100; // For this custom_tb.sv, drive it at 100%\n      u_drv.m_out_tvalid_pct = 100;  // Similarly, stream out at 100% (assume upstream store/forward FIFO too)\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n\n\n// src_file='/home/drew/github/eth-puzzles/eda.work/tb_dut_l2_switch_lite_6_test_sim/tb.sv' \n\n\n// SPDX-License-Identifier: MPL-2.0\n\n// Test for ./dut.sv (refactored oclib_axist_eth_router.sv)\n// This file is refactored (simplified) from oclib_axist_eth_router_test.sv\n\n\n// (Skipping, flagged as only-use-once: `include \"lib/oclib_defines.vh\")\n\nmodule tb;\n\n\n  localparam type AxiStreamType = oclib_pkg::axi4st_128_s;\n  localparam int AxiStreamWidth = 128;\n\n  localparam int unsigned NumPorts        = 4;\n  localparam int unsigned MacTableDepth   = 16;\n  localparam int unsigned MacTableCyclesPerEpoch  = 32'd1_750_000_000;\n\n  logic                   clock;\n  logic                   reset;\n  bit                     stim_done, tb_done;\n  ocsim_tb_control uCONTROL (.clock, .reset, .stimulusDone(stim_done), .checkerDone(tb_done));\n  wire seen_rst = uCONTROL.seen_rst;\n\n  AxiStreamType  [NumPorts - 1 : 0] inAxi4St;\n  logic [NumPorts - 1 : 0]          inTready; // inTready mimics Rx MAC behavior (DUT drives with '1)\n\n  AxiStreamType [NumPorts - 1 : 0]  outAxi4St;\n  logic [NumPorts - 1 : 0]          outTready; // outTready mimics Tx MAC behavior, is not tied to '1 by TB.\n\n  logic [NumPorts - 1 : 0] [NumPorts - 1 : 0] egressFifoDropEvents; // [i][j]=1: Port i dropped pkt from port [j].\n\n  localparam int AxiStreamBytes = (AxiStreamWidth + 7) / 8;\n\n`ifdef TB_COMPILE_ONLY_NO_DUT\ninitial begin @(posedge clock); $display(\"NOTE: TB_COMPILE_ONLY_NO_DUT defined, test finishing after 1 clock cycle\"); oclib_assert_pkg::finish(); end\n`endif\n`ifndef TB_COMPILE_ONLY_NO_DUT\n  dut\n    #(\n      .NumPorts(NumPorts),\n      .AxiStreamType(AxiStreamType),\n      .AxiStreamWidth(AxiStreamWidth),\n      .MacTableDepth(MacTableDepth),\n      .MacTableCyclesPerEpoch(MacTableCyclesPerEpoch)\n      )\n  u_dut\n    (.*);\n`endif // TB_COMPILE_ONLY_NO_DUT\n\n\n  // drivers + monitors\n  generate for (genvar g = 0; g < NumPorts; g++) begin : gen_drv_mon\n    ocsim_axist_driver\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth)\n        )\n    u_drv\n      (.clock,\n       .reset,\n       .outAxi4St(inAxi4St[g]), // --> to DUT\n       .outError(),\n       .outTready(inTready[g])\n       );\n\n    // Simplified, do not check that inTready[g] is tied to 1:\n    //`OC_SYNC_ASSERT_STR(clock, reset, inAxi4St[g].tvalid |-> inTready[g] === 1,\n    //                    $sformatf(\"inTready[g=%0d]=%0d must be 1 when incoming tvalid=1 (Rx Mac port)\",\n    //                              g, inTready[g]));\n\n    ocsim_axist_monitor\n      #(.AxiStreamType(AxiStreamType),\n        .AxiStreamWidth(AxiStreamWidth),\n        .DriveOutTready(1)\n        )\n    u_mon\n      (.clock,\n       .reset,\n       .inAxi4St(outAxi4St[g]),\n       .inError(),\n       .inTready(outTready[g]), // <-- from our driven this module's outTready\n       .outTready(outTready[g])\n       );\n\n    logic mon_in_pkt;\n    oclib_axist_tfirst\n      #(.AxiStreamType(AxiStreamType))\n    u_mon_tfirst\n      (.clock, .reset, .inAxi4St(outAxi4St[g]), .inTready(outTready[g]), .tfirst(),\n       .in_packet(mon_in_pkt) // get this information from the stream.\n       );\n\n    // Simplified, do not check that egress tvalid=1 for an entire packet:\n    //// // Egress path to a Tx MAC: if DUT asserts valid for a packet, valid must be 1 throughout.\n    ////`OC_SYNC_ASSERT(clock, reset, mon_in_pkt |-> outAxi4St[g].tvalid === 1);\n\n    initial begin\n      u_mon.m_out_tready1_pct = 100; // For this tb.sv, drive it at 100%\n      u_drv.m_out_tvalid_pct = 100;  // Similarly, stream out at 100% (assume upstream store/forward FIFO too)\n    end\n  end\n  endgenerate\n\n  import ocsim_packet_pkg::bytequeue_t;\n  import ocsim_packet_pkg::packet_t;\n  import ocsim_packet_pkg::packet_as_string;\n  import ocsim_packet_pkg::compare_packets;\n\n  packet_t main_pkt;\n\n  int main_packets_sent;\n\n  bit [3:0] [47:0] tb_macs;\n  initial begin\n    // get some random mac addresses\n    do begin\n      for (int i = 0; i < 4; i++) begin\n        // rightmost nibble is our port number, for tb.\n        tb_macs[i] = {8'h00, 8'($urandom), 24'($urandom), 8'(i)};\n      end\n    end while (tb_macs[0] == tb_macs[1] ||\n               tb_macs[0] == tb_macs[2] ||\n               tb_macs[0] == tb_macs[3] ||\n               tb_macs[1] == tb_macs[2] ||\n               tb_macs[1] == tb_macs[3] ||\n               tb_macs[2] == tb_macs[3]);\n\n    if (ocsim_pkg::info_verbosity_always()) begin\n      for (int unsigned i = 0; i < 4; i++)\n        $display(\"%t %m: TB mac address %0d: 0x%12x\", $realtime, i, tb_macs[i]);\n    end\n\n  end\n\n  function automatic packet_t add_random_packet(input int srcport,\n                                                input int dstport=-1, // -1 for broadcast/multicast/unknown.\n                                                input int max_size = 1500,\n                                                input int min_size = 64);\n    bytequeue_t bq;\n    packet_t ret;\n    bit [47:0]  smac, dmac;\n\n    bq = ocsim_packet_pkg::get_rand_bytequeue(.max_size(max_size), .min_size(min_size));\n\n    // decide if broadcast, multicast, or unicast to port, or unicast to unknown port.\n    smac = tb_macs[srcport];\n    if (dstport == -1 || dstport >= 4)\n      dmac = {7'($urandom), 1'b1, 8'($urandom), 32'($urandom)}; // multicast or broadcast.\n    // TODO(drew): try unknown unicast?\n    else\n      dmac = tb_macs[dstport];\n\n    // fix our bytequeue for mac info\n    for (int unsigned i = 0; i < 6; i++) begin\n      bq[i]     = dmac[47 - 8 * i -: 8]; // replace first 6B w/ dmac\n      bq[i + 6] = smac[47 - 8 * i -: 8]; // next 6B w/ smac, big Endian for both.\n    end\n\n    case (srcport)\n    0: ret = gen_drv_mon[0].u_drv.add_packet_from_bytequeue(.bq(bq));\n    1: ret = gen_drv_mon[1].u_drv.add_packet_from_bytequeue(.bq(bq));\n    2: ret = gen_drv_mon[2].u_drv.add_packet_from_bytequeue(.bq(bq));\n    3: ret = gen_drv_mon[3].u_drv.add_packet_from_bytequeue(.bq(bq));\n    default: ;\n    endcase // case (srcport)\n\n    if (ocsim_pkg::info_verbosity_high()) begin\n      $display(\"%t %m: Driving packet at srcport=%0d (smac=0x%12x) to dstport=%0d (dmac=0x%12x)\",\n               $realtime, srcport, smac, dstport, dmac);\n    end\n\n    return ret;\n\n  endfunction : add_random_packet\n\n\n\n  function automatic void check_egress_port_for_packet(input packet_t pkt, input int port);\n    packet_t mon;\n    bit was_empty;\n\n    case (port)\n    0: begin\n      if (gen_drv_mon[0].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[0].u_mon.mon_packet_queue.pop_front();\n    end\n    1: begin\n      if (gen_drv_mon[1].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[1].u_mon.mon_packet_queue.pop_front();\n    end\n    2: begin\n      if (gen_drv_mon[2].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[2].u_mon.mon_packet_queue.pop_front();\n    end\n    3: begin\n      if (gen_drv_mon[3].u_mon.mon_packet_queue.size() == 0)\n        was_empty = 1;\n      else\n        mon = gen_drv_mon[3].u_mon.mon_packet_queue.pop_front();\n    end\n    default: ;\n    endcase // case (port)\n\n    if (was_empty) begin\n      `OC_ASSERT_STR(0, $sformatf(\"port=%0d egress is empty, looking for pkt=%s\",\n                                  port, packet_as_string(pkt)));\n      return;\n    end\n\n    compare_packets(.got(mon), .want(pkt), .ignore_id(1),\n                    .str($sformatf(\"egress port=%0d\", port)));\n\n  endfunction : check_egress_port_for_packet\n\n\n  task automatic send_and_check_unicast_rand_packet(input int srcport,\n                                                    input int dstport,\n                                                    input bit skip_check=0);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d\", $realtime, srcport, dstport);\n\n    // We don't allow srcport=dstport here.\n\n    `OC_ASSERT(dstport >= 0);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(dstport));\n    main_packets_sent++;\n\n    if (skip_check)\n      return;\n\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n\n    if (srcport == dstport) begin\n      // Note - I assume the DUT has its routing table figured out by now, so it would be smart enough to drop\n      // a packet like this (seeing an entry with a destination set to itself, which we won't send to).\n      // If you wanted to try this prior to the DUT discovering things, then you'll have to have the TB track\n      // the DUT's routing table to knwo if this is dropped vs. Broadcast.\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving unicast on srcport=%0d -> dstport=%0d (same port) %s\",\n                 $realtime, srcport, dstport, \"This should be dropped at ingress routing, no checking performed\");\n      return;\n    end\n\n    check_egress_port_for_packet(.pkt(pkt), .port(dstport));\n\n  endtask : send_and_check_unicast_rand_packet\n\n\n  task automatic send_and_check_multicast_rand_packet(input int srcport);\n    packet_t pkt;\n\n    if (ocsim_pkg::info_verbosity_medium())\n      $display(\"%t %m: Driving broadcast/multicast on srcport=%0d\", $realtime, srcport);\n\n    pkt = add_random_packet(.srcport(srcport), .dstport(-1)); // dstport=-1 = broadcast/multicast\n    main_packets_sent++;\n    // have to wait at least 2 * AxiStream cycles (driver to send it store/fwd, +monitor to receive ALL of it)\n    repeat(1000 + 2 * pkt.data.size() / AxiStreamBytes) @(posedge clock);\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 1) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 2) % NumPorts));\n    check_egress_port_for_packet(.pkt(pkt), .port((srcport + 3) % NumPorts));\n  endtask : send_and_check_multicast_rand_packet\n\n\n  task automatic wait_mon_idle(input int port);\n    case (port)\n    0: wait (gen_drv_mon[0].u_mon.m_idle);\n    1: wait (gen_drv_mon[0].u_mon.m_idle);\n    2: wait (gen_drv_mon[0].u_mon.m_idle);\n    3: wait (gen_drv_mon[0].u_mon.m_idle);\n    default: ;\n    endcase // case (port)\n  endtask : wait_mon_idle\n\n\n\n\n  initial begin : main\n    @(posedge clock);\n\n    // override some items in the driver/monitor:\n\n    while (seen_rst === 0) @(posedge clock);\n\n    if (ocsim_pkg::info_verbosity_always()) $display(\"%t %m: Start\", $realtime);\n\n    repeat (5) begin\n      // drive exactly 1 packet at a time from port 0, do this 5x\n      if (ocsim_pkg::info_verbosity_medium())\n        $display(\"%t %m: Driving on port0, broadcast/multicast\", $realtime);\n\n      main_pkt = add_random_packet(.srcport(0), .dstport(-1)); // dstport=-1 = broadcast/multicast\n      main_packets_sent++;\n\n      // wait a while\n      while (gen_drv_mon[0].u_drv.num_packets_driven < main_packets_sent) repeat(100) @(posedge clock);\n\n      while (gen_drv_mon[1].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[2].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n      while (gen_drv_mon[3].u_mon.num_packets_received < main_packets_sent) repeat(100) @(posedge clock);\n\n      // ports 1,2,3 should have this packet, b/c their mac address is unknown.\n      check_egress_port_for_packet(.pkt(main_pkt), .port(1));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(2));\n      check_egress_port_for_packet(.pkt(main_pkt), .port(3));\n    end\n\n    // This gets a little goofy b/c now if I sent a packet from 1, it will go to 0, 2, 3 and the packet counts\n    // are screwy.\n    send_and_check_multicast_rand_packet(.srcport(1));\n    send_and_check_multicast_rand_packet(.srcport(2));\n    send_and_check_multicast_rand_packet(.srcport(3));\n\n    // At this point the tables should be populated.\n    // 0 should have Tx'd 3 packets. The others 5 + 2.\n\n    // Should be set up to do unicast routing now.\n\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(0), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(2));\n    send_and_check_unicast_rand_packet(.srcport(1), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(2), .dstport(3));\n\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(0));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(1));\n    send_and_check_unicast_rand_packet(.srcport(3), .dstport(2));\n\n    // Every dstport should have seen 3 packets.\n\n    repeat(50) begin\n      // random port -> random port. This may result in port0 -> port0 mac addresses\n      // (which should get dropped at port0's routing dests)\n      // Note these only get dropped *IF* our table entries are already set up.\n      send_and_check_unicast_rand_packet(.srcport($urandom_range(3)), .dstport($urandom_range(3)));\n    end\n\n    // TODO(drew): confirm epoch timeouts work.\n\n\n\n    stim_done = 1;\n    @(posedge clock);\n\n    gen_drv_mon[0].u_drv.eot_checks();\n    gen_drv_mon[0].u_mon.eot_checks();\n    gen_drv_mon[1].u_drv.eot_checks();\n    gen_drv_mon[1].u_mon.eot_checks();\n    gen_drv_mon[2].u_drv.eot_checks();\n    gen_drv_mon[2].u_mon.eot_checks();\n    gen_drv_mon[3].u_drv.eot_checks();\n    gen_drv_mon[3].u_mon.eot_checks();\n\n    @(posedge clock);\n    tb_done   = 1;\n\n\n  end\n\nendmodule\n",
    "name": "test_l2_switch_lite_6",
    "return_code": 0,
    "stdout": "make: Entering directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_bb732651-91bf-4891-96a6-86cdc024412c_4/obj_dir'\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated.o /tools/verilator/share/verilator/include/verilated.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_timing.o /tools/verilator/share/verilator/include/verilated_timing.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -c -o verilated_threads.o /tools/verilator/share/verilator/include/verilated_threads.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -x c++-header Vtb__pch.h -o Vtb__pch.h.fast.gch\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -x c++-header Vtb__pch.h -o Vtb__pch.h.slow.gch\necho \"\" > Vtb__ALL.verilator_deplist.tmp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb__ConstPool_0.o Vtb__ConstPool_0.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb___024root__Slow.o Vtb___024root__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb___024root__DepSet_hfe20aad3__0__Slow.o Vtb___024root__DepSet_hfe20aad3__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb___024root__DepSet_ha183790c__0__Slow.o Vtb___024root__DepSet_ha183790c__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_oclib_assert_pkg__Slow.o Vtb_oclib_assert_pkg__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.o Vtb_oclib_assert_pkg__DepSet_h2254702a__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_pkg__Slow.o Vtb_ocsim_pkg__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.o Vtb_ocsim_pkg__DepSet_hf1a8d5c7__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.o Vtb_ocsim_pkg__DepSet_h9cfbd5f8__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_packet_pkg__Slow.o Vtb_ocsim_packet_pkg__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0__Slow.cpp\nccache g++   -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.slow -c -o Vtb__Syms.o Vtb__Syms.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb.o Vtb.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__0.o Vtb___024root__DepSet_hfe20aad3__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__1.o Vtb___024root__DepSet_hfe20aad3__1.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__2.o Vtb___024root__DepSet_hfe20aad3__2.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_hfe20aad3__3.o Vtb___024root__DepSet_hfe20aad3__3.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb___024root__DepSet_ha183790c__0.o Vtb___024root__DepSet_ha183790c__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.o Vtb_ocsim_packet_pkg__DepSet_h34fa2989__0.cpp\nccache g++ -Os  -I.  -MMD -I/tools/verilator/share/verilator/include -I/tools/verilator/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TIMING=1 -DVM_TRACE=0 -DVM_TRACE_FST=0 -DVM_TRACE_VCD=0 -faligned-new -fcf-protection=none -Wno-bool-operation -Wno-shadow -Wno-sign-compare -Wno-tautological-compare -Wno-uninitialized -Wno-unused-but-set-parameter -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable    -O0 -DVL_TIME_CONTEXT   -fcoroutines -include Vtb__pch.h.fast -c -o Vtb__main.o Vtb__main.cpp\ng++ -fuse-ld=mold   verilated.o verilated_timing.o verilated_threads.o Vtb__ALL.a    -pthread -lpthread -latomic   -o sim.exe\nrm Vtb__ALL.verilator_deplist.tmp\nmake: Leaving directory '/home/ubuntu/rtl-puzzles/bin/yasaman_tests/work/job_bb732651-91bf-4891-96a6-86cdc024412c_4/obj_dir'\n- V e r i l a t i o n   R e p o r t: Verilator 5.028 2024-08-21 rev v5.028\n- Verilator: Built from 0.437 MB sources in 29 modules, into 3.473 MB in 20 C++ files needing 0.003 MB\n- Verilator: Walltime 4.383 s (elab=0.008, cvt=0.150, bld=3.868); cpu 0.403 s on 64 threads; alloced 173.906 MB\n                   0 TOP.ocsim_pkg.init_trace_plusarg: Starting tracing to ./dump.fst\n-Info: tb.sv:1377: $dumpvar ignored, as Verilated without --trace\n                   0 TOP.tb.unnamedblk2: TB mac address 0: 0x00c41e5d9c00\n                   0 TOP.tb.unnamedblk2: TB mac address 1: 0x0002c2e0e401\n                   0 TOP.tb.unnamedblk2: TB mac address 2: 0x0078d58ebc02\n                   0 TOP.tb.unnamedblk2: TB mac address 3: 0x00b614ffe403\n                   0 TOP.tb.uCONTROL.main: TEST START\n               20000 TOP.tb.main: Start\n               20000 TOP.tb.main: Driving on port0, broadcast/multicast\n             1020000 TOP.tb.main: Driving on port0, broadcast/multicast\n             2020000 TOP.tb.main: Driving on port0, broadcast/multicast\n             3020000 TOP.tb.main: Driving on port0, broadcast/multicast\n             4020000 TOP.tb.main: Driving on port0, broadcast/multicast\n             5020000 TOP.tb.send_and_check_multicast_rand_packet: Driving broadcast/multicast on srcport=1\n[16340000] %Error: tb.sv:6185: Assertion failed in TOP.tb.check_egress_port_for_packet:             16340000 TOP.tb.check_egress_port_for_packet: port=2 egress is empty, looking for pkt={id: 6, error: 0, timestamp_ps=4707148194931277824, data: {size: 1063, data: 71545bb2_055a0002 c2e0e401_04b7f5af aea30b5c_bdbdbc27 2eae7805_95e9e74f e1c55c2a_9db8da23 821a6f99_c856ad28 e912416f_a6e7c2ad 1508b352_ef4105bd 3d48a32c_7e126051 52c7919e_bceb3c50 5318a443_edb6c4f6 0f8e041a_cca65a4b 8ef597ad_a1f2bb64 906101fb_3bbd8fa1 d7c41f67_f9d76aa0 7bcd9ce6_e5881dff 49a5fa1f_40bc0e3c 5b8ebefd_f3872add fd29291f_9a396786 10dfa8ca_ae9a9aef 87c28407_4ae0e235 a663694b_18a0b3f4 fcb7189b_99c69c74 a222d8ed_f886a14b 1eceafe7_9980b6aa 2268003d_9222e2ba f18e79b5_45eb03b1 4c0724e3_3b305db8 80feb721_c44db217 6d377c07_7c3fb805 595c5b7c_261234ae d89a4566_6e8f373e 38035ef9_1b633229 46ea2bf8_fa056c53 8050ef24_d14af7db 72b0c903_b887d68c 54f7ab00_8ac445d9 3503d09c_3386b375 e9de3f80_6ddb4509 38f86dbe_4efe86ba 77a85a4f_f7680415 f057130e_e3a029bd 5d24961d_3786c966 11a1c1a6_c7ad93d8 15d6452c_6d2adaac 0996cae3_45fc2670 e46f2066_4b7770ec 62d3b451_d8443e89 900a87f8_85086cff 095e2699_7c808dee 37825522_ce6d17c8 9cc47e78_77a4dda9 c66e29a7_db9ee306 b2dae931_b1cb7ff4 807f0bcf_d185df27 3c8b113d_93238d16 d05da4f7_1f316161 73f7e464_cee3bd94 71ab87f7_d28df399 3e6066cc_52d6c513 432cf8f7_f621ba05 baac1aaf_457df038 9c12e20c_2b84ebd2 3014b96b_cd09ec8c 1a93da18_0834eeb5 211deb99_9536015d 39b35449_ff62645d 70014fb6_984c2bdf 7547a018_ec1b7dfb 2bf3271e_ccc7a6f3 270f66aa_e0e36c0d e98bcc33_66eb3394 19727d1e_ecdef784 8439c7d8_2ea639b7 10126c64_81614b50 c00b5ca2_b6717f92 60735707_9c1ce0e0 07d933a1_7eb66b0c 9d8b3102_590311ff bcdfaaaa_59afbce5 6b31ac30_1ed6f260 66fcca22_c2fa6665 408baeb2_3a1d1a2d cf7e6d3b_dc0ab7e4 88fefb2a_973ca9e9 a11a3649_a5198d59 acfff763_70eb214f 296ef24a_c7c165fe 317b856f_7f26ba0c 5ae86a1a_7f9c9c98 74993b38_d501ba6c 98ce2f8b_e7772c62 3ffd8add_6784fc81 9e4cce24_58dbd47f 19f75bd0_9ac257dd 3588a26c_670aa7d2 c756c693_89a0add3 9a255de0_f0474358 63f01322_a2c8845c 458b11a0_e65d8509 20830d5c_305c1f69 a2f4e700_babcc0bf 9a371061_2d123f2e c75c0aed_33fadebc 48430bad_7a10ae4e fb65ee5d_46ae1cf2 59c21fa5_6f01c3d8 046a448f_f2037c61 57f16dbf_88773764 370afe2c_97c04e03 328ed3de_d9472dcd 6068fa3f_be660545 46cb832e_69daa300 decd2987_af45f32a 54e2bdd2_da0d3864 18e49345_9fce95d7 716e3e9b_df185679 8f354d64_dbc3b217 361243f5_8076c6a2 833bf827_aba07b4a 8e4978d1_23ce4cb5 127a33a4_a79faccc 6629bbe1_7dbdceea 82d371cf_ecb440e9 6e219af2_df530d1f 4a7725ea_815e628a b862c024_16432fb7 53f91fe9_8277df33 244e4efb_9124e18c 7db92e3b_bfda1a25 dc1e4162_4c6c277a af06b7af_32f84f96 1f64f6d6_4ce22b}} at tb.sv:6185\n%Error: tb.sv:6185: Verilog $stop\nAborting...\n",
    "stderr": "%Warning-LATCH: dut.sv:84:5: Latch inferred for signal 'tb.u_dut.unnamedblk6.found' (not all control paths of combinational always assign a value)\n                           : ... Suggest use of always_latch for intentional latches\n   84 |     always_comb begin\n      |     ^~~~~~~~~~~\n                ... For warning description see https://verilator.org/warn/LATCH?v=5.028\n                ... Use \"/* verilator lint_off LATCH */\" and lint_on around source to disable this message.\n",
    "pass": false,
    "score": 79,
    "warnings": 1,
    "errors": 0,
    "runtime": 4.6214659214019775,
    "batch_iter": 4,
    "batch_uuid": "bb732651-91bf-4891-96a6-86cdc024412c",
    "dut_name": "dut",
    "tb_name": "tb",
    "sim_tool": "verilator",
    "pass_string": "TEST PASS",
    "compile_only": false,
    "timeout": 60,
    "dir": "work/job_bb732651-91bf-4891-96a6-86cdc024412c_4",
    "start_time": 1733527789.879335,
    "stop_time": 1733527794.5008008
  }
]